diff --git a/Component/DLL/Interop.SpeechLib.dll b/Component/DLL/Interop.SpeechLib.dll
deleted file mode 100644
index 21e7355..0000000
Binary files a/Component/DLL/Interop.SpeechLib.dll and /dev/null differ
diff --git a/Component/DLL/LitJson.dll b/Component/DLL/LitJson.dll
deleted file mode 100644
index cfdbe23..0000000
Binary files a/Component/DLL/LitJson.dll and /dev/null differ
diff --git a/Component/Motor/SC_Motor_Angle.cs b/Component/Motor/SC_Motor_Angle.cs
deleted file mode 100644
index 1082f59..0000000
--- a/Component/Motor/SC_Motor_Angle.cs
+++ /dev/null
@@ -1,54 +0,0 @@
-﻿using System;
-using System.Collections;
-using System.Collections.Generic;
-using SDHK_Tool.Dynamic;
-using UnityEngine;
-using UnityEngine.Events;
-
-//遗留提醒：简易电机组未开工
-
-public class SC_Motor_Angle : MonoBehaviour
-{
-
-
-    public Action<float> awt001;
-    // [System.Serializable]
-    public UnityEvent ActionRegistered;
-
-    public float speed = 10;
-
-    public SD_Motor_Angle motor_Angle;
-
-    // Use this for initialization
-    void Start()
-    {
-        motor_Angle = new SD_Motor_Angle();
-
-        ActionRegistered.Invoke();
-
-    }
-
-    // Update is called once per frame
-    void Update()
-    {
-
-        motor_Angle.SetTarget_AngleDelta(speed)
-        .Run_LerpAngle(Time.deltaTime)
-        .Get_MotorSave();
-
-
-        awt001(motor_Angle.Get_MotorSave());
-
-
-
-
-
-    }
-
-
-
-    public void Run_z()
-    {
-        awt001 = (float a) => { transform.localEulerAngles = new Vector3(transform.localPosition.x, a, transform.localPosition.z); };
-    }
-}
diff --git a/Component/Socket/SC_UdpGet.cs b/Component/Socket/SC_UdpGet.cs
deleted file mode 100644
index d92d8af..0000000
--- a/Component/Socket/SC_UdpGet.cs
+++ /dev/null
@@ -1,145 +0,0 @@
-﻿using System.Collections;
-using System.Net;
-using System.Net.Sockets;
-using UnityEngine;
-using SDHK_Tool.Dynamic;
-using System;
-using SDHK_Tool.Static;
-using System.Threading;
-
-
-
-/*
- * 作者：闪电Y黑客
- *
- * 日期：2019.6.20
- * 
- * 功能：Udp消息接收端
- *
- * 注：暂时做为组件
- * 
- */
-
-namespace SDHK_Tool.Component
-{
-
-    /// <summary>
-    /// Udp接收端
-    /// </summary>
-    public class SC_UdpGet : MonoBehaviour
-    {
-        /// <summary>
-        /// 本地IP
-        /// </summary>
-        public string Local_IP;
-        /// <summary>
-        /// 本地端口
-        /// </summary>
-        public int Local_PORT;
-
-        /// <summary>
-        /// 检测心跳超时时间（秒）
-        /// </summary>
-        public float GetOutTime = 3;
-        /// <summary>
-        /// 心跳检测时间间隔（秒）
-        /// </summary>
-        public float ClockTimeDelay = 1;
-        /// <summary>
-        /// 超时标记,是否超时
-        /// </summary>
-        public bool TimeOut = false;
-
-
-        private Queue GetQueue;//用于接收的数据队列
-
-        private UdpClient udpGet;//udp
-
-        private IPEndPoint GetServerPoint;//监听地址
-
-        private SD_Thread GetThread;//数据队列收发线程
-
-        private SD_Thread ClockThread;//心跳线程
-
-        private DateTime LateTime;//心跳计时
-
-        /// <summary>
-        /// 获取接收的消息队列
-        /// </summary>
-        /// <returns>消息队列</returns>
-        public Queue GetDataQueue()
-        {
-            return GetQueue;
-        }
-
-
-        private void Awake()
-        {
-            Refresh();
-        }
-
-        public void Refresh()
-        {
-           if(GetThread!=null)  OnDestroy();
-
-            GetQueue = new Queue();
-            LateTime = DateTime.Now;//刷新心跳时间
-
-            IPAddress ServerIp = Dns.GetHostEntry(Dns.GetHostName()).AddressList[2];
-            Local_IP = ServerIp.ToString(); //获取本地IP
-
-
-            udpGet = new UdpClient(new IPEndPoint(IPAddress.Parse(Local_IP), Local_PORT)); //绑定IP和端口
-            GetServerPoint = new IPEndPoint(IPAddress.Any, 0);//监听接收的所有消息
-
-            //=[线程启动]======
-            GetThread = new SD_Thread(DataQueueProcessor);
-            ClockThread = new SD_Thread(ClockCheck);
-            GetThread.Start();
-            ClockThread.Start();
-        }
-
-        private void DataQueueProcessor(SD_Thread Bit)//数据队列处理器
-        {
-            while (Bit.isStart)
-            {
-                try
-                {
-                    byte[] data = udpGet.Receive(ref GetServerPoint);//阻塞式接受数据
-                    GetQueue.Enqueue(data);//添加到队列
-                    LateTime = DateTime.Now;//刷新心跳时间
-                }
-                catch
-                {
-                }
-            }
-
-        }
-
-        private void ClockCheck(SD_Thread Bit)//心跳检测线程
-        {
-            while (Bit.isStart)
-            {
-                TimeOut = SS_TriggerMarker.Clock_System( LateTime, GetOutTime);//心跳超时检测
-                Thread.Sleep((int)ClockTimeDelay * 1000);//处理延时
-            }
-        }
-
-
-        void OnApplicationQuit()//释放资源
-        {
-            GetThread.End();
-            ClockThread.End();
-            udpGet.Close();
-        }
-        void OnDestroy()//释放资源
-        {
-            GetThread.End();
-            ClockThread.End();
-            udpGet.Close();
-        }
-
-
-    }
-
-}
\ No newline at end of file
diff --git a/Component/Socket/SC_UdpSet.cs b/Component/Socket/SC_UdpSet.cs
deleted file mode 100644
index 2030bcc..0000000
--- a/Component/Socket/SC_UdpSet.cs
+++ /dev/null
@@ -1,130 +0,0 @@
-﻿using System.Collections;
-using System.Net;
-using System.Net.Sockets;
-using UnityEngine;
-using SDHK_Tool.Dynamic;
-using System;
-using SDHK_Tool.Static;
-using System.Threading;
-
-
-/*
- * 作者：闪电Y黑客
- *
- * 日期：2019.6.20
- * 
- * 功能：Udp消息发送端
- *
- * 注：暂时做为组件
- * 
- */
-
-namespace SDHK_Tool.Component
-{
-
-    /// <summary>
-    /// UDP发送端
-    /// </summary>
-    public class SC_UdpSet : MonoBehaviour
-    {
-        /// <summary>
-        /// 目标IP
-        /// </summary>
-        public string SetIP;
-        /// <summary>
-        /// 目标端口
-        /// </summary>
-        public int SetPORT;
-        /// <summary>
-        /// 发送间隔（秒）
-        /// </summary>
-        public float SetTimeDelay = 1;
-        /// <summary>
-        /// 是否启动心跳
-        /// </summary>
-        public bool StartClock = false;
-        /// <summary>
-        /// 心跳发送间隔（秒）
-        /// </summary>
-        public float ClockTimeDelay = 1;
-
-
-
-        private Queue SetQueue;//用于发送的数据队列
-
-        private UdpClient udpSet;//udp
-
-        private IPEndPoint SetServerPoint;//客户端地址
-
-        private SD_Thread SetThread;//客户端接收线程
-
-        private DateTime LateTime;//用于心跳计时
-
-        /// <summary>
-        /// 添加发送数据队列
-        /// </summary>
-        /// <param name="data">要发送的数据</param>
-        public void SetDataQueue(byte[] data)
-        {
-            SetQueue.Enqueue(data);
-        }
-
-        private void Awake()
-        {
-
-            Refresh();
-        }
-
-
-        public void Refresh()
-        {
-
-            if (SetThread != null) OnDestroy();
-
-            SetQueue = new Queue();
-            LateTime = DateTime.Now;//刷新心跳时间
-
-            udpSet = new UdpClient();
-            SetServerPoint = new IPEndPoint(IPAddress.Parse(SetIP), SetPORT);//发送服务器端口IP
-
-            //=[线程启动]======
-            SetThread = new SD_Thread(DataQueueProcessor);
-            SetThread.Start();
-        }
-
-        private void DataQueueProcessor(SD_Thread Bit)//数据队列处理器
-        {
-            while (Bit.isStart)
-            {
-                if (SS_TriggerMarker.Clock_System(LateTime, ClockTimeDelay) && StartClock)//心跳时间判断
-                {
-                    SetQueue.Enqueue(new byte[] { 1 });//心跳消息暂时为Byte 1
-                    LateTime = DateTime.Now;//刷新心跳时间
-                }
-
-                if (SetQueue.Count > 0)//发送数据
-                {
-                    byte[] data = (byte[])SetQueue.Dequeue();
-                    udpSet.Send(data, data.Length, SetServerPoint);//针对发送数据 
-                    LateTime = DateTime.Now;//刷新心跳时间
-                }
-
-                Thread.Sleep((int)SetTimeDelay * 1000);//处理延时
-            }
-        }
-
-
-        void OnApplicationQuit()//释放资源
-        {
-            SetThread.End();
-            udpSet.Close();
-        }
-        void OnDestroy()//释放资源
-        {
-            SetThread.End();
-            udpSet.Close();
-        }
-
-    }
-
-}
\ No newline at end of file
diff --git a/Component/UI/Camera.meta b/Component/UI/Camera.meta
deleted file mode 100644
index 677ec7a..0000000
--- a/Component/UI/Camera.meta
+++ /dev/null
@@ -1,10 +0,0 @@
-fileFormatVersion: 2
-guid: 904e329b731a54d45ac20f7fd9324604
-folderAsset: yes
-timeCreated: 1573459713
-licenseType: Pro
-DefaultImporter:
-  externalObjects: {}
-  userData: 
-  assetBundleName: 
-  assetBundleVariant: 
diff --git a/Component/UI/Camera/SC_WebCamera.cs b/Component/UI/Camera/SC_WebCamera.cs
deleted file mode 100644
index 996e99b..0000000
--- a/Component/UI/Camera/SC_WebCamera.cs
+++ /dev/null
@@ -1,136 +0,0 @@
-﻿using System.Collections;
-using System.Collections.Generic;
-using UnityEngine;
-using UnityEngine.UI;
-
-
-/*
- * 作者：闪电Y黑客
- * 
- * 日期： 2019.9.27
- * 
- * 功能：调用照相机
- */
-
-namespace SDHK_Tool.Component
-{
-    /// <summary>
-    /// 用于调用摄像机拍照
-    /// </summary>
-
-    public class SC_WebCamera : MonoBehaviour
-    {
-        /// <summary>
-        /// 渲染到图片
-        /// </summary>
-        [Tooltip("播放组件")]
-        public RawImage rawImage;
-
-        /// <summary>
-        /// 照相尺寸
-        /// </summary>
-        [Tooltip("照相尺寸")]
-        public Vector2 CameraSize;
-
-        /// <summary>
-        /// 拍照帧数
-        /// </summary>
-        [Tooltip("拍照帧数")]
-        public float CameraFPS;
-
-        /// <summary>
-        /// 接收返回的图片数据  
-        /// </summary>
-        public WebCamTexture webCamera;
-
-        /// <summary>
-        /// 选择设备序号
-        /// </summary>
-        [Tooltip("选择设备序号")]
-        public int DeviceIndex = 0;
-
-        /// <summary>
-        /// 设备列表
-        /// </summary>
-        [Tooltip("设备列表")]
-        public WebCamDevice[] devices;
-
-        // Use this for initialization
-        void Start()
-        {
-            rawImage = GetComponent<RawImage>();
-            WebCamDevice[] devices = WebCamTexture.devices;
-            DeviceIndex = Mathf.Clamp(DeviceIndex, 0, devices.Length - 1);
-
-            try
-            {
-                Initialize(); webCamera.Stop();
-            }
-            catch { }
-        }
-
-        /// <summary>
-        /// 初始化摄像机
-        /// </summary>
-        public void Initialize()
-        {
-            Application.RequestUserAuthorization(UserAuthorization.WebCam);
-            if (Application.HasUserAuthorization(UserAuthorization.WebCam))
-            {
-                webCamera = new WebCamTexture(devices[DeviceIndex].name, (int)CameraSize.x, (int)CameraSize.y, (int)CameraFPS);
-                if (rawImage != null) rawImage.texture = webCamera;
-                webCamera.Play();
-            }
-        }
-
-
-        /// <summary>
-        /// 切换设备
-        /// </summary>
-        public void SwitchDevice()
-        {
-            DeviceIndex++;
-            DeviceIndex %= devices.Length;
-            CameraStop();
-            Initialize();
-        }
-
-        /// <summary>
-        /// 获取照片 ：暂停后获取就不会出现照片错位 
-        /// </summary>
-        /// <returns>获取到的图形Texture2D</returns>
-        public Texture2D Get_Texture2D()
-        {
-            Texture2D texture2D = new Texture2D(webCamera.width, webCamera.height, TextureFormat.ARGB32, true);
-            texture2D.SetPixels(webCamera.GetPixels());
-            texture2D.Apply();
-            return texture2D;
-        }
-
-        /// <summary>
-        /// 摄像机开始摄像
-        /// </summary>
-        public void CameraPlay()
-        {
-            webCamera.Play();
-        }
-
-        /// <summary>
-        /// 摄像机关闭摄像
-        /// </summary>
-        public void CameraStop()
-        {
-            webCamera.Stop();
-        }
-
-        /// <summary>
-        /// 摄像机暂停摄像
-        /// </summary>
-        public void CameraPause()
-        {
-            webCamera.Pause();
-        }
-
-    }
-
-}
\ No newline at end of file
diff --git a/Component/UI/ScrollGroup.meta b/Component/UI/ScrollGroup.meta
deleted file mode 100644
index fd57337..0000000
--- a/Component/UI/ScrollGroup.meta
+++ /dev/null
@@ -1,10 +0,0 @@
-fileFormatVersion: 2
-guid: 21f27762dee700740922ebb720658d50
-folderAsset: yes
-timeCreated: 1572851179
-licenseType: Pro
-DefaultImporter:
-  externalObjects: {}
-  userData: 
-  assetBundleName: 
-  assetBundleVariant: 
diff --git a/Component/UI/ScrollGroup/Base.meta b/Component/UI/ScrollGroup/Base.meta
deleted file mode 100644
index a0d5e0c..0000000
--- a/Component/UI/ScrollGroup/Base.meta
+++ /dev/null
@@ -1,10 +0,0 @@
-fileFormatVersion: 2
-guid: a0be444220397fd41a9a4b39780de44d
-folderAsset: yes
-timeCreated: 1572919246
-licenseType: Pro
-DefaultImporter:
-  externalObjects: {}
-  userData: 
-  assetBundleName: 
-  assetBundleVariant: 
diff --git a/Component/UI/SequenceFrame.meta b/Component/UI/SequenceFrame.meta
deleted file mode 100644
index 4192cd3..0000000
--- a/Component/UI/SequenceFrame.meta
+++ /dev/null
@@ -1,10 +0,0 @@
-fileFormatVersion: 2
-guid: fbbc6a7caa0ecdf44b1daefdfdbb1037
-folderAsset: yes
-timeCreated: 1569722905
-licenseType: Pro
-DefaultImporter:
-  externalObjects: {}
-  userData: 
-  assetBundleName: 
-  assetBundleVariant: 
diff --git a/Component/WinModel.cs b/Component/WinModel.cs
deleted file mode 100644
index 29cf319..0000000
--- a/Component/WinModel.cs
+++ /dev/null
@@ -1,265 +0,0 @@
-﻿using UnityEngine;
-using System.Collections;
-using System.Runtime.InteropServices;
-using System;
-using System.Xml;
-using System.IO;
-using System.Diagnostics;
-using SDHK_Tool.Static;
-
-
-
-/// <summary>
-/// 更改窗口大小脚本
-/// </summary>
-public class WinModel : MonoBehaviour
-{
-    #region
-    //public Rect screenPosition;
-
-    //[DllImport("user32.dll")]
-
-    //static extern IntPtr SetWindowLong(IntPtr hwnd, int _nIndex, int dwNewLong);
-
-    //[DllImport("user32.dll")]
-
-    //static extern bool SetWindowPos(IntPtr hWnd, int hWndInsertAfter, int X, int Y, int cx, int cy, uint uFlags);
-
-    //[DllImport("user32.dll")]
-
-    //static extern IntPtr GetForegroundWindow();
-
-    //// not used rigth now
-
-    ////const uint SWP_NOMOVE = 0x2;
-
-    ////const uint SWP_NOSIZE = 1;
-
-    ////const uint SWP_NOZORDER = 0x4;
-
-    ////const uint SWP_HIDEWINDOW = 0x0080; 
-
-    //const uint SWP_SHOWWINDOW = 0x0040;
-
-    //const int GWL_STYLE = -16;
-
-    //const int WS_BORDER = 1;
-
-    ////  public bool GGPM = false;
-    //// Use this for initialization
-    //void Start()
-    //{
-
-    //    SetWindowLong(GetForegroundWindow(), GWL_STYLE, WS_BORDER);
-
-    //    bool result = SetWindowPos(GetForegroundWindow(), 0, (int)screenPosition.x, (int)screenPosition.y, (int)screenPosition.width, (int)screenPosition.height, SWP_SHOWWINDOW);
-    //    // GGPM = true;
-    //}
-    #endregion
-
-    /// <summary>  
-    /// 窗口左上角x  
-    /// </summary>  
-    public int winPosX;
-    /// <summary>  
-    /// 窗口左上角y  
-    /// </summary>  
-    public int winPosY;
-
-    /// <summary>  
-    /// 窗口宽度  
-    /// </summary>  
-    public int winWidth;
-    /// <summary>  
-    /// 窗口高度  
-    /// </summary>  
-    public int winHeight;
-
-    public bool isWin;
-
-    public delegate bool WNDENUMPROC(IntPtr hwnd, uint lParam);
-    [DllImport("user32.dll", SetLastError = true)]
-    public static extern bool EnumWindows(WNDENUMPROC lpEnumFunc, uint lParam);
-    [DllImport("user32.dll", SetLastError = true)]
-    public static extern IntPtr GetParent(IntPtr hWnd);
-    [DllImport("user32.dll")]
-    public static extern uint GetWindowThreadProcessId(IntPtr hWnd, ref uint lpdwProcessId);
-    [DllImport("kernel32.dll")]
-    public static extern void SetLastError(uint dwErrCode);
-
-
-
-    [DllImport("user32.dll")]
-    static extern IntPtr SetWindowLong(IntPtr hwnd, int _nIndex, int dwNewLong);
-    [DllImport("user32.dll")]
-    static extern bool SetWindowPos(IntPtr hWnd, int hWndInsertAfter, int X, int Y, int cx, int cy, uint uFlags);
-    [DllImport("user32.dll")]
-    static extern IntPtr GetForegroundWindow();
-
-    [DllImport("User32.dll", EntryPoint = "GetSystemMetrics")]
-    public static extern IntPtr GetSystemMetrics(int nIndex);
-
-    public static readonly System.IntPtr HWND_TOPMOST = new System.IntPtr(-1);
-
-    const int SM_CXSCREEN = 0x00000000;
-    const int SM_CYSCREEN = 0x00000001;
-
-    const uint SWP_SHOWWINDOW = 0x0040;
-    const int GWL_STYLE = -16;
-    const int WS_BORDER = 1;
-    const int WS_POPUP = 0x800000;
-
-    public static string _WindowTitle;
-
-
-    public static IntPtr GetProcessWnd()
-    {
-        IntPtr ptrWnd = IntPtr.Zero;
-        uint pid = (uint)Process.GetCurrentProcess().Id;  // 当前进程 ID  
-        bool bResult = EnumWindows(new WNDENUMPROC(delegate (IntPtr hwnd, uint lParam)
-    {
-        uint id = 0;
-        if (GetParent(hwnd) == IntPtr.Zero)
-        {
-            GetWindowThreadProcessId(hwnd, ref id);
-            if (id == lParam)    // 找到进程对应的主窗口句柄  
-            {
-                ptrWnd = hwnd;   // 把句柄缓存起来  
-                SetLastError(0);    // 设置无错误  
-                return false;   // 返回 false 以终止枚举窗口  
-            }
-        }
-        return true;
-    }), pid);
-        return (!bResult && Marshal.GetLastWin32Error() == 0) ? ptrWnd : IntPtr.Zero;
-    }
-
-    void Awake()
-    {
-// #if UNITY_EDITOR
-
-
-
-// #else
-
-        
-        int resWidth = (int)GetSystemMetrics(SM_CXSCREEN);
-        int resHeight = (int)GetSystemMetrics(SM_CYSCREEN);
-        
-        winPosX = 0;
-        winPosY = 0;
-        //winWidth = 1920;
-        //winHeight = 720;
-        //当前屏幕分辨率  
-
-        string filepath = Application.streamingAssetsPath + "/XML/WinInfo.xml";
-        //Debug.Log(filepath);
-        if (File.Exists(filepath))
-        {
-            XmlDocument xmlDoc = new XmlDocument();
-            xmlDoc.Load(filepath);
-            XmlNodeList nodelist = xmlDoc.SelectSingleNode("Window").ChildNodes;
-            foreach (XmlElement xe in nodelist)
-            {
-                if (xe.GetAttribute("isWindow") == "Yes")
-                {
-                    UnityEngine.Debug.Log("ISWin");
-                    isWin = true;
-                    foreach (XmlElement xe1 in xe.ChildNodes)
-                    {
-                        string X = xe1.GetAttribute("winposX");
-                        String Y = xe1.GetAttribute("winposY");
-                        string W = xe1.GetAttribute("winWidth");
-                        string H = xe1.GetAttribute("winHeight");
-                        _WindowTitle = xe1.GetAttribute("windowTielt");
-                        winPosX = int.Parse(X);
-                        winPosY = int.Parse(Y);
-                        winWidth = int.Parse(W);
-                        winHeight = int.Parse(H);
-                    }
-                }
-                else
-                {
-                    isWin = false;
-                }
-            }
-        }
-
-        if (isWin)
-        {
-            
-
-            SetWindowLong(GetProcessWnd(), GWL_STYLE, WS_POPUP & WS_BORDER);
-            //测试发现左下角坐标为（0,1),修改如下  
-            bool result = SetWindowPos(GetProcessWnd(), -1, winPosX, winPosY, winWidth, winHeight, SWP_SHOWWINDOW);
-            //bool result = SetWindowPos(GetForegroundWindow(), 0, winPosX, winPosY, winWidth, winHeight, SWP_SHOWWINDOW); 
-        }
-
-        //winPosX = resWidth / 2 - winWidth / 2;
-        // winPosY = resHeight / 2 - winHeight / 2 - 1;
-
-// #endif
-
-
-
-    }
-    void Update()
-    {
-        if (isWin)
-        {
-            if (Input.GetKey(KeyCode.Q) && Input.GetKeyDown(KeyCode.DownArrow))
-            {
-                bool result = SetWindowPos(GetProcessWnd(), 0, winPosX, winPosY, winWidth, winHeight, SWP_SHOWWINDOW);
-            }
-        }
-    }
-
-    void OnGUI()
-    {
-
-    }
-
-
-
-
-    /// <summary>  
-    /// 窗口左上角x  
-    /// </summary>  
-    public void SetWinPosX(int winPosX)
-    {
-
-        this.winPosX = winPosX;
-    }
-    /// <summary>  
-    /// 窗口左上角y  
-    /// </summary>  
-    public void SetWinPosY(int winPosY)
-    {
-
-        this.winPosY = winPosY;
-    }
-
-    /// <summary>  
-    /// 窗口宽度  
-    /// </summary>  
-    public void SetWinWidth(int winWidth)
-    {
-
-        this.winWidth = winWidth;
-    }
-    /// <summary>  
-    /// 窗口高度  
-    /// </summary>  
-    public void SetWinHeight(int winHeight)
-    {
-
-        this.winHeight = winHeight;
-    }
-
-    public void SetIsWin(bool isWin)
-    {
-
-        this.isWin = isWin;
-    }
-
-}
diff --git a/Dynamic/NeuralNetwork.meta b/Dynamic/NeuralNetwork.meta
deleted file mode 100644
index d63de2b..0000000
--- a/Dynamic/NeuralNetwork.meta
+++ /dev/null
@@ -1,10 +0,0 @@
-fileFormatVersion: 2
-guid: 147779f51c7d2264cb8b3c6e0750f684
-folderAsset: yes
-timeCreated: 1576668357
-licenseType: Pro
-DefaultImporter:
-  externalObjects: {}
-  userData: 
-  assetBundleName: 
-  assetBundleVariant: 
diff --git a/Dynamic/NeuralNetwork/PerceptionMachine.meta b/Dynamic/NeuralNetwork/PerceptionMachine.meta
deleted file mode 100644
index 0de8558..0000000
--- a/Dynamic/NeuralNetwork/PerceptionMachine.meta
+++ /dev/null
@@ -1,10 +0,0 @@
-fileFormatVersion: 2
-guid: fa2069e736f9eae4b8bad9c097c89174
-folderAsset: yes
-timeCreated: 1576668382
-licenseType: Pro
-DefaultImporter:
-  externalObjects: {}
-  userData: 
-  assetBundleName: 
-  assetBundleVariant: 
diff --git a/Dynamic/Other.meta b/Dynamic/Other.meta
deleted file mode 100644
index 1a75f53..0000000
--- a/Dynamic/Other.meta
+++ /dev/null
@@ -1,10 +0,0 @@
-fileFormatVersion: 2
-guid: c852d1c6e1417cb44a17a97ac39ef38e
-folderAsset: yes
-timeCreated: 1567056695
-licenseType: Pro
-DefaultImporter:
-  externalObjects: {}
-  userData: 
-  assetBundleName: 
-  assetBundleVariant: 
diff --git a/Dynamic/SD_Thread.cs b/Dynamic/SD_Thread.cs
deleted file mode 100644
index 8ec605a..0000000
--- a/Dynamic/SD_Thread.cs
+++ /dev/null
@@ -1,48 +0,0 @@
-﻿using System;
-using System.Threading;
-
-/*
- * 作者：闪电Y黑客
- * 
- * 日期： 2019.6.11
- * 
- * 功能：可让线程安全退出
- */
-
-namespace SDHK_Tool.Dynamic
-{
-	
-	/// <summary>
-	/// 标记式线程
-	/// </summary>
-    public class SD_Thread 
-    {
-		public bool isStart = false;
-        public Thread thread;
-
-		//线程添加
-        public SD_Thread(Action<SD_Thread> action)
-        {
-            thread = new Thread(() => { action(this); })
-            { IsBackground = true };//设置为后台线程
-        }
-
-        /// <summary>
-        /// 线程启动
-        /// </summary>
-        public void Start()
-        {
-            isStart = true;
-            thread.Start();
-        }
-
-        /// <summary>
-        /// 线程退出
-        /// </summary>
-        public void End()
-        {
-            isStart = false;
-        }
-
-    }
-}
\ No newline at end of file
diff --git a/Extension/SE_Transform.cs b/Extension/SE_Transform.cs
deleted file mode 100644
index 27d371b..0000000
--- a/Extension/SE_Transform.cs
+++ /dev/null
@@ -1,445 +0,0 @@
-﻿using System.Collections;
-using System.Collections.Generic;
-using UnityEngine;
-using SDHK_Tool.Static;
-
-
-/*
- * 作者：闪电Y黑客
- * 
- * 日期： 2019.10.23
- * 
- * 功能：Transform类的扩展方法
- */
-
-namespace SDHK_Tool.Extension
-{
-    /// <summary>
-    /// Transform的扩展方法类
-    /// </summary>
-    public static class SE_Transform
-    {
-        /// <summary>
-        /// 直接输入参数
-        /// </summary>
-        public static Vector3 SE_Position(this Transform transform, float x, float y, float z)
-        {
-            return transform.position = new Vector3(x, y, z);
-        }
-
-        /// <summary>
-        /// 单独修改x值
-        /// </summary>
-        public static Vector3 SE_Position_X(this Transform transform, float x)
-        {
-            return transform.position = new Vector3(x, transform.position.y, transform.position.z);
-        }
-
-        /// <summary>
-        /// 单独修改y值
-        /// </summary>
-        public static Vector3 SE_Position_Y(this Transform transform, float y)
-        {
-            return transform.position = new Vector3(transform.position.x, y, transform.position.z);
-        }
-
-        /// <summary>
-        /// 单独修改z值
-        /// </summary>
-        public static Vector3 SE_Position_Z(this Transform transform, float z)
-        {
-            return transform.position = new Vector3(transform.position.x, transform.position.y, z);
-        }
-
-
-
-        /// <summary>
-        /// 直接输入参数
-        /// </summary>
-        public static Vector3 SE_LocalPosition(this Transform transform, float x, float y, float z)
-        {
-            return transform.localPosition = new Vector3(x, y, z);
-        }
-
-        /// <summary>
-        /// 单独修改x值
-        /// </summary>
-        public static Vector3 SE_LocalPosition_X(this Transform transform, float x)
-        {
-            return transform.localPosition = new Vector3(x, transform.localPosition.y, transform.localPosition.z);
-        }
-
-        /// <summary>
-        /// 单独修改y值
-        /// </summary>
-        public static Vector3 SE_LocalPosition_Y(this Transform transform, float y)
-        {
-            return transform.localPosition = new Vector3(transform.localPosition.x, y, transform.localPosition.z);
-        }
-
-        /// <summary>
-        /// 单独修改z值
-        /// </summary>
-        public static Vector3 SE_LocalPosition_Z(this Transform transform, float z)
-        {
-            return transform.localPosition = new Vector3(transform.localPosition.x, transform.localPosition.y, z);
-        }
-
-
-
-        /// <summary>
-        /// 直接输入参数
-        /// </summary>
-        public static Vector3 SE_EulerAngles(this Transform transform, float x, float y, float z)
-        {
-            return transform.eulerAngles = new Vector3(x, y, z);
-        }
-
-        /// <summary>
-        /// 单独修改x值
-        /// </summary>
-        public static Vector3 SE_EulerAngles_X(this Transform transform, float x)
-        {
-            return transform.eulerAngles = new Vector3(x, transform.eulerAngles.y, transform.eulerAngles.z);
-        }
-
-        /// <summary>
-        /// 单独修改y值
-        /// </summary>
-        public static Vector3 SE_EulerAngles_Y(this Transform transform, float y)
-        {
-            return transform.eulerAngles = new Vector3(transform.eulerAngles.x, y, transform.eulerAngles.z);
-        }
-
-        /// <summary>
-        /// 单独修改z值
-        /// </summary>
-        public static Vector3 SE_EulerAngles_Z(this Transform transform, float z)
-        {
-            return transform.eulerAngles = new Vector3(transform.eulerAngles.x, transform.eulerAngles.y, z);
-        }
-
-
-
-        /// <summary>
-        /// 直接输入参数
-        /// </summary>
-        public static Vector3 SE_LocalEulerAngles(this Transform transform, float x, float y, float z)
-        {
-            return transform.localEulerAngles = new Vector3(x, y, z);
-        }
-
-        /// <summary>
-        /// 单独修改x值
-        /// </summary>
-        public static Vector3 SE_LocalEulerAngles_X(this Transform transform, float x)
-        {
-            return transform.localEulerAngles = new Vector3(x, transform.localEulerAngles.y, transform.localEulerAngles.z);
-        }
-
-        /// <summary>
-        /// 单独修改y值
-        /// </summary>
-        public static Vector3 SE_LocalEulerAngles_Y(this Transform transform, float y)
-        {
-            return transform.localEulerAngles = new Vector3(transform.localEulerAngles.x, y, transform.localEulerAngles.z);
-        }
-
-        /// <summary>
-        /// 单独修改z值
-        /// </summary>
-        public static Vector3 SE_LocalEulerAngles_Z(this Transform transform, float z)
-        {
-            return transform.localEulerAngles = new Vector3(transform.localEulerAngles.x, transform.localEulerAngles.y, z);
-        }
-
-
-
-        /// <summary>
-        /// 直接输入参数
-        /// </summary>
-        public static Vector3 SE_LocalScale(this Transform transform, float x, float y, float z)
-        {
-            return transform.localScale = new Vector3(x, y, z);
-        }
-
-        /// <summary>
-        /// 单独修改x值
-        /// </summary>
-        public static Vector3 SE_LocalScale_X(this Transform transform, float x)
-        {
-            return transform.localScale = new Vector3(x, transform.localScale.y, transform.localScale.z);
-        }
-
-        /// <summary>
-        /// 单独修改y值
-        /// </summary>
-        public static Vector3 SE_LocalScale_Y(this Transform transform, float y)
-        {
-            return transform.localScale = new Vector3(transform.localScale.x, y, transform.localScale.z);
-        }
-
-        /// <summary>
-        /// 单独修改z值
-        /// </summary>
-        public static Vector3 SE_LocalScale_Z(this Transform transform, float z)
-        {
-            return transform.localScale = new Vector3(transform.localScale.x, transform.localScale.y, z);
-        }
-
-
-        /// <summary>
-        /// 单独修改x值
-        /// </summary>
-        public static Vector2 SE_AnchoredPosition_X(this RectTransform rectTransform, float x)
-        {
-            return rectTransform.anchoredPosition = new Vector2(x, rectTransform.anchoredPosition.y);
-        }
-
-        /// <summary>
-        /// 单独修改y值
-        /// </summary>
-        public static Vector2 SE_AnchoredPosition_Y(this RectTransform rectTransform, float y)
-        {
-            return rectTransform.anchoredPosition = new Vector2(rectTransform.anchoredPosition.x, y);
-        }
-
-        /// <summary>
-        /// 世界坐标转局部坐标
-        /// </summary>
-        /// <param name="WorldPoint">世界坐标点</param>
-        /// <returns>局部坐标</returns>
-        public static Vector3 SE_World_To_local(this Transform transform, Vector3 WorldPoint)
-        {
-            return transform.InverseTransformPoint(WorldPoint);
-        }
-
-        /// <summary>
-        /// 局部坐标转世界坐标
-        /// </summary>
-        /// <param name="LocalPoint">局部坐标点</param>
-        /// <returns>世界坐标</returns>
-        public static Vector3 SE_Local_To_World(this Transform transform, Vector3 LocalPoint)
-        {
-            return transform.TransformPoint(LocalPoint);
-        }
-
-
-        /// <summary>
-        /// 局部坐标转局部坐标
-        /// </summary>
-        /// <param name="CurrentTransform">当前坐标系</param>
-        /// <param name="LocalPoint">当前局部坐标点</param>
-        /// <returns>局部坐标点</returns>
-        public static Vector3 SE_Local_To_Local(this Transform transform, Transform CurrentTransform, Vector3 LocalPoint)
-        {
-            return transform.InverseTransformPoint(CurrentTransform.TransformPoint(LocalPoint));
-        }
-
-
-
-
-
-        /// <summary>
-        /// 匀速移动
-        /// </summary>
-        /// <param name="TargetPosition">目标位置</param>
-        /// <param name="MoveSpeed">移动速度</param>
-        /// <param name="space">坐标系</param>
-        public static void SE_Position_MoveTowards(this Transform transform, Vector3 TargetPosition, float MoveSpeed, Space space = Space.World)
-        {
-            if (space == Space.World)
-                transform.position = Vector3.MoveTowards(transform.position, TargetPosition, MoveSpeed);
-            else
-                transform.localPosition = Vector3.MoveTowards(transform.localPosition, TargetPosition, MoveSpeed);
-        }
-
-        /// <summary>
-        /// 差值移动
-        /// </summary>
-        /// <param name="TargetPosition">目标位置</param>
-        /// <param name="MoveSpeed">移动速度</param>
-        /// <param name="space">坐标系</param>
-        public static void SE_Position_Lerp(this Transform transform, Vector3 TargetPosition, float MoveSpeed, Space space = Space.World)
-        {
-            if (space == Space.World)
-                transform.position = Vector3.Lerp(transform.position, TargetPosition, MoveSpeed);
-            else
-                transform.localPosition = Vector3.Lerp(transform.localPosition, TargetPosition, MoveSpeed);
-        }
-
-        /// <summary>
-        /// 平滑移动
-        /// </summary>
-        /// <param name="TargetPosition">目标位置</param>
-        /// <param name="MoveTime">移动速度</param>
-        /// <param name="space">坐标系</param>
-        /// <returns> 移动速度</returns>
-        public static Vector3 SE_Position_SmoothDamp(this Transform transform, Vector3 TargetPosition, float MoveTime, Space space = Space.World)
-        {
-            Vector3 yVelocity = new Vector3();
-
-            if (space == Space.World)
-                transform.position = Vector3.SmoothDamp(transform.position, TargetPosition, ref yVelocity, MoveTime);
-            else
-                transform.localPosition = Vector3.SmoothDamp(transform.localPosition, TargetPosition, ref yVelocity, MoveTime);
-
-            return yVelocity;
-        }
-
-
-
-        /// <summary>
-        /// 欧拉角匀速旋转
-        /// </summary>
-        /// <param name="TargetEulerAngle">目标欧拉角</param>
-        /// <param name="RotatingMoveSpeed">旋转速度</param>
-        /// <param name="space">坐标系</param>
-        public static void SE_EulerAngles_MoveTowards(this Transform transform, Vector3 TargetEulerAngle, float RotatingMoveSpeed, Space space = Space.World)
-        {
-            if (space == Space.World)
-                transform.eulerAngles = SS_EulerAngleRotation.EulerAngles_MoveTowards(transform.eulerAngles, TargetEulerAngle, RotatingMoveSpeed);
-            else
-                transform.localEulerAngles = SS_EulerAngleRotation.EulerAngles_MoveTowards(transform.localEulerAngles, TargetEulerAngle, RotatingMoveSpeed);
-        }
-
-        /// <summary>
-        /// 欧拉角插值旋转
-        /// </summary>
-        /// <param name="TargetEulerAngle">目标欧拉角</param>
-        /// <param name="RotatingMoveSpeed">旋转速度</param>
-        /// <param name="space">坐标系</param>
-        public static void SE_EulerAngles_Lerp(this Transform transform, Vector3 TargetEulerAngle, float RotatingMoveSpeed, Space space = Space.World)
-        {
-            if (space == Space.World)
-                transform.eulerAngles = SS_EulerAngleRotation.EulerAngles_Lerp(transform.eulerAngles, TargetEulerAngle, RotatingMoveSpeed);
-            else
-                transform.localEulerAngles = SS_EulerAngleRotation.EulerAngles_Lerp(transform.localEulerAngles, TargetEulerAngle, RotatingMoveSpeed);
-        }
-
-        /// <summary>
-        /// 欧拉角平滑旋转
-        /// </summary>
-        /// <param name="TargetEulerAngle">目标欧拉角</param>
-        /// <param name="MoveTime">旋转时间</param>
-        /// <param name="space">坐标系</param>
-        /// <returns>旋转速度</returns>
-        public static Vector3 SE_EulerAngles_SmoothDamp(this Transform transform, Vector3 TargetEulerAngle, float MoveTime, Space space = Space.World)
-        {
-            Vector3 yVelocity = new Vector3();
-
-            if (space == Space.World)
-                transform.eulerAngles = SS_EulerAngleRotation.EulerAngles_SmoothDamp(transform.eulerAngles, TargetEulerAngle, ref yVelocity, MoveTime);
-            else
-                transform.localEulerAngles = SS_EulerAngleRotation.EulerAngles_SmoothDamp(transform.localEulerAngles, TargetEulerAngle, ref yVelocity, MoveTime);
-
-            return yVelocity;
-        }
-
-
-
-        /// <summary>
-        /// 匀速缩放
-        /// </summary>
-        /// <param name="TargetPosition">目标尺寸</param>
-        /// <param name="MoveSpeed">缩放速度</param>
-        public static void SE_Scale_MoveTowards(this Transform transform, Vector3 TargetPosition, float MoveSpeed)
-        {
-            transform.localScale = Vector3.MoveTowards(transform.localScale, TargetPosition, MoveSpeed);
-        }
-
-        /// <summary>
-        /// 差值缩放
-        /// </summary>
-        /// <param name="TargetPosition">目标尺寸</param>
-        /// <param name="MoveSpeed">缩放速度</param>
-        public static void SE_Scale_Lerp(this Transform transform, Vector3 TargetPosition, float MoveSpeed)
-        {
-            transform.localScale = Vector3.Lerp(transform.localScale, TargetPosition, MoveSpeed);
-        }
-
-        /// <summary>
-        /// 平滑缩放
-        /// </summary>
-        /// <param name="TargetPosition">目标尺寸</param>
-        /// <param name="MoveTime">缩放时间</param>
-        public static Vector3 SE_Scale_SmoothDamp(this Transform transform, Vector3 TargetPosition, float MoveTime)
-        {
-            Vector3 yVelocity = new Vector3();
-            transform.localScale = Vector3.SmoothDamp(transform.localScale, TargetPosition, ref yVelocity, MoveTime);
-            return yVelocity;
-        }
-
-
-
-        /// <summary>
-        /// 三维向量约束
-        /// </summary>
-        /// <param name="Limit_Min">最小值</param>
-        /// <param name="Limit_Max">最大值</param>
-        /// <param name="Limit_X">X轴限制激活</param>
-        /// <param name="Limit_Y">Y轴限制激活</param>
-        /// <param name="Limit_Z">Z轴限制激活</param>
-        /// <param name="space">坐标系</param>
-        public static void SE_Position_Constraint(this Transform transform, Vector3 Limit_Min, Vector3 Limit_Max, bool Limit_X = true, bool Limit_Y = true, bool Limit_Z = true, Space space = Space.World)
-        {
-            if (space == Space.World)
-                transform.position = SS_VectorConstraint.Constraint_Vector3(transform.position, Limit_Min, Limit_Max, Limit_X, Limit_Y, Limit_Z);
-            else
-                transform.localPosition = SS_VectorConstraint.Constraint_Vector3(transform.localPosition, Limit_Min, Limit_Max, Limit_X, Limit_Y, Limit_Z);
-        }
-
-        /// <summary>
-        /// 三维向量球形范围约束
-        /// </summary>
-        /// <param name="TargetPoint">约束点</param>
-        /// <param name="Limit_Radius">限制半径</param>
-        /// <param name="space">坐标系</param>
-        public static void SE_Position_Constraint_Scope(this Transform transform, Vector3 TargetPoint, float Limit_Radius, Space space = Space.World)
-        {
-            if (space == Space.World)
-                transform.position = SS_VectorConstraint.Constraint_Vector3_Scope(transform.position, TargetPoint, Limit_Radius);
-            else
-                transform.localPosition = SS_VectorConstraint.Constraint_Vector3_Scope(transform.localPosition, TargetPoint, Limit_Radius);
-        }
-
-
-        /// <summary>
-        /// 欧拉角约束
-        /// </summary>
-        /// <param name="Limit_Min">最小值</param>
-        /// <param name="Limit_Max">最大值</param>
-        /// <param name="Limit_X">X轴限制激活</param>
-        /// <param name="Limit_Y">Y轴限制激活</param>
-        /// <param name="Limit_Z">Z轴限制激活</param>
-        /// <param name="space">坐标系</param>
-        public static void SE_EulerAngles_Constraint(this Transform transform, Vector3 Limit_Min, Vector3 Limit_Max, bool Limit_X = true, bool Limit_Y = true, bool Limit_Z = true, Space space = Space.World)
-        {
-            if (space == Space.World)
-                transform.eulerAngles = SS_VectorConstraint.Constraint_EulerAngle(transform.eulerAngles, Limit_Min, Limit_Max, Limit_X, Limit_Y, Limit_Z);
-            else
-                transform.localEulerAngles = SS_VectorConstraint.Constraint_EulerAngle(transform.localEulerAngles, Limit_Min, Limit_Max, Limit_X, Limit_Y, Limit_Z);
-        }
-
-
-        /// <summary>
-        /// 尺寸约束
-        /// </summary>
-        /// <param name="Limit_Min">最小值</param>
-        /// <param name="Limit_Max">最大值</param>
-        /// <param name="Limit_X">X轴限制激活</param>
-        /// <param name="Limit_Y">Y轴限制激活</param>
-        /// <param name="Limit_Z">Z轴限制激活</param>
-        public static void SE_Scale_Constraint(this Transform transform, Vector3 Limit_Min, Vector3 Limit_Max, bool Limit_X = true, bool Limit_Y = true, bool Limit_Z = true)
-        {
-            transform.localScale = SS_VectorConstraint.Constraint_Vector3(transform.localScale, Limit_Min, Limit_Max, Limit_X, Limit_Y, Limit_Z);
-        }
-
-
-
-
-
-
-    }
-
-}
\ No newline at end of file
diff --git a/README.md b/README.md
deleted file mode 100644
index 4dc275f..0000000
--- a/README.md
+++ /dev/null
@@ -1,2 +0,0 @@
-﻿# SDHK_Tool
- 工具箱上传，未写完。。。
\ No newline at end of file
diff --git a/Static/SS_TriangleSolutions.cs.meta b/SDHK_Tool/A_Reference/BaiduASR1.cs.meta
similarity index 77%
rename from Static/SS_TriangleSolutions.cs.meta
rename to SDHK_Tool/A_Reference/BaiduASR1.cs.meta
index 4871cd1..51207c8 100644
--- a/Static/SS_TriangleSolutions.cs.meta
+++ b/SDHK_Tool/A_Reference/BaiduASR1.cs.meta
@@ -1,6 +1,6 @@
 fileFormatVersion: 2
-guid: b9174aac444308c4aa69c971cc6a2995
-timeCreated: 1560132408
+guid: 96e47dad25b074f409aee12ed31c5bb2
+timeCreated: 1583472195
 licenseType: Free
 MonoImporter:
   externalObjects: {}
diff --git a/Static/SS_VectorConstraint.cs.meta b/SDHK_Tool/A_Reference/CameraTouch.cs.meta
similarity index 77%
rename from Static/SS_VectorConstraint.cs.meta
rename to SDHK_Tool/A_Reference/CameraTouch.cs.meta
index 72bf372..aae7f41 100644
--- a/Static/SS_VectorConstraint.cs.meta
+++ b/SDHK_Tool/A_Reference/CameraTouch.cs.meta
@@ -1,6 +1,6 @@
 fileFormatVersion: 2
-guid: 97672c9ddc0edbe419d73cb14b4156b8
-timeCreated: 1560413120
+guid: 0bce399757b87a54992a6d8489a262e5
+timeCreated: 1603851778
 licenseType: Free
 MonoImporter:
   externalObjects: {}
diff --git a/SDHK_Tool/A_Reference/LetterSpacing4.cs.meta b/SDHK_Tool/A_Reference/LetterSpacing4.cs.meta
new file mode 100644
index 0000000..b3c9d02
--- /dev/null
+++ b/SDHK_Tool/A_Reference/LetterSpacing4.cs.meta
@@ -0,0 +1,13 @@
+fileFormatVersion: 2
+guid: 782571b0249706748b7bea25eca48c16
+timeCreated: 1593309846
+licenseType: Free
+MonoImporter:
+  externalObjects: {}
+  serializedVersion: 2
+  defaultReferences: []
+  executionOrder: 0
+  icon: {instanceID: 0}
+  userData: 
+  assetBundleName: 
+  assetBundleVariant: 
diff --git a/SDHK_Tool/A_Reference/Loom.cs.meta b/SDHK_Tool/A_Reference/Loom.cs.meta
new file mode 100644
index 0000000..c901402
--- /dev/null
+++ b/SDHK_Tool/A_Reference/Loom.cs.meta
@@ -0,0 +1,13 @@
+fileFormatVersion: 2
+guid: ba0a94b280628dc41a8e7589b1983c1f
+timeCreated: 1596444488
+licenseType: Free
+MonoImporter:
+  externalObjects: {}
+  serializedVersion: 2
+  defaultReferences: []
+  executionOrder: 0
+  icon: {instanceID: 0}
+  userData: 
+  assetBundleName: 
+  assetBundleVariant: 
diff --git a/SDHK_Tool/A_Reference/PengFei/MicRecord/MicCall.cs.meta b/SDHK_Tool/A_Reference/PengFei/MicRecord/MicCall.cs.meta
new file mode 100644
index 0000000..f0f4f87
--- /dev/null
+++ b/SDHK_Tool/A_Reference/PengFei/MicRecord/MicCall.cs.meta
@@ -0,0 +1,13 @@
+fileFormatVersion: 2
+guid: 3ed1b99e51c575447bd0f17e1ec3d467
+timeCreated: 1581409019
+licenseType: Pro
+MonoImporter:
+  externalObjects: {}
+  serializedVersion: 2
+  defaultReferences: []
+  executionOrder: 0
+  icon: {instanceID: 0}
+  userData: 
+  assetBundleName: 
+  assetBundleVariant: 
diff --git a/SDHK_Tool/A_Reference/PengFei/MicRecord/MicroPhoneInput.cs.meta b/SDHK_Tool/A_Reference/PengFei/MicRecord/MicroPhoneInput.cs.meta
new file mode 100644
index 0000000..665e576
--- /dev/null
+++ b/SDHK_Tool/A_Reference/PengFei/MicRecord/MicroPhoneInput.cs.meta
@@ -0,0 +1,13 @@
+fileFormatVersion: 2
+guid: a53f9782d3ca7fd4896d1720d8870b5f
+timeCreated: 1581408603
+licenseType: Pro
+MonoImporter:
+  externalObjects: {}
+  serializedVersion: 2
+  defaultReferences: []
+  executionOrder: 0
+  icon: {instanceID: 0}
+  userData: 
+  assetBundleName: 
+  assetBundleVariant: 
diff --git a/SDHK_Tool/Component/Mesh/Base/SB_Mesh_Skeleton.cs b/SDHK_Tool/Component/Mesh/Base/SB_Mesh_Skeleton.cs
new file mode 100644
index 0000000..3b8e82a
--- /dev/null
+++ b/SDHK_Tool/Component/Mesh/Base/SB_Mesh_Skeleton.cs
@@ -0,0 +1,25 @@
+﻿using System.Collections.Generic;
+using UnityEngine;
+
+/*
+ * 作者：闪电Y黑客
+ * 
+ * 日期： 2019.10.17
+ * 
+ * 功能：网格骨架抽象基类：共同属性：节点集合
+ *
+ */
+
+
+/// <summary>
+/// 网格骨架抽象基类：共同属性：节点集合
+/// </summary>
+public abstract class SB_Mesh_Skeleton : MonoBehaviour
+{
+    /// <summary>
+    /// 骨架节点集合
+    /// </summary>
+	[Tooltip("骨架节点集合列表")]
+    public List<Transform> Pionts;
+
+}
diff --git a/SDHK_Tool/Component/Mesh/Base/SB_Mesh_Skeleton.cs.meta b/SDHK_Tool/Component/Mesh/Base/SB_Mesh_Skeleton.cs.meta
new file mode 100644
index 0000000..8cc1818
--- /dev/null
+++ b/SDHK_Tool/Component/Mesh/Base/SB_Mesh_Skeleton.cs.meta
@@ -0,0 +1,13 @@
+fileFormatVersion: 2
+guid: c0e3dd8e1df39bb43b53c21e36628678
+timeCreated: 1571911585
+licenseType: Pro
+MonoImporter:
+  externalObjects: {}
+  serializedVersion: 2
+  defaultReferences: []
+  executionOrder: 0
+  icon: {instanceID: 0}
+  userData: 
+  assetBundleName: 
+  assetBundleVariant: 
diff --git a/SDHK_Tool/Component/Mesh/SC_Mesh_Deformer.cs b/SDHK_Tool/Component/Mesh/SC_Mesh_Deformer.cs
new file mode 100644
index 0000000..7260040
--- /dev/null
+++ b/SDHK_Tool/Component/Mesh/SC_Mesh_Deformer.cs
@@ -0,0 +1,190 @@
+﻿
+using System.Collections.Generic;
+using SDHK_Tool.Static;
+using UnityEngine;
+// using SDHK_Tool.Extension;
+
+/*
+ * 作者：闪电Y黑客
+ * 
+ * 日期： 2019.8.29
+ * 
+ * 2019.10.25 与绑定器功能合并
+ * 
+ * 功能：用于Mesh的扭曲器
+ */
+
+namespace SDHK_Tool.Component
+{
+    /// <summary>
+    /// Mesh扭曲器
+    /// </summary>
+    public class SC_Mesh_Deformer : MonoBehaviour
+    {
+
+        /// <summary>
+        /// 动态刷新激活
+        /// </summary>
+        [Tooltip("动态刷新激活")]
+        public bool Dynamic;
+
+        /// <summary>
+        /// 绑定画线
+        /// </summary>
+        [Tooltip("绑定画线")]
+        public bool Debug_Line = true;
+
+        /// <summary>
+        /// 模型绑定存档路径
+        /// </summary>
+        [Tooltip("模型绑定存档路径")]
+        public string FilePath = "Mesh_Save";
+
+        /// <summary>
+        /// 绑定骨骼
+        /// </summary>
+        [Tooltip("绑定骨骼")]
+        public SB_Mesh_Skeleton mesh_Skeleton;
+
+        private MeshBinder Mesh_Binder = new MeshBinder();
+        private Mesh mesh;
+        private List<Vector3> mesh_vertices;
+
+
+
+        private float ShortDistance = 0;//最短距离
+        private Vector3 OffsetSave;//偏移存档
+        private int index;//节点编号
+
+
+        // Use this for initialization
+
+        private void Awake()
+        {
+            RefreshDeformer();
+        }
+
+        // Update is called once per frame
+        void Update()
+        {
+            if (Dynamic) Deformer();
+        }
+
+        private void Initialize()
+        {
+            try { mesh = GetComponent<MeshFilter>().mesh; } catch { }
+            mesh_vertices = new List<Vector3>();
+            mesh_vertices.AddRange(mesh.vertices);
+        }
+
+        [ContextMenu("模型绑定到存档")]
+        void StartBind()
+        {
+            Initialize();
+            Bind();
+        }
+
+        [ContextMenu("模型扭曲刷新")]
+        private void RefreshDeformer()
+        {
+            Initialize();
+            if (FilePath != "") Mesh_Binder = SS_File.GetFile_ByteObject<MeshBinder>(Application.streamingAssetsPath + FilePath);
+            Deformer();
+        }
+
+        /// <summary>
+        /// 绑定方法
+        /// </summary>
+        private void Bind()
+        {
+            Mesh_Binder = new MeshBinder();
+
+            for (int i = 0; i < mesh.vertices.Length; i++)//遍历mesh全点
+            {
+                ShortDistance = Mathf.Infinity;
+
+                for (int i1 = 0; i1 < mesh_Skeleton.Pionts.Count; i1++)//遍历骨架线节点
+                {
+                    Vector3 Offset = (mesh_Skeleton.Pionts[i1].SE_World_To_local(transform.SE_Local_To_World(mesh.vertices[i])));
+
+                    if (Offset.magnitude < ShortDistance)//取最近骨架节点
+                    {
+                        ShortDistance = Offset.magnitude;
+                        OffsetSave = Offset;
+                        index = i1;
+                    }
+                }
+
+                if (Mesh_Binder.MeshBind.ContainsKey(index.ToString()))//骨架编号与mesh节点编号绑定
+                {
+                    Mesh_Binder.MeshBind[index.ToString()].Add(i.ToString(), OffsetSave);
+                }
+                else
+                {
+                    Mesh_Binder.MeshBind.Add(index.ToString(), new Dictionary<string, SF_Vector3>());
+                    Mesh_Binder.MeshBind[index.ToString()].Add(i.ToString(), OffsetSave);
+                }
+                index = 0;
+            }
+
+            string path = Application.streamingAssetsPath + FilePath;
+            SS_File.SetFile_byteObject(Mesh_Binder, path);//绑定过程太慢所以需要存档
+        }
+
+        /// <summary>
+        /// 扭曲变形
+        /// </summary>
+        private void Deformer()
+        {
+            for (int i = 0; i < mesh_Skeleton.Pionts.Count; i++)
+            {
+                if (Mesh_Binder.MeshBind.ContainsKey(i.ToString()))
+                {
+                    foreach (var Mesh_Ids in Mesh_Binder.MeshBind[i.ToString()])
+                    {
+                        mesh_vertices[int.Parse(Mesh_Ids.Key)] = transform.SE_World_To_local(mesh_Skeleton.Pionts[i].SE_Local_To_World(Mesh_Ids.Value));
+                    }
+                }
+            }
+            mesh.vertices = mesh_vertices.ToArray();
+            mesh.RecalculateNormals();//刷新法线
+        }
+
+
+
+
+
+#if UNITY_EDITOR
+        void OnDrawGizmos()
+        {
+            if (mesh_Skeleton != null && Debug_Line) DeBugDraw();
+        }
+#endif
+        private void DeBugDraw()
+        {
+            for (int i = 0; i < mesh_Skeleton.Pionts.Count; i++)
+            {
+                if (Mesh_Binder.MeshBind.ContainsKey(i.ToString()))
+                {
+                    foreach (var Mesh_Ids in Mesh_Binder.MeshBind[i.ToString()])
+                    {
+                        Debug.DrawLine(mesh_Skeleton.Pionts[i].position, mesh_Skeleton.Pionts[i].SE_Local_To_World(Mesh_Ids.Value), (i % 2 == 0) ? Color.yellow : Color.red);
+                    }
+                }
+            }
+
+        }
+
+    }
+
+
+
+    /// <summary>
+    /// 用于序列化存档的网格绑定类
+    /// </summary>
+    [System.Serializable]
+    class MeshBinder
+    {
+        public Dictionary<string, Dictionary<string, SF_Vector3>> MeshBind = new Dictionary<string, Dictionary<string, SF_Vector3>>();
+    }
+}
\ No newline at end of file
diff --git a/SDHK_Tool/Component/Mesh/SC_Mesh_Deformer.cs.meta b/SDHK_Tool/Component/Mesh/SC_Mesh_Deformer.cs.meta
new file mode 100644
index 0000000..b367b8c
--- /dev/null
+++ b/SDHK_Tool/Component/Mesh/SC_Mesh_Deformer.cs.meta
@@ -0,0 +1,13 @@
+fileFormatVersion: 2
+guid: b00540e590cb4c54a98d5a6d2cf9d6f3
+timeCreated: 1566977512
+licenseType: Pro
+MonoImporter:
+  externalObjects: {}
+  serializedVersion: 2
+  defaultReferences: []
+  executionOrder: 0
+  icon: {instanceID: 0}
+  userData: 
+  assetBundleName: 
+  assetBundleVariant: 
diff --git a/SDHK_Tool/Component/Mesh/SC_Mesh_SkeletonLine.cs b/SDHK_Tool/Component/Mesh/SC_Mesh_SkeletonLine.cs
new file mode 100644
index 0000000..f912214
--- /dev/null
+++ b/SDHK_Tool/Component/Mesh/SC_Mesh_SkeletonLine.cs
@@ -0,0 +1,148 @@
+﻿using UnityEngine;
+
+/*
+ * 作者：闪电Y黑客
+ * 
+ * 日期： 2019.8.29
+ *
+ * 2019.10.25 继承 SB_Mesh_Skeleton 抽象类的骨架脚本
+ * 
+ * 功能：用于Mesh的骨架线条
+ */
+
+namespace SDHK_Tool.Component
+{
+    /// <summary>
+    /// 用于Mesh的骨架线条
+    /// </summary>
+    public class SC_Mesh_SkeletonLine : SB_Mesh_Skeleton
+    {
+
+        /// <summary>
+        /// 动态刷新激活
+        /// </summary>
+        [Tooltip("动态刷新激活")]
+        public bool Dynamic = true;
+
+        /// <summary>
+        /// 调试画线
+        /// </summary>
+        [Tooltip("调试画线")]
+        public bool Debug_Line = true;
+
+        /// <summary>
+        /// 不计算根节点
+        /// </summary>
+        [Tooltip("不计算根节点")]
+        public bool Ignore_RootNode = false;
+
+        /// <summary>
+        /// 线条节点数量
+        /// </summary>
+        [Tooltip("线条节点数量")]
+        public int LineCount = 10;
+
+        /// <summary>
+        /// 每段长度
+        /// </summary>
+        [Tooltip("每段长度")]
+        public float LineDistance = 1;
+
+        /// <summary>
+        /// 弯曲角度：w为受影响段数
+        /// </summary>
+        [Tooltip("弯曲角度：w为受影响段数")]
+        public Vector4[] BendAngles = new Vector4[1];
+
+
+        private Vector3 Angle = Vector3.zero;
+
+        private int Bend_i = 0;
+
+        private int Bend_Count = 0;
+
+
+        private void Awake()
+        {
+
+        }
+
+
+        [ContextMenu("生成新的骨架线")]
+        private void Initialize()
+        {
+            if (Pionts.Count != 0)
+            {
+                foreach (var Line in Pionts)
+                {
+                    DestroyImmediate(Line.gameObject);
+                }
+                Pionts.Clear();
+            }
+
+            if (Pionts.Count == 0)
+            {
+                for (int i = 0; i < LineCount; i++)
+                {
+                    Pionts.Add(new GameObject().transform);
+                    Pionts[i].parent = transform;
+                }
+                Line_draw();
+            }
+        }
+
+        private void Line_draw()
+        {
+            Bend_i = 0;
+            Bend_Count = 0;
+
+            Angle = (Ignore_RootNode) ? Vector3.zero : (Vector3)BendAngles[Bend_i];
+
+            Pionts[0].transform.localPosition = Vector3.zero;
+            Pionts[0].transform.localEulerAngles = Angle;
+
+            for (int i = 1; i < LineCount; i++)
+            {
+
+                Bend_Count++;
+
+                if (BendAngles[Bend_i].w - 1 < Bend_Count && Bend_i < BendAngles.Length - 1)
+                {
+                    Bend_i++;
+                    Bend_Count = 0;
+                }
+
+                Pionts[i].transform.position = Pionts[i - 1].forward * LineDistance + Pionts[i - 1].position;
+
+                Angle += (Vector3)BendAngles[Bend_i];
+
+                Pionts[i].transform.localEulerAngles = Angle;
+
+            }
+        }
+
+#if UNITY_EDITOR
+        void OnDrawGizmos()
+        {
+            if (Pionts == null || Pionts.Count == 0) return;
+            if (Dynamic) Line_draw();
+            if (Debug_Line) DeBugDraw();
+        }
+#endif
+
+
+        private void DeBugDraw()
+        {
+            for (int i = 0; i < Pionts.Count - 1; i++)
+            {
+                Debug.DrawLine(Pionts[i].position, Pionts[i + 1].position, (i % 2 == 0) ? Color.yellow : Color.red);
+            }
+
+            foreach (var item in Pionts)
+            {
+                Debug.DrawLine(item.position, item.up + item.position, Color.green);
+            }
+        }
+
+    }
+}
\ No newline at end of file
diff --git a/SDHK_Tool/Component/Mesh/SC_Mesh_SkeletonLine.cs.meta b/SDHK_Tool/Component/Mesh/SC_Mesh_SkeletonLine.cs.meta
new file mode 100644
index 0000000..e1b8c51
--- /dev/null
+++ b/SDHK_Tool/Component/Mesh/SC_Mesh_SkeletonLine.cs.meta
@@ -0,0 +1,13 @@
+fileFormatVersion: 2
+guid: 8ac1edfda7c82d14ea9e81c20812f841
+timeCreated: 1566976093
+licenseType: Pro
+MonoImporter:
+  externalObjects: {}
+  serializedVersion: 2
+  defaultReferences: []
+  executionOrder: 0
+  icon: {instanceID: 0}
+  userData: 
+  assetBundleName: 
+  assetBundleVariant: 
diff --git a/SDHK_Tool/Component/Motor.meta b/SDHK_Tool/Component/Motor.meta
new file mode 100644
index 0000000..8b5a268
--- /dev/null
+++ b/SDHK_Tool/Component/Motor.meta
@@ -0,0 +1,10 @@
+fileFormatVersion: 2
+guid: 9b197f7d2b43131409df74e6d29e0e92
+folderAsset: yes
+timeCreated: 1585187510
+licenseType: Free
+DefaultImporter:
+  externalObjects: {}
+  userData: 
+  assetBundleName: 
+  assetBundleVariant: 
diff --git a/SDHK_Tool/Component/Physics/SC_Overlap_Box.cs b/SDHK_Tool/Component/Physics/SC_Overlap_Box.cs
new file mode 100644
index 0000000..13d0014
--- /dev/null
+++ b/SDHK_Tool/Component/Physics/SC_Overlap_Box.cs
@@ -0,0 +1,162 @@
+﻿using System;
+using System.Collections.Generic;
+using UnityEngine;
+using SDHK_Tool.Static;
+using System.Linq;
+
+/*
+ * 作者：闪电Y黑客
+ * 
+ * 日期：2019.10.22
+ * 
+ * 功能：用于游戏物体碰撞箱的检测判断
+ */
+
+namespace SDHK_Tool.Component
+{
+    /// <summary>
+    /// 碰撞箱检测器：箱形
+    /// </summary>
+    public class SC_Overlap_Box : MonoBehaviour
+    {
+        /// <summary>
+        /// 是否应触发触发器
+        /// </summary>
+        [Tooltip("是否应触发触发器")]
+        public QueryTriggerInteraction TriggerInteraction;
+
+        [Space()]
+
+        /// <summary>
+        /// 忽略层
+        /// </summary>
+        [Tooltip("忽略层")]
+        public string[] IgnoreLayer;
+
+        [Space()]
+        [Space()]
+
+        /// <summary>
+        /// 中心偏移
+        /// </summary>
+        [Tooltip("中心点偏移")]
+        public Vector3 Center = Vector3.zero;
+
+        [Space()]
+
+        /// <summary>
+        /// 尺寸大小
+        /// </summary>
+        [Tooltip("尺寸大小")]
+        public Vector3 Size = Vector3.one;
+
+        [Space()]
+        [Space()]
+
+        /// <summary>
+        /// 调试画线
+        /// </summary>
+        [Tooltip("调试画线")]
+        public bool DebugLine = true;
+
+        [Space()]
+
+        /// <summary>
+        /// 线条颜色
+        /// </summary>
+        [Tooltip("线条颜色")]
+        public Color color = Color.green;
+
+
+        /// <summary>
+        /// 触发事件：进入
+        /// </summary>
+        public Action<List<Collider>> OnOverlapEnter;
+
+        /// <summary>
+        /// 触发事件：离开
+        /// </summary>
+        public Action<List<Collider>> OnOverlapExit;
+
+        /// <summary>
+        /// 触发事件：停留
+        /// </summary>
+        public Action<List<Collider>> OnOverlapStay;
+
+
+        private List<Collider> EnterColliders;
+        private List<Collider> ExitColliders;
+        private List<Collider> StayColliders;
+
+        private Func<Collider, Collider, bool> IF_Func = (Collider a, Collider b) => { return object.ReferenceEquals(a.gameObject, b.gameObject); };
+
+        private List<Collider> LastColliders = new List<Collider>();
+        private Vector3 OverlapCenter;
+        private Vector3 OverlapSize;
+
+        private bool isCheckBox = false;
+        private bool isLastCheckBox = false;
+
+
+        // Use this for initialization
+        void Start()
+        {
+            // OnOverlapEnter = (a) => Debug.Log("Enter");
+            // OnOverlapExit = (a) => Debug.Log("Exit");
+            // OnOverlapStay = (a) => Debug.Log("Stay");
+        }
+
+        // Update is called once per frame
+        void Update()
+        {
+            OverlapCenter = transform.TransformPoint(Center);
+
+            OverlapSize = new Vector3(
+                transform.lossyScale.x * Size.x,
+                 transform.lossyScale.y * Size.y,
+                  transform.lossyScale.z * Size.z
+            ) * 0.5f;
+
+            isCheckBox = Physics.CheckBox(OverlapCenter, OverlapSize, transform.rotation, ~LayerMask.GetMask(IgnoreLayer));
+
+            if (isCheckBox || isCheckBox != isLastCheckBox)
+            {
+                List<Collider> NowColliders = Physics.OverlapBox(OverlapCenter, OverlapSize, transform.rotation, ~LayerMask.GetMask(IgnoreLayer), TriggerInteraction).ToList();
+
+                LastColliders.RemoveAll(v => v == null);//去除可能出现的空物体
+
+                EnterColliders = SS_GameObject.List_Except(NowColliders, LastColliders, IF_Func);
+                ExitColliders = SS_GameObject.List_Except(LastColliders, NowColliders, IF_Func);
+                StayColliders = SS_GameObject.List_Intersect(NowColliders, LastColliders, IF_Func);
+
+                if (OnOverlapEnter != null && EnterColliders.Count > 0) { OnOverlapEnter(EnterColliders); }
+                if (OnOverlapExit != null && ExitColliders.Count > 0) { OnOverlapExit(ExitColliders); }
+                if (OnOverlapStay != null && StayColliders.Count > 0) { OnOverlapStay(StayColliders); }
+
+                LastColliders = NowColliders;
+            }
+            isLastCheckBox = isCheckBox;
+
+        }
+
+
+
+
+#if UNITY_EDITOR
+
+        void OnDrawGizmos()
+        {
+            if (DebugLine)
+            {
+                Gizmos.matrix = transform.localToWorldMatrix;
+                Gizmos.color = color;
+                Gizmos.DrawWireCube(Center, Size);
+            }
+        }
+
+#endif
+
+    }
+
+
+}
\ No newline at end of file
diff --git a/SDHK_Tool/Component/Physics/SC_Overlap_Box.cs.meta b/SDHK_Tool/Component/Physics/SC_Overlap_Box.cs.meta
new file mode 100644
index 0000000..86c5a72
--- /dev/null
+++ b/SDHK_Tool/Component/Physics/SC_Overlap_Box.cs.meta
@@ -0,0 +1,13 @@
+fileFormatVersion: 2
+guid: 410a13cdba7309c4ca3c73feafc36e5c
+timeCreated: 1571635869
+licenseType: Pro
+MonoImporter:
+  externalObjects: {}
+  serializedVersion: 2
+  defaultReferences: []
+  executionOrder: 0
+  icon: {instanceID: 0}
+  userData: 
+  assetBundleName: 
+  assetBundleVariant: 
diff --git a/SDHK_Tool/Component/Physics/SC_Overlap_Sphere.cs b/SDHK_Tool/Component/Physics/SC_Overlap_Sphere.cs
new file mode 100644
index 0000000..fd930d3
--- /dev/null
+++ b/SDHK_Tool/Component/Physics/SC_Overlap_Sphere.cs
@@ -0,0 +1,154 @@
+﻿using System;
+using System.Collections.Generic;
+using System.Linq;
+using SDHK_Tool.Static;
+using UnityEngine;
+
+/*
+ * 作者：闪电Y黑客
+ * 
+ * 日期：2019.10.22
+ * 
+ * 功能：用于游戏物体碰撞箱的检测判断
+ */
+
+namespace SDHK_Tool.Component
+{
+    /// <summary>
+    /// 碰撞箱检测器：球形
+    /// </summary>
+    public class SC_Overlap_Sphere : MonoBehaviour
+    {
+        /// <summary>
+        /// 是否应触发触发器
+        /// </summary>
+        [Tooltip("是否应触发触发器")]
+        public QueryTriggerInteraction TriggerInteraction;
+
+        [Space()]
+
+        /// <summary>
+        /// 忽略层
+        /// </summary>
+        [Tooltip("忽略层")]
+        public string[] IgnoreLayer;
+
+        [Space()]
+        [Space()]
+
+        /// <summary>
+        /// 中心偏移
+        /// </summary>
+        [Tooltip("中心点偏移")]
+        public Vector3 Center = Vector3.zero;
+
+        [Space()]
+
+        /// <summary>
+        /// 半径大小
+        /// </summary>
+        [Tooltip("半径大小")]
+        public float Radius = 0.5f;
+
+        [Space()]
+        [Space()]
+
+        /// <summary>
+        /// 调试画线
+        /// </summary>
+        [Tooltip("调试画线")]
+        public bool DebugLine = true;
+
+        [Space()]
+
+        /// <summary>
+        /// 线条颜色
+        /// </summary>
+        [Tooltip("线条颜色")]
+        public Color color = Color.green;
+
+
+        /// <summary>
+        /// 触发事件：进入
+        /// </summary>
+        public Action<List<Collider>> OnOverlapEnter;
+
+        /// <summary>
+        /// 触发事件：离开
+        /// </summary>
+        public Action<List<Collider>> OnOverlapExit;
+
+        /// <summary>
+        /// 触发事件：停留
+        /// </summary>
+        public Action<List<Collider>> OnOverlapStay;
+
+
+        private List<Collider> EnterColliders;
+        private List<Collider> ExitColliders;
+        private List<Collider> StayColliders;
+
+        private Func<Collider, Collider, bool> IF_Func = (Collider a, Collider b) => { return object.ReferenceEquals(a.gameObject, b.gameObject); };
+
+        private List<Collider> LastColliders = new List<Collider>();
+        private Vector3 OverlapCenter;
+        private Vector3 OverlapSize;
+
+
+        private bool isCheckSphere = false;
+        private bool isLastCheckSphere = false;
+
+        // Use this for initialization
+        void Start()
+        {
+            // OnOverlapEnter = (a) => Debug.Log("Enter");
+            // OnOverlapExit = (a) => Debug.Log("Exit");
+            // OnOverlapStay = (a) => Debug.Log("Stay");
+        }
+
+        // Update is called once per frame
+        void Update()
+        {
+            OverlapCenter = transform.TransformPoint(Center);
+
+            isCheckSphere = Physics.CheckSphere(OverlapCenter, Radius, ~LayerMask.GetMask(IgnoreLayer), TriggerInteraction);
+
+            if (isCheckSphere || isCheckSphere != isLastCheckSphere)
+            {
+                List<Collider> NowColliders = Physics.OverlapSphere(OverlapCenter, Radius, ~LayerMask.GetMask(IgnoreLayer), TriggerInteraction).ToList();
+
+                LastColliders.RemoveAll(v => v == null);//去除可能出现的空物体
+
+                EnterColliders = SS_GameObject.List_Except(NowColliders, LastColliders, IF_Func);
+                ExitColliders = SS_GameObject.List_Except(LastColliders, NowColliders, IF_Func);
+                StayColliders = SS_GameObject.List_Intersect(NowColliders, LastColliders, IF_Func);
+
+                if (OnOverlapEnter != null && EnterColliders.Count > 0) { OnOverlapEnter(EnterColliders); }
+                if (OnOverlapExit != null && ExitColliders.Count > 0) { OnOverlapExit(ExitColliders); }
+                if (OnOverlapStay != null && StayColliders.Count > 0) { OnOverlapStay(StayColliders); }
+
+                LastColliders = NowColliders;
+            }
+            isLastCheckSphere = isCheckSphere;
+
+        }
+
+#if UNITY_EDITOR
+        void OnDrawGizmos()
+        {
+
+            if (DebugLine)
+            {
+                Gizmos.matrix = transform.localToWorldMatrix;
+
+                Gizmos.color = color;
+                Gizmos.DrawWireSphere(Center, Radius);
+
+                Gizmos.color = new Color(color.r, color.g, color.b, color.a * 0.3f);
+                Gizmos.DrawSphere(Center, Radius);
+            }
+
+        }
+#endif
+    }
+}
\ No newline at end of file
diff --git a/SDHK_Tool/Component/Physics/SC_Overlap_Sphere.cs.meta b/SDHK_Tool/Component/Physics/SC_Overlap_Sphere.cs.meta
new file mode 100644
index 0000000..cf31ae0
--- /dev/null
+++ b/SDHK_Tool/Component/Physics/SC_Overlap_Sphere.cs.meta
@@ -0,0 +1,13 @@
+fileFormatVersion: 2
+guid: 4261c4910a8dcc940be945275c9e371a
+timeCreated: 1571725551
+licenseType: Pro
+MonoImporter:
+  externalObjects: {}
+  serializedVersion: 2
+  defaultReferences: []
+  executionOrder: 0
+  icon: {instanceID: 0}
+  userData: 
+  assetBundleName: 
+  assetBundleVariant: 
diff --git a/SDHK_Tool/Component/Physics/SC_RayCast.cs b/SDHK_Tool/Component/Physics/SC_RayCast.cs
new file mode 100644
index 0000000..9d8e233
--- /dev/null
+++ b/SDHK_Tool/Component/Physics/SC_RayCast.cs
@@ -0,0 +1,162 @@
+﻿using System;
+using System.Collections;
+using System.Collections.Generic;
+using System.Linq;
+using SDHK_Tool.Static;
+using UnityEngine;
+// using SDHK_Tool.Extension;
+
+
+/*
+ * 作者：闪电Y黑客
+ * 
+ * 日期：2019.12.05
+ * 
+ * 功能：用于游戏物体碰撞箱的射线检测判断
+ */
+
+namespace SDHK_Tool.Component
+{
+
+    /// <summary>
+    /// 碰撞箱检测器：射线
+    /// </summary>
+    public class SC_RayCast : MonoBehaviour
+    {
+        /// <summary>
+        /// 坐标系
+        /// </summary>
+		[Tooltip("坐标系")]
+        public Transform Origin;
+
+        [Space()]
+
+        /// <summary>
+        /// 是否应触发触发器
+        /// </summary>
+        [Tooltip("是否应触发触发器")]
+        public QueryTriggerInteraction TriggerInteraction;
+
+        [Space()]
+
+        /// <summary>
+        /// 忽略层
+        /// </summary>
+        [Tooltip("忽略层")]
+        public string[] IgnoreLayer;
+
+        [Space()]
+        [Space()]
+
+        /// <summary>
+        /// 射线节点
+        /// </summary>
+		[Tooltip("射线节点")]
+        public List<Vector3> LinePoints = new List<Vector3>() { Vector3.zero, new Vector3(0, 0, 5) };
+
+        [Space()]
+        [Space()]
+
+        /// <summary>
+        /// 调试画线
+        /// </summary>
+        [Tooltip("调试画线")]
+        public bool DebugLine = true;
+
+        /// <summary>
+        /// 线条颜色
+        /// </summary>
+        [Tooltip("线条颜色")]
+        public Color color = Color.green;
+
+
+        /// <summary>
+        /// 触发事件：进入
+        /// </summary>
+        public Action<List<RaycastHit>> OnRayCastEnter;
+
+        /// <summary>
+        /// 触发事件：离开
+        /// </summary>
+        public Action<List<RaycastHit>> OnRayCastExit;
+
+        /// <summary>
+        /// 触发事件：停留
+        /// </summary>
+        public Action<List<RaycastHit>> OnRayCastStay;
+
+
+        private List<RaycastHit> EnterColliders = new List<RaycastHit>();
+        private List<RaycastHit> ExitColliders = new List<RaycastHit>();
+        private List<RaycastHit> StayColliders = new List<RaycastHit>();
+
+        private List<Vector3> points = new List<Vector3>() { Vector3.zero, new Vector3(0, 0, 5) };
+        private Func<RaycastHit, RaycastHit, bool> IF_Func = (RaycastHit a, RaycastHit b) => { return object.ReferenceEquals(a.collider.gameObject, b.collider.gameObject); };
+        private List<RaycastHit> LastColliders = new List<RaycastHit>();
+
+        private Vector3 point1_To_point2 = Vector3.zero;
+
+        private bool isCheckBox = false;
+
+        // Use this for initialization
+        void Start()
+        {
+            // OnRayCastEnter = (a) => Debug.Log("Enter");
+            // OnRayCastExit = (a) => Debug.Log("Exit");
+            // OnRayCastStay = (a) => Debug.Log("Stay");
+        }
+
+        // Update is called once per frame
+        void Update()//Fixed
+        {
+            if (points.Count < 2) return;
+
+            List<RaycastHit> NowColliders = new List<RaycastHit>();
+
+            points = (Origin != null) ? LinePoints.ConvertAll<Vector3>(a => Origin.SE_Local_To_World(a)) : LinePoints;
+
+            for (int i = 1; i < points.Count; i++)
+            {
+                point1_To_point2 = points[i] - points[i - 1];
+                isCheckBox = Physics.Raycast(points[i - 1], point1_To_point2, point1_To_point2.magnitude, ~LayerMask.GetMask(IgnoreLayer), TriggerInteraction);
+
+                if (isCheckBox)
+                {
+                    NowColliders = NowColliders.Union(Physics.RaycastAll(points[i - 1], point1_To_point2, point1_To_point2.magnitude, ~LayerMask.GetMask(IgnoreLayer), TriggerInteraction).ToList()).ToList();
+                }
+            }
+
+            if (NowColliders.Count > 0 || LastColliders.Count > 0)
+            {
+                LastColliders.RemoveAll(v => v.collider == null);//去除可能出现的空物体
+
+                EnterColliders = SS_GameObject.List_Except(NowColliders, LastColliders, IF_Func);
+                ExitColliders = SS_GameObject.List_Except(LastColliders, NowColliders, IF_Func);
+                StayColliders = SS_GameObject.List_Intersect(NowColliders, LastColliders, IF_Func);
+
+
+
+                if (OnRayCastEnter != null && EnterColliders.Count > 0) { OnRayCastEnter(EnterColliders); }
+                if (OnRayCastExit != null && ExitColliders.Count > 0) { OnRayCastExit(ExitColliders); }
+                if (OnRayCastStay != null && StayColliders.Count > 0) { OnRayCastStay(StayColliders); }
+            }
+
+            LastColliders = NowColliders;
+        }
+
+#if UNITY_EDITOR
+        void OnDrawGizmos()
+        {
+            if (DebugLine)
+            {
+                // Gizmos.matrix
+                Gizmos.color = color;
+                for (int i = 1; i < points.Count; i++) Gizmos.DrawLine(points[i - 1], points[i]);
+            }
+        }
+#endif
+
+
+    }
+
+}
\ No newline at end of file
diff --git a/SDHK_Tool/Component/Physics/SC_RayCast.cs.meta b/SDHK_Tool/Component/Physics/SC_RayCast.cs.meta
new file mode 100644
index 0000000..f7a4fe3
--- /dev/null
+++ b/SDHK_Tool/Component/Physics/SC_RayCast.cs.meta
@@ -0,0 +1,13 @@
+fileFormatVersion: 2
+guid: 3f96b29d1e1022d40875460903a64aab
+timeCreated: 1575523644
+licenseType: Pro
+MonoImporter:
+  externalObjects: {}
+  serializedVersion: 2
+  defaultReferences: []
+  executionOrder: 0
+  icon: {instanceID: 0}
+  userData: 
+  assetBundleName: 
+  assetBundleVariant: 
diff --git a/SDHK_Tool/Component/Socket.meta b/SDHK_Tool/Component/Socket.meta
new file mode 100644
index 0000000..3148b4f
--- /dev/null
+++ b/SDHK_Tool/Component/Socket.meta
@@ -0,0 +1,10 @@
+fileFormatVersion: 2
+guid: ef422267c87e9c94689f382455001dda
+folderAsset: yes
+timeCreated: 1585187510
+licenseType: Free
+DefaultImporter:
+  externalObjects: {}
+  userData: 
+  assetBundleName: 
+  assetBundleVariant: 
diff --git a/SDHK_Tool/Component/TUIO/SC_TUIO_Listener.cs b/SDHK_Tool/Component/TUIO/SC_TUIO_Listener.cs
new file mode 100644
index 0000000..f76e397
--- /dev/null
+++ b/SDHK_Tool/Component/TUIO/SC_TUIO_Listener.cs
@@ -0,0 +1,168 @@
+﻿using System.Collections.Generic;
+using TUIOsharp;
+using TUIOsharp.DataProcessors;
+using UnityEngine;
+using System;
+
+
+/*
+ * 作者：闪电Y黑客
+ * 
+ * 日期： 2019.12.16
+ *
+ * 功能：TUIO事件监听器
+ *
+ */
+
+namespace SDHK_Tool.Component
+{
+
+    /// <summary>
+    /// TUIO事件监听器
+    /// </summary>
+    public class SC_TUIO_Listener : MonoBehaviour
+    {
+        /// <summary>
+        /// 监听端口[默认3333]
+        /// </summary>
+		[Tooltip("监听端口[默认3333]")]
+        public int TuioPort = 3333;
+
+        [Space()]
+
+        /// <summary>
+        /// Tuio点Id顺序链表[顺序列表]，通过列表id顺序去字典提取Tuio触摸点
+        /// </summary>
+        [Tooltip("Tuio点Id顺序表")]
+        public List<int> TuioCursorIds = new List<int>();
+
+        /// <summary>
+        /// Tuio字典[无序]
+        /// </summary>
+        public Dictionary<int, TuioCursorEventArgs> Tuio_CursorPool = new Dictionary<int, TuioCursorEventArgs>();
+
+        /// <summary>
+        /// Tuio点坐标字典[无序]
+        /// </summary>
+        public Dictionary<int, Vector2> Tuio_PointPool = new Dictionary<int, Vector2>();
+
+
+        /// <summary>
+        /// 触发事件：进入
+        /// </summary>
+        public Action<List<int>> TuioEnter;
+
+        /// <summary>
+        /// 触发事件：离开
+        /// </summary>
+        public Action<List<int>> TuioExit;
+
+        /// <summary>
+        /// 触发事件：停留刷新
+        /// </summary>
+        public Action<List<int>> TuioStay;
+
+        private List<int> TuioEnterId = new List<int>();//进入事件Id池
+        private List<int> TuioStayId = new List<int>();//更新事件Id池
+        private List<int> TuioExitId = new List<int>();//退出事件Id池
+
+        private TuioServer server;//TUIO服务
+        private CursorProcessor cursorProcessor;//处理器
+
+        // private ObjectProcessor objectProcessor;
+        // private BlobProcessor blobProcessor;
+
+        private Vector2 screen;//屏幕长宽值
+
+        private void OnEnable()//启动
+        {
+            screen.x = Screen.width;
+            screen.y = Screen.height;
+
+            cursorProcessor = new CursorProcessor();//委托挂载到线程里
+            cursorProcessor.CursorAdded += OnCursorAdded;
+            cursorProcessor.CursorUpdated += OnCursorUpdated;
+            cursorProcessor.CursorRemoved += OnCursorRemoved;
+
+            server = new TuioServer(TuioPort);//启动服务
+            server.Connect();//连接
+
+            server.AddDataProcessor(cursorProcessor);//处理器添加
+        }
+
+        private void OnDisable()//关闭
+        {
+            if (server != null)
+            {
+                server.RemoveDataProcessor(cursorProcessor);
+                server.RemoveAllDataProcessors();
+                server.Disconnect();
+                server = null;
+            }
+        }
+
+        private void OnCursorAdded(object sender, TuioCursorEventArgs e)//tuio点添加（线程）
+        {
+            // var entity = e.Cursor;
+            lock (this)
+            {
+                if (!Tuio_CursorPool.ContainsKey(e.Cursor.Id))
+                {
+                    TuioCursorIds.Add(e.Cursor.Id);
+                    Tuio_CursorPool.Add(e.Cursor.Id, e);
+                    Tuio_PointPool.Add(e.Cursor.Id, new Vector2(e.Cursor.X * screen.x, (1 - e.Cursor.Y) * screen.y));//坐标换算
+
+                    TuioEnterId.Add(e.Cursor.Id);//添加进入事件Id池
+                }
+            }
+        }
+
+        private void OnCursorUpdated(object sender, TuioCursorEventArgs e)//tuio点刷新（线程）
+        {
+            // var entity = e.Cursor;
+            lock (this)
+            {
+                if (Tuio_CursorPool.ContainsKey(e.Cursor.Id))
+                {
+                    Tuio_PointPool[e.Cursor.Id] = new Vector2(e.Cursor.X * screen.x, (1 - e.Cursor.Y) * screen.y);//坐标换算
+
+                    TuioStayId.Add(e.Cursor.Id);//添加更新事件Id池
+                }
+            }
+        }
+
+        private void OnCursorRemoved(object sender, TuioCursorEventArgs e)//tuio点移除（线程）
+        {
+            // var entity = e.Cursor;
+            lock (this)
+            {
+                if (Tuio_CursorPool.ContainsKey(e.Cursor.Id))
+                {
+                    Tuio_PointPool[e.Cursor.Id] = new Vector2(e.Cursor.X * screen.x, (1 - e.Cursor.Y) * screen.y);//坐标换算
+
+                    TuioExitId.Add(e.Cursor.Id);//添加退出事件Id池
+
+                    Tuio_CursorPool.Remove(e.Cursor.Id);//Tuio点池去除id
+                    TuioCursorIds.Remove(e.Cursor.Id);//TuioId池去除Id
+                }
+            }
+        }
+
+        // Update is called once per frame
+        void Update()
+        {
+
+            if (TuioEnter != null && TuioEnterId.Count > 0) { TuioEnter(new List<int>(TuioEnterId)); }  //委托事件：进入
+
+            if (TuioStay != null && TuioStayId.Count > 0) { TuioStay(new List<int>(TuioStayId)); }      //委托事件：刷新
+
+            if (TuioExit != null && TuioExitId.Count > 0) { TuioExit(new List<int>(TuioExitId)); }      //委托事件：退出
+
+            foreach (var Id in TuioExitId) Tuio_PointPool.Remove(Id);//Tuio点坐标池去除id
+            TuioEnterId.Clear();   //进入事件Id池清空
+            TuioStayId.Clear();   //更新事件Id池清空
+            TuioExitId.Clear();     //退出事件Id池清空
+        }
+
+    }
+}
\ No newline at end of file
diff --git a/SDHK_Tool/Component/TUIO/SC_TUIO_Listener.cs.meta b/SDHK_Tool/Component/TUIO/SC_TUIO_Listener.cs.meta
new file mode 100644
index 0000000..1a33afd
--- /dev/null
+++ b/SDHK_Tool/Component/TUIO/SC_TUIO_Listener.cs.meta
@@ -0,0 +1,13 @@
+fileFormatVersion: 2
+guid: 5ec084223b661b84d9f94f97ff8798c8
+timeCreated: 1576481014
+licenseType: Pro
+MonoImporter:
+  externalObjects: {}
+  serializedVersion: 2
+  defaultReferences: []
+  executionOrder: 0
+  icon: {instanceID: 0}
+  userData: 
+  assetBundleName: 
+  assetBundleVariant: 
diff --git a/SDHK_Tool/Component/TUIO/SC_TUIO_Touch.cs b/SDHK_Tool/Component/TUIO/SC_TUIO_Touch.cs
new file mode 100644
index 0000000..a8ccca1
--- /dev/null
+++ b/SDHK_Tool/Component/TUIO/SC_TUIO_Touch.cs
@@ -0,0 +1,103 @@
+﻿using System.Collections.Generic;
+using UnityEngine;
+using SDHK_Tool.Static;
+using UnityEngine.EventSystems;
+
+
+/*
+ * 作者：闪电Y黑客
+ * 
+ * 日期： 2019.12.20
+ *
+ * 功能：TUIO触摸联动器
+ *
+ */
+
+namespace SDHK_Tool.Component
+{
+
+    /// <summary>
+    /// TUIO触摸联动器
+    /// </summary>
+    public class SC_TUIO_Touch : MonoBehaviour
+    {
+
+        /// <summary>
+        /// TUIO事件监听器
+        /// </summary>
+        [Tooltip("TUIO事件监听器")]
+        public SC_TUIO_Listener tuio_Listener;
+
+        [Space()]
+
+        /// <summary>
+        /// 触摸穿透器
+        /// </summary>
+        [Tooltip("触摸穿透器：挂上则可触发触摸事件")]
+        public SC_TouchEvent_RayCast TouchRayCast;
+
+        /// <summary>
+        /// 触摸字典[无序]
+        /// </summary>
+        public Dictionary<int, PointerEventData> TouchPool = new Dictionary<int, PointerEventData>();
+
+        // Use this for initialization
+        void Start()
+        {
+            if (tuio_Listener != null && TouchRayCast != null)
+            {
+                tuio_Listener.TuioEnter = TouchEnter;
+                tuio_Listener.TuioExit = TouchExit;
+                tuio_Listener.TuioStay = TouchStay;
+            }
+        }
+
+        public void TouchEnter(List<int> Ids)
+        {
+            foreach (var Id in Ids)
+            {
+                if (!TouchPool.ContainsKey(Id))
+                {
+                    PointerEventData pointerEventData = new PointerEventData(EventSystem.current);
+                    pointerEventData.pointerId = Id;
+                    pointerEventData.position = tuio_Listener.Tuio_PointPool[Id];
+
+                    TouchPool.Add(Id, pointerEventData);
+
+                    SS_Touch.OnEnter(TouchRayCast.gameObject, pointerEventData);
+                    SS_Touch.OnDown(TouchRayCast.gameObject, pointerEventData);
+                    SS_Touch.OnBeginDrag(TouchRayCast.gameObject, pointerEventData);
+                }
+            }
+        }
+
+        public void TouchStay(List<int> Ids)
+        {
+            foreach (var Id in Ids)
+            {
+                if (TouchPool.ContainsKey(Id))
+                {
+                    TouchPool[Id].position = tuio_Listener.Tuio_PointPool[Id];
+                    SS_Touch.OnDrag(TouchRayCast.gameObject, TouchPool[Id]);
+                }
+            }
+        }
+
+        public void TouchExit(List<int> Ids)
+        {
+            foreach (var Id in Ids)
+            {
+                if (TouchPool.ContainsKey(Id))
+                {
+                    TouchPool[Id].position = tuio_Listener.Tuio_PointPool[Id];
+
+                    SS_Touch.OnUp(TouchRayCast.gameObject, TouchPool[Id]);
+                    SS_Touch.OnExit(TouchRayCast.gameObject, TouchPool[Id]);
+                    SS_Touch.OnEndDrag(TouchRayCast.gameObject, TouchPool[Id]);
+
+                    TouchPool.Remove(Id);
+                }
+            }
+        }
+    }
+}
\ No newline at end of file
diff --git a/SDHK_Tool/Component/TUIO/SC_TUIO_Touch.cs.meta b/SDHK_Tool/Component/TUIO/SC_TUIO_Touch.cs.meta
new file mode 100644
index 0000000..a1426da
--- /dev/null
+++ b/SDHK_Tool/Component/TUIO/SC_TUIO_Touch.cs.meta
@@ -0,0 +1,13 @@
+fileFormatVersion: 2
+guid: aa51060251908f04c9fe1dcae96f21d6
+timeCreated: 1576827324
+licenseType: Pro
+MonoImporter:
+  externalObjects: {}
+  serializedVersion: 2
+  defaultReferences: []
+  executionOrder: 0
+  icon: {instanceID: 0}
+  userData: 
+  assetBundleName: 
+  assetBundleVariant: 
diff --git a/SDHK_Tool/Component/Touch.meta b/SDHK_Tool/Component/Touch.meta
new file mode 100644
index 0000000..8cebd4d
--- /dev/null
+++ b/SDHK_Tool/Component/Touch.meta
@@ -0,0 +1,10 @@
+fileFormatVersion: 2
+guid: 1445612c9e4dd9d40bc39ac0735975ca
+folderAsset: yes
+timeCreated: 1585187510
+licenseType: Free
+DefaultImporter:
+  externalObjects: {}
+  userData: 
+  assetBundleName: 
+  assetBundleVariant: 
diff --git a/SDHK_Tool/Component/Touch/Base/SB_Touch.cs b/SDHK_Tool/Component/Touch/Base/SB_Touch.cs
new file mode 100644
index 0000000..84ee1a1
--- /dev/null
+++ b/SDHK_Tool/Component/Touch/Base/SB_Touch.cs
@@ -0,0 +1,25 @@
+﻿using System.Collections;
+using System.Collections.Generic;
+using UnityEngine;
+
+/*
+ * 作者：闪电Y黑客
+ * 
+ * 日期： 2019.10.17
+ * 
+ * 功能：触摸抽象基类：共同属性：忽略鼠标事件
+ *
+ */
+
+/// <summary>
+/// 触摸抽象基类：共同属性：忽略鼠标事件
+/// </summary>
+public abstract class SB_Touch : MonoBehaviour
+{
+ 
+    /// <summary>
+    /// 触摸忽略鼠标事件
+    /// </summary>
+    [Tooltip("忽略鼠标")]
+    public bool IgnoreMouse = false;
+}
diff --git a/SDHK_Tool/Component/Touch/Base/SB_Touch.cs.meta b/SDHK_Tool/Component/Touch/Base/SB_Touch.cs.meta
new file mode 100644
index 0000000..7f65189
--- /dev/null
+++ b/SDHK_Tool/Component/Touch/Base/SB_Touch.cs.meta
@@ -0,0 +1,13 @@
+fileFormatVersion: 2
+guid: 20536f8389cf4554a8296307c426619f
+timeCreated: 1571913100
+licenseType: Pro
+MonoImporter:
+  externalObjects: {}
+  serializedVersion: 2
+  defaultReferences: []
+  executionOrder: 0
+  icon: {instanceID: 0}
+  userData: 
+  assetBundleName: 
+  assetBundleVariant: 
diff --git a/SDHK_Tool/Component/Touch/Base/SB_TouchEvent.cs b/SDHK_Tool/Component/Touch/Base/SB_TouchEvent.cs
new file mode 100644
index 0000000..ad5b178
--- /dev/null
+++ b/SDHK_Tool/Component/Touch/Base/SB_TouchEvent.cs
@@ -0,0 +1,31 @@
+﻿using System.Collections;
+using System.Collections.Generic;
+using UnityEngine;
+using UnityEngine.EventSystems;
+
+
+/*
+ * 作者：闪电Y黑客
+ * 
+ * 日期： 2019.10.17
+ * 
+ * 功能：触摸事件抽象基类：共同属性：触摸池
+ *
+ */
+
+/// <summary>
+/// 触摸事件抽象基类：共同属性：触摸池
+/// </summary>
+public abstract class SB_TouchEvent : SB_Touch
+{
+    /// <summary>
+    /// 触摸id顺序链表[顺序列表]，通过列表id顺序去字典提取触摸
+    /// </summary>
+    [Tooltip("触摸点Id顺序表")]
+    public List<int> TouchIds = new List<int>();
+
+    /// <summary>
+    /// 触摸字典[无序]
+    /// </summary>
+    public Dictionary<int, PointerEventData> TouchPool = new Dictionary<int, PointerEventData>();
+}
diff --git a/SDHK_Tool/Component/Touch/Base/SB_TouchEvent.cs.meta b/SDHK_Tool/Component/Touch/Base/SB_TouchEvent.cs.meta
new file mode 100644
index 0000000..779f57b
--- /dev/null
+++ b/SDHK_Tool/Component/Touch/Base/SB_TouchEvent.cs.meta
@@ -0,0 +1,13 @@
+fileFormatVersion: 2
+guid: 355a7d5953bddfe45a4cd6ec2b053264
+timeCreated: 1571913123
+licenseType: Pro
+MonoImporter:
+  externalObjects: {}
+  serializedVersion: 2
+  defaultReferences: []
+  executionOrder: 0
+  icon: {instanceID: 0}
+  userData: 
+  assetBundleName: 
+  assetBundleVariant: 
diff --git a/SDHK_Tool/Component/Touch/Base/SB_TouchMotor.cs b/SDHK_Tool/Component/Touch/Base/SB_TouchMotor.cs
new file mode 100644
index 0000000..4c9586a
--- /dev/null
+++ b/SDHK_Tool/Component/Touch/Base/SB_TouchMotor.cs
@@ -0,0 +1,71 @@
+﻿using System.Collections;
+using System.Collections.Generic;
+using UnityEngine;
+
+/*
+ * 作者：闪电Y黑客
+ * 
+ * 日期： 2019.10.17
+ * 
+ * 功能：触摸电机抽象基类：共同功能
+ *
+ */
+
+/// <summary>
+/// 功能：触摸电机抽象基类：共同功能
+/// </summary>
+public abstract class SB_TouchMotor : MonoBehaviour
+{
+
+    /// <summary>
+    /// 初始化电机
+    /// </summary>
+    public abstract void Initialize(Transform TouchObject);
+
+    /// <summary>
+    /// 刷新电机
+    /// </summary>
+    public abstract void Refresh();
+
+    /// <summary>
+    /// 最后一个触摸点抬起
+    /// </summary>
+    public abstract void TouchOnEndUp(Vector2 TargetPosition, float TargetAngle, Vector3 TargetScale);
+
+    /// <summary>
+    /// 触摸按下事件
+    /// </summary>
+    public abstract void TouchOnDown(Vector2 TargetPosition, float TargetAngle, Vector3 TargetScale);
+
+    /// <summary>
+    /// 触摸拖拽事件
+    /// </summary>
+    /// <param name="TargetPosition">移动位置</param>
+    /// <param name="TargetAngle">旋转角度</param>
+    /// <param name="TargetScale">缩放值</param>
+    public abstract void TouchOnDrag(Vector2 TargetPosition, float TargetAngle, Vector3 TargetScale);
+
+
+    /// <summary>
+    /// 电机移动方法
+    /// </summary>
+    /// <param name="Position">移动位置</param>
+    /// <returns>处理后的移动位置</returns>
+    public abstract Vector2 TouchMortor_Mobile(Vector2 TargetPosition);
+
+
+    /// <summary>
+    /// 电机旋转方法
+    /// </summary>
+    /// <param name="Angle">旋转角度</param>
+    /// <returns>处理后的旋转角度</returns>
+    public abstract float TouchMortor_Rotation(float TargetAngle);
+
+    /// <summary>
+    /// 电机缩放方法
+    /// </summary>
+    /// <param name="Scale">缩放值</param>
+    /// <returns>处理后的缩放值</returns>
+    public abstract Vector3 TouchMortor_Zoom(Vector3 TargetScale);
+
+}
diff --git a/SDHK_Tool/Component/Touch/Base/SB_TouchMotor.cs.meta b/SDHK_Tool/Component/Touch/Base/SB_TouchMotor.cs.meta
new file mode 100644
index 0000000..ccbb63b
--- /dev/null
+++ b/SDHK_Tool/Component/Touch/Base/SB_TouchMotor.cs.meta
@@ -0,0 +1,13 @@
+fileFormatVersion: 2
+guid: 9e0a4d9412993984daad8143e1f71672
+timeCreated: 1571914764
+licenseType: Pro
+MonoImporter:
+  externalObjects: {}
+  serializedVersion: 2
+  defaultReferences: []
+  executionOrder: 0
+  icon: {instanceID: 0}
+  userData: 
+  assetBundleName: 
+  assetBundleVariant: 
diff --git a/SDHK_Tool/Component/Touch/CanvasMode/SC_TouchCanvasMode.cs b/SDHK_Tool/Component/Touch/CanvasMode/SC_TouchCanvasMode.cs
new file mode 100644
index 0000000..74e507f
--- /dev/null
+++ b/SDHK_Tool/Component/Touch/CanvasMode/SC_TouchCanvasMode.cs
@@ -0,0 +1,83 @@
+﻿using System.Collections;
+using System.Collections.Generic;
+using UnityEngine;
+using SDHK_Tool.Component;
+
+
+/*
+ * 作者：闪电Y黑客
+ * 
+ * 日期： 2019.10.11
+ * 
+ * 功能：给触摸组件切换当前模式
+ *
+ */
+
+namespace SDHK_Tool.Component
+{
+
+    /// <summary>
+    /// 画布模式切换器:编辑器模式下运行
+    /// </summary>
+
+    [ExecuteInEditMode]
+    public class SC_TouchCanvasMode : MonoBehaviour
+    {
+        /// <summary>
+        /// 画布距离
+        /// </summary>
+        [Tooltip("画布距离")]
+        public float planeDistance;
+
+        [Tooltip("模式刷新：点击一次即可")]
+        public bool refresh = true;
+
+        /// <summary>
+        /// 触摸忽略鼠标事件
+        /// </summary>
+        [Tooltip("忽略鼠标")]
+        public bool IgnoreMouse = false;
+
+        private Canvas canvas;
+
+        private void Update()
+        {
+            if (refresh)
+            {
+                Refresh();
+                refresh = false;
+            }
+        }
+
+        /// <summary>
+        /// 触摸切换刷新模式
+        /// </summary>
+        [ContextMenu("画布模式刷新")]
+
+        public void Refresh()
+        {
+            if (GetComponent<Canvas>() == null) return;
+            canvas = GetComponent<Canvas>();
+
+            foreach (var TouchTransform in this.GetComponentsInChildren<SC_TouchTransform>())//搜寻所有子物体组件赋值画布模式
+            {
+                TouchTransform.renderMode = canvas.renderMode;
+                if (planeDistance != 0)
+                {
+                    TouchTransform.PlaneDistance = planeDistance;
+                }
+                else
+                {
+                    TouchTransform.PlaneDistance = canvas.planeDistance;
+                }
+
+            }
+
+            foreach (var TouchBase in this.GetComponentsInChildren<SB_Touch>())//搜寻所有子物体组件鼠标事件忽略属性
+            {
+                TouchBase.IgnoreMouse = IgnoreMouse;
+            }
+        }
+
+    }
+}
\ No newline at end of file
diff --git a/SDHK_Tool/Component/Touch/CanvasMode/SC_TouchCanvasMode.cs.meta b/SDHK_Tool/Component/Touch/CanvasMode/SC_TouchCanvasMode.cs.meta
new file mode 100644
index 0000000..6e3d0d1
--- /dev/null
+++ b/SDHK_Tool/Component/Touch/CanvasMode/SC_TouchCanvasMode.cs.meta
@@ -0,0 +1,13 @@
+fileFormatVersion: 2
+guid: 33430bca3b46939409ab3fe655627450
+timeCreated: 1570788520
+licenseType: Pro
+MonoImporter:
+  externalObjects: {}
+  serializedVersion: 2
+  defaultReferences: []
+  executionOrder: 0
+  icon: {instanceID: 0}
+  userData: 
+  assetBundleName: 
+  assetBundleVariant: 
diff --git a/SDHK_Tool/Component/Touch/SC_TouchColor.cs b/SDHK_Tool/Component/Touch/SC_TouchColor.cs
new file mode 100644
index 0000000..e19a831
--- /dev/null
+++ b/SDHK_Tool/Component/Touch/SC_TouchColor.cs
@@ -0,0 +1,128 @@
+﻿using System.Collections.Generic;
+using UnityEngine;
+using UnityEngine.EventSystems;
+using UnityEngine.UI;
+
+/*
+ * 作者：闪电Y黑客
+ * 
+ * 日期： 2019.7.10
+ * 
+ * 功能：触摸事件 UI变色器
+ *
+ */
+
+namespace SDHK_Tool.Component
+{
+
+    /// <summary>
+    /// 触摸UI变色器
+    /// </summary>
+    public class SC_TouchColor : SB_Touch
+    , IPointerDownHandler
+    , IPointerEnterHandler
+    , IPointerUpHandler
+    , IPointerExitHandler
+    {
+
+        [Space()]
+
+        [Tooltip("点击颜色")]
+        [SerializeField]
+        public Color TouchDown = new Color(0.7f, 0.7f, 0.7f, 1);
+
+        [Tooltip("停留颜色")]
+        [SerializeField]
+        public Color TouchEnter = new Color(0.9f, 0.9f, 0.9f, 1);
+
+        // [SerializeField]
+        public Color TouchExit = Color.white;
+
+        private Color imageColor;
+
+        private Image image;
+        private RawImage rawimage;
+
+        /// <summary>
+        /// 点击触摸id顺序链表[顺序列表]
+        /// </summary>
+        private List<int> TouchDownIds = new List<int>();
+
+        /// <summary>
+        /// 点击触摸id顺序链表[顺序列表]
+        /// </summary>
+        private List<int> TouchEnterIds = new List<int>();
+
+        void Awake()
+        {
+            if (GetComponent<Image>() != null) { image = GetComponent<Image>(); TouchExit = image.color; }
+
+            if (GetComponent<RawImage>() != null) { rawimage = GetComponent<RawImage>(); TouchExit = rawimage.color; }
+        }
+
+        public void OnPointerDown(PointerEventData eventData)
+        {
+            if (IgnoreMouse && eventData.pointerId < 0) return;
+            if (TouchDownIds.Contains(eventData.pointerId)) return;
+
+            TouchDownIds.Add(eventData.pointerId);
+
+            if (TouchDownIds.Count == 1)
+            {
+                imageColor = TouchDown;
+                Set_Color();
+            }
+        }
+
+        public void OnPointerEnter(PointerEventData eventData)
+        {
+            if (IgnoreMouse && eventData.pointerId < 0) return;
+            if (TouchEnterIds.Contains(eventData.pointerId)) return;
+
+            TouchEnterIds.Add(eventData.pointerId);
+            if (TouchDownIds.Count == 0 && TouchEnterIds.Count == 1)
+            {
+                imageColor = TouchEnter;
+                Set_Color();
+            }
+        }
+
+        public void OnPointerUp(PointerEventData eventData)
+        {
+            if (IgnoreMouse && eventData.pointerId < 0) return;
+            if (!TouchDownIds.Contains(eventData.pointerId)) return;
+
+            TouchDownIds.Remove(eventData.pointerId);
+            if (TouchDownIds.Count == 0 && TouchEnterIds.Count > 0)
+            {
+                imageColor = TouchEnter;
+                Set_Color();
+            }
+            if (TouchDownIds.Count == 0 && TouchEnterIds.Count == 0)
+            {
+                imageColor = TouchExit;
+                Set_Color();
+            }
+        }
+
+        public void OnPointerExit(PointerEventData eventData)
+        {
+            if (IgnoreMouse && eventData.pointerId < 0) return;
+            if (!TouchEnterIds.Contains(eventData.pointerId)) return;
+            TouchEnterIds.Remove(eventData.pointerId);
+            if (TouchDownIds.Count == 0 && TouchEnterIds.Count == 0)
+            {
+                imageColor = TouchExit;
+                Set_Color();
+            }
+        }
+
+        public void Set_Color()
+        {
+            if (image != null) image.color = imageColor;
+            if (rawimage != null) rawimage.color = imageColor;
+        }
+
+
+    }
+}
\ No newline at end of file
diff --git a/SDHK_Tool/Component/Touch/SC_TouchColor.cs.meta b/SDHK_Tool/Component/Touch/SC_TouchColor.cs.meta
new file mode 100644
index 0000000..52af53e
--- /dev/null
+++ b/SDHK_Tool/Component/Touch/SC_TouchColor.cs.meta
@@ -0,0 +1,13 @@
+fileFormatVersion: 2
+guid: 305e6d2abeac7fa449f7ee88e3899665
+timeCreated: 1562846899
+licenseType: Free
+MonoImporter:
+  externalObjects: {}
+  serializedVersion: 2
+  defaultReferences: []
+  executionOrder: 0
+  icon: {instanceID: 0}
+  userData: 
+  assetBundleName: 
+  assetBundleVariant: 
diff --git a/SDHK_Tool/Component/Touch/TouchCalculator.meta b/SDHK_Tool/Component/Touch/TouchCalculator.meta
new file mode 100644
index 0000000..9360d9f
--- /dev/null
+++ b/SDHK_Tool/Component/Touch/TouchCalculator.meta
@@ -0,0 +1,10 @@
+fileFormatVersion: 2
+guid: 7dcece0eeb58d7f4eac228625eb295e8
+folderAsset: yes
+timeCreated: 1585187510
+licenseType: Free
+DefaultImporter:
+  externalObjects: {}
+  userData: 
+  assetBundleName: 
+  assetBundleVariant: 
diff --git a/SDHK_Tool/Component/Touch/TouchCalculator/SC_TouchMotor.cs b/SDHK_Tool/Component/Touch/TouchCalculator/SC_TouchMotor.cs
new file mode 100644
index 0000000..8ae8217
--- /dev/null
+++ b/SDHK_Tool/Component/Touch/TouchCalculator/SC_TouchMotor.cs
@@ -0,0 +1,282 @@
+﻿using UnityEngine;
+using SDHK_Tool.Dynamic;
+
+/*
+ * 作者：闪电Y黑客
+ * 
+ * 日期： 2019.7.23
+ *
+ * 2019.10.12 添加触摸惯性
+ * 
+ * 功能：平滑和限制数值
+ *
+ * 注：可以自己写一个自己适用的，只要接上 I_TouchMotor 接口就能赋值给 TouchTransform
+ *
+ */
+namespace SDHK_Tool.Component
+{
+    /// <summary>
+    /// 触摸电机
+    /// </summary>
+    public class SC_TouchMotor : SB_TouchMotor
+    {
+        [Space()]
+
+        /// <summary>
+        /// 移动平滑速度
+        /// </summary>
+        [Tooltip("移动平滑速度：越小越快")]
+        public float Mobile_SmoothSpeed = 0.1f;
+
+
+
+        /// <summary>
+        /// 移动提前量偏差
+        /// </summary>
+        [Tooltip("移动惯性")]
+        public float Mobile_Inertial = 0;
+
+
+        [Space()]
+        /// <summary>
+        /// 旋转平滑速度
+        /// </summary>
+        [Tooltip("旋转平滑速度：越小越快")]
+        public float Rotation_SmoothSpeed = 0.1f;
+
+
+        /// <summary>
+        /// 旋转提前量偏差
+        /// </summary>
+        [Tooltip("旋转惯性")]
+        public float Rotation_Inertial = 0;
+
+        [Space()]
+
+        /// <summary>
+        /// 缩放平滑速度
+        /// </summary>
+        [Tooltip("缩放平滑速度：越小越快")]
+        public float Zoom_SmoothSpeed = 0.1f;
+
+        /// <summary>
+        /// 缩放提前量偏差
+        /// </summary>
+        [Tooltip("缩放惯性")]
+        public float Zoom_Inertial = 0;
+
+
+        [Space()]
+        [Space()]
+
+
+
+        /// <summary>
+        /// 移动限制激活
+        /// </summary>
+        [Tooltip("移动限制激活")]
+        public bool LimitMobile = false;
+
+
+        /// <summary>
+        /// 限制为当前位置
+        /// </summary>
+        [Tooltip("限制为当前位置")]
+        public bool Limit_Current = false;
+
+        /// <summary>
+        /// X轴约束
+        /// </summary>
+        [Tooltip("X轴约束")]
+        public bool Limit_X = true;
+
+        /// <summary>
+        /// Y轴约束
+        /// </summary>
+        [Tooltip("Y轴约束")]
+        public bool Limit_Y = true;
+
+
+        /// <summary>
+        /// 移动限制最小值
+        /// </summary>
+        [Tooltip("移动位置限制最小值")]
+        public Vector2 Limit_Size_MobileMin = new Vector2(-100, -100);
+        /// <summary>
+        /// 移动限制最大值
+        /// </summary>
+        [Tooltip("移动位置限制最大值")]
+        public Vector2 Limit_Size_MobileMax = new Vector2(100, 100);
+
+        [Space()]
+        [Space()]
+
+        /// <summary>
+        /// 旋转限制激活
+        /// </summary>
+        [Tooltip("旋转限制激活")]
+        public bool LimitRotation = false;
+
+        /// <summary>
+        /// 旋转角度限制
+        /// </summary>
+        [Tooltip("旋转角度限制值")]
+        public Vector2 Limit_Size_Rotation = new Vector2(-90, 90);
+
+        [Space()]
+        [Space()]
+
+
+        /// <summary>
+        /// 缩放限制激活
+        /// </summary>
+        [Tooltip("缩放限制激活")]
+        public bool LimitZoom = false;
+
+
+        /// <summary>
+        /// 缩放尺寸限制
+        /// </summary>
+        [Tooltip("缩放尺寸限制值")]
+        public Vector2 Limit_Size_Zoom = new Vector2(0.5f, 5);
+
+
+        private Transform TouchObject;
+        private Vector3 SaveScale;//保存初始化尺寸
+
+        private Vector2 TargetPosition_Last;
+        private float TargetAngle_Last;
+        private Vector3 TargetScale_Last;
+
+        private Vector2 Inertia_Position;
+
+        private float Inertia_Angle;
+        private Vector3 Inertia_Scale;
+
+        private Vector2 Inertia_Position_Save;
+        private float Inertia_Angle_Save;
+        private Vector3 Inertia_Scale_Save;
+
+        public SD_Motor_Vector2 MotorMobile;
+        public SD_Motor_Angle MotorRotation;
+        public SD_Motor_Vector3 MotorZoom;
+
+
+
+        public override void Initialize(Transform touchObject)
+        {
+            TouchObject = touchObject;
+
+            SaveScale = TouchObject.localScale;       //保存物体初始尺寸
+
+            MotorMobile = new SD_Motor_Vector2()	//初始化移动电机值
+            .Set_MotorValue(TouchObject.localPosition);
+
+
+            MotorRotation = new SD_Motor_Angle()	//初始化旋转电机值
+            .Set_MotorValue_Angle(TouchObject.localEulerAngles.z);
+
+            MotorZoom = new SD_Motor_Vector3()      //初始化缩放电机值
+            .Set_MotorValue(TouchObject.localScale);
+
+
+        }
+
+
+        public override void Refresh()
+        {
+            MotorMobile.Set_MotorValue(TouchObject.localPosition);
+            MotorRotation.Set_MotorValue_Angle(TouchObject.localEulerAngles.z);
+            MotorZoom.Set_MotorValue(TouchObject.localScale);
+
+            Inertia_Position_Save = Inertia_Position = Vector2.zero;
+            Inertia_Angle_Save = Inertia_Angle = 0;
+            Inertia_Scale_Save = Inertia_Scale = Vector3.zero;
+        }
+
+        private void Start()
+        {
+            if (TouchObject == null) TouchObject = this.transform;
+            
+            if (Limit_Current)
+            {
+                Limit_Size_MobileMin += (Vector2)TouchObject.localPosition;
+                Limit_Size_MobileMax += (Vector2)TouchObject.localPosition;
+            }
+        }
+
+        public override void TouchOnDown(Vector2 TargetPosition, float TargetAngle, Vector3 TargetScale)
+        {
+            Inertia_Position_Save = Inertia_Position = Vector2.zero;
+            Inertia_Angle_Save = Inertia_Angle = 0;
+            Inertia_Scale_Save = Inertia_Scale = Vector3.zero;
+        }
+
+        public override void TouchOnEndUp(Vector2 TargetPosition, float TargetAngle, Vector3 TargetScale)
+        {
+            Inertia_Position = Inertia_Position_Save * Mobile_Inertial;
+            Inertia_Angle = Inertia_Angle_Save * Rotation_Inertial;
+            Inertia_Scale = Inertia_Scale_Save * Zoom_Inertial;
+        }
+
+        public override void TouchOnDrag(Vector2 TargetPosition, float TargetAngle, Vector3 TargetScale)
+        {
+            Inertia_Position_Save = TargetPosition - TargetPosition_Last;
+            Inertia_Angle_Save = TargetAngle - TargetAngle_Last;
+            Inertia_Scale_Save = TargetScale - TargetScale_Last;
+
+            TargetPosition_Last = TargetPosition;
+            TargetAngle_Last = TargetAngle;
+            TargetScale_Last = TargetScale;
+
+        }
+
+
+
+        public override Vector2 TouchMortor_Mobile(Vector2 TargetPosition)
+        {
+            return MotorMobile
+            .Set_MotorSave(TouchObject.localPosition)
+            .SetTarget_Vector(TargetPosition + Inertia_Position)
+            .Set_MotorConstraint(LimitMobile)
+            .Set_MotorConstraint_Shaft(Limit_X, Limit_Y)
+            .Set_MotorConstraint_Limit(Limit_Size_MobileMin, Limit_Size_MobileMax)
+            .Set_MotorSpeed(Mobile_SmoothSpeed)
+            .Run_SmoothDamp(Time.fixedDeltaTime)
+            .Constraint_Vector_Local()
+            .Get_MotorSave()
+            ;
+
+
+        }
+
+        public override float TouchMortor_Rotation(float TargetAngle)
+        {
+            return MotorRotation
+            .Set_MotorSave(TouchObject.localEulerAngles.z)
+            .SetTarget_Angle(TargetAngle + Inertia_Angle)							//电机目标设置
+            .Set_MotorConstraint(LimitRotation)										//电机限制器激活
+            .Set_MotorConstraint_Limit(Limit_Size_Rotation.x, Limit_Size_Rotation.y)//电机限制范围设置
+            .Set_MotorSpeed(Rotation_SmoothSpeed)									//电机速度设置
+            .Run_SmoothDampAngle()													//电机运行平滑移动
+            .Constraint_Angle_Complete_Local()										//电机进行本地全面角度限制
+            .Get_MotorSave()														//获取电机的角度
+            ;
+        }
+
+        public override Vector3 TouchMortor_Zoom(Vector3 TargetScale)
+        {
+            return MotorZoom
+            .Set_MotorSave(TouchObject.localScale)
+            .SetTarget_Vector(TargetScale + Inertia_Scale)
+            .Set_MotorConstraint(LimitZoom)
+            .Set_MotorConstraint_Limit(Limit_Size_Zoom.x * SaveScale, Limit_Size_Zoom.y * SaveScale)
+            .Set_MotorSpeed(Zoom_SmoothSpeed)
+            .Run_SmoothDamp()
+            .Constraint_Vector_Local()
+            .Get_MotorSave()
+            ;
+        }
+
+    }
+}
\ No newline at end of file
diff --git a/SDHK_Tool/Component/Touch/TouchCalculator/SC_TouchMotor.cs.meta b/SDHK_Tool/Component/Touch/TouchCalculator/SC_TouchMotor.cs.meta
new file mode 100644
index 0000000..788d872
--- /dev/null
+++ b/SDHK_Tool/Component/Touch/TouchCalculator/SC_TouchMotor.cs.meta
@@ -0,0 +1,13 @@
+fileFormatVersion: 2
+guid: 24b7a17dce7262b40b7a6235f36d9565
+timeCreated: 1563774186
+licenseType: Free
+MonoImporter:
+  externalObjects: {}
+  serializedVersion: 2
+  defaultReferences: []
+  executionOrder: 0
+  icon: {instanceID: 0}
+  userData: 
+  assetBundleName: 
+  assetBundleVariant: 
diff --git a/SDHK_Tool/Component/Touch/TouchCalculator/SC_TouchTransform.cs b/SDHK_Tool/Component/Touch/TouchCalculator/SC_TouchTransform.cs
new file mode 100644
index 0000000..add8b26
--- /dev/null
+++ b/SDHK_Tool/Component/Touch/TouchCalculator/SC_TouchTransform.cs
@@ -0,0 +1,649 @@
+﻿
+using System.Collections.Generic;
+using SDHK_Tool.Static;
+using UnityEngine;
+using UnityEngine.EventSystems;
+// using SDHK_Tool.Extension;
+
+/*
+ * 作者：闪电Y黑客
+ * 
+ * 日期： 2019.7.22 
+ *
+ * 2019.10.11 触摸池合并，坐标计算从世界坐标改为局部坐标系，添加三种不同的画布模式计算功能
+ * 
+ * 2019.11.16 添加拖拽角度限制
+ *
+ * 功能：计算出触摸拖拽后的位置
+ *
+ */
+namespace SDHK_Tool.Component
+{
+
+    /// <summary>
+    /// 触摸位置计算器
+    /// </summary>
+    public class SC_TouchTransform : SB_Touch
+    , IPointerDownHandler
+    , IDragHandler
+    , IPointerUpHandler
+    , IScrollHandler
+    {
+
+        /// <summary>
+        /// 点击顶置
+        /// </summary>
+        [Tooltip("点击顶置")]
+        public bool Overhead = false;
+
+        [Space()]
+
+        /// <summary>
+        /// 画布模式：将影响拖拽计算
+        /// </summary>
+        [Tooltip("画布模式")]
+        public RenderMode renderMode;
+
+        /// <summary>
+        /// 屏幕距离：用于画布的Camera模式
+        /// </summary>
+        [Tooltip("画布距离")]
+        public float PlaneDistance = 100;
+
+
+        [Space()]
+
+        /// <summary>
+        /// 拖拽作用物体
+        /// </summary>
+        [Tooltip("拖拽作用物体：为null则默认为本身")]
+        public Transform TouchObject;
+
+        [Space()]
+
+        /// <summary>
+        /// 电机接口（当电机不为空时，数值将会通过电机计算后再作用到物体上）
+        /// </summary>
+        [Tooltip("电机接口（当电机不为空时，数值将会通过电机计算后再作用到物体上）")]
+        public SB_TouchMotor TouchMotor;//电机接口
+
+        [Space()]
+        [Space()]
+
+        /// <summary>
+        /// 触摸优先：优先使用最新的触摸点进行计算
+        /// </summary>
+        [Tooltip("触摸优先级")]
+        public bool TouchPriority = false;
+
+        /// <summary>
+        /// 计算结果直接作用于物体
+        /// </summary>
+        [Tooltip("拖拽结果作用于物体")]
+        public bool UseResults = true;
+
+        [Space()]
+        [Space()]
+
+        /// <summary>
+        /// 启用移动
+        /// </summary>
+        [Tooltip("移动")]
+        public bool Mobile = true;
+
+        /// <summary>
+        /// 启用旋转 
+        /// </summary>
+        [Tooltip("旋转")]
+        public bool Rotation = true;
+
+        /// <summary>
+        /// 开启缩放
+        /// </summary>
+        [Tooltip("缩放")]
+        public bool Zoom = true;
+
+
+        [Space()]
+        [Space()]
+
+        /// <summary>
+        /// 触摸点数量限制
+        /// </summary>
+        [Tooltip("触摸点限制")]
+        public Vector2 TouchLimit = new Vector2(1, 10);
+
+        /// <summary>
+        /// 拖拽角度限制：限制范围为 X~Y 之间
+        /// </summary>
+        [Tooltip("拖拽角度限制：限制范围为 X~Y 之间")]
+        public List<Vector2> TouchAngleLimit = new List<Vector2>();
+
+        [Space()]
+        [Space()]
+
+        [Tooltip("触摸调试画线")]
+        public bool DebugLine = false;
+
+        [Space()]
+        [Space()]
+
+        /// <summary>
+        /// 点击触摸id顺序链表[顺序列表]，通过列表id顺序去字典提取触摸
+        /// </summary>
+        [Tooltip("触摸点Id顺序表")]
+        public List<int> TouchIds = new List<int>();
+
+        /// <summary>
+        /// 触摸字典[无序]
+        /// </summary>
+        public Dictionary<int, PointerEventData> TouchPool = new Dictionary<int, PointerEventData>();
+
+
+
+        //第一第二触摸位置
+
+        /// <summary>
+        /// 从点击池筛选出的第一个触摸点
+        /// </summary>
+        [System.NonSerialized]
+        public Vector2 Touch_First;
+        /// <summary>
+        /// 从点击池筛选出的第二个触摸点，移动禁止情况下为物体的中心点
+        /// </summary>
+        [System.NonSerialized]
+        public Vector2 Touch_Second;
+
+
+        //触摸拖拽刷新位置
+
+        /// <summary>
+        /// 拖拽时计算出的双指中心点
+        /// </summary>
+        [System.NonSerialized]
+        public Vector2 TouchCenterPointer;
+
+        /// <summary>
+        /// 上一帧的双指中心点
+        /// </summary>
+        [System.NonSerialized]
+        public Vector2 TouchCenterPointer_Last;
+
+        /// <summary>
+        /// 拖拽时计算出的双指向量在世界坐标的角度
+        /// </summary>
+        [System.NonSerialized]
+        public float TouchAngle;
+
+        /// <summary>
+        /// 拖拽时计算出的双指向量缩放比例差值
+        /// </summary>
+        [System.NonSerialized]
+        public float TouchScale;
+
+        /// <summary>
+        /// 拖拽时计算出的中心点移动角度
+        /// </summary>
+        [System.NonSerialized]
+        public float TouchDragAngle;
+
+        /// <summary>
+        /// 拖拽角度限制标志
+        /// </summary>
+        [System.NonSerialized]
+        public bool DragAngleLimit = false;
+
+        //触摸点之间的向量  
+
+        /// <summary>
+        /// 双指向量
+        /// </summary>
+        [System.NonSerialized]
+        public Vector2 FirstToSecond;
+        private Vector2 FirstToSecond_Last;
+
+
+        //初始点击位置存档
+
+        /// <summary>
+        /// 每次点击时保存的双指中心点
+        /// </summary>
+        [System.NonSerialized]
+        public Vector2 Save_TouchCenterPointer;
+
+        /// <summary>
+        /// 每次点击时保存的双指向量角度
+        /// </summary>
+        [System.NonSerialized]
+        public float Save_TouchAngle;
+
+        /// <summary>
+        /// 每次点击时保存的双指向量长度
+        /// </summary>
+        [System.NonSerialized]
+        public float Save_TouchScale;
+
+
+        //初始点击偏差存档
+
+        /// <summary>
+        /// 每次点击时保存的双指中心点到物体中心的距离
+        /// </summary>
+        [System.NonSerialized]
+        public Vector2 Save_TouchCenterToTransform_Position;
+
+        /// <summary>
+        /// 每次点击时保存的双指角度与物体z轴的角度差
+        /// </summary>
+        [System.NonSerialized]
+        public float Save_TouchToTransform_Angle;
+
+
+        //计算后的位置
+
+        /// <summary>
+        /// 计算拖拽后得到的位置
+        /// </summary>
+        [System.NonSerialized]
+        public Vector2 Calculation_Position;
+
+        /// <summary>
+        /// 计算拖拽后得到的角度
+        /// </summary>
+        [System.NonSerialized]
+        public float Calculation_Angle;
+
+        /// <summary>
+        /// 计算拖拽后得到的尺寸
+        /// </summary>
+        [System.NonSerialized]
+        public Vector3 Calculation_Scale;
+
+
+        //最终结果
+
+        /// <summary>
+        /// 电机计算后的位置
+        /// </summary>
+        [System.NonSerialized]
+        public Vector2 Transform_Position;
+
+        /// <summary>
+        /// 电机计算后的角度
+        /// </summary>
+        [System.NonSerialized]
+        public float Transform_Angle;
+
+        /// <summary>
+        /// 电机计算后的尺寸
+        /// </summary>
+        [System.NonSerialized]
+        public Vector3 Transform_Scale;
+
+
+
+        void Awake()
+        {
+            if (TouchObject == null) TouchObject = this.transform;
+            if (TouchMotor != null) TouchMotor.Initialize(TouchObject);
+        }
+
+        void Start()
+        {
+            Calculation_Position = TouchObject.localPosition;
+            Calculation_Angle = TouchObject.localEulerAngles.z;
+            Calculation_Scale = TouchObject.localScale;
+        }
+
+        /// <summary>
+        /// 添加触摸点
+        /// </summary>
+        /// <param name="eventData">触摸点</param>
+        public void AddTouchData(PointerEventData eventData)
+        {
+            TouchIds.Add(eventData.pointerId);
+            TouchPool.Add(eventData.pointerId, eventData);
+        }
+
+        /// <summary>
+        /// 删除触摸点
+        /// </summary>
+        /// <param name="eventData">触摸点</param>
+        public void RemoveTouchData(PointerEventData eventData)
+        {
+            TouchIds.Remove(eventData.pointerId);
+            TouchPool.Remove(eventData.pointerId);
+        }
+
+        // OnPointerEnter,OnPointerDown
+        public void OnPointerDown(PointerEventData eventData)//点击事件
+        {
+            if (TouchPool.ContainsKey(eventData.pointerId)) return;
+            if (IgnoreMouse && eventData.pointerId < 0) return;//忽略鼠标
+
+            if (Overhead) TouchObject.SetAsLastSibling();//顶置自身
+
+            AddTouchData(eventData);
+
+            if (TouchPool.Count < TouchLimit.x || TouchPool.Count > TouchLimit.y) return;//触摸限制
+
+            TouchScreening();//稳定点筛选
+
+            FirstToSecond = Touch_Second - Touch_First; //当前手势向量
+            FirstToSecond_Last = FirstToSecond;         //上一次的手势向量
+
+            //===================================
+
+            TouchCenterPointer = Touch_First + FirstToSecond * 0.5f;    //当前手势中心点位置
+            Save_TouchCenterPointer = TouchCenterPointer;               //手势中心位置存档
+            TouchCenterPointer_Last = TouchCenterPointer;               //上一帧手势中心位置
+
+            //当前手势向量角度 = 角度计算类.角度转换正负无限数值转换为正360度角（角度计算类.获得两个二维向量的角度差（二维向量.上，当前手势的向量，轴方向翻转））;
+            TouchAngle = SS_EulerAngleConversion.Angle_PN_To_P360(SS_EulerAngleConversion.Get_Angle_In_Vector2Deviation(Vector2.up, FirstToSecond, false));
+
+            Save_TouchAngle = TouchAngle;   //手势初始角度存档
+
+            Save_TouchScale = FirstToSecond.magnitude;  //手势向量长度存档
+
+            Calculation_Scale = TouchObject.localScale;     //缩放位置赋值
+
+            //触摸中心到本物体的向量存档 = 真实位置- 触摸中心位置存档；
+            Save_TouchCenterToTransform_Position = (Vector2)TouchObject.localPosition - Save_TouchCenterPointer;
+
+            //手势向量角度与本物体角度差值存档 = 数学类.计算角度差（触摸向量角度存档，物体真实角度）;
+            Save_TouchToTransform_Angle = Mathf.DeltaAngle(Save_TouchAngle, TouchObject.localEulerAngles.z);
+
+            OnDrag(eventData);
+
+            if (TouchMotor != null) TouchMotor.TouchOnDown(Calculation_Position, Calculation_Angle, Calculation_Scale);
+
+        }
+
+        public void OnDrag(PointerEventData eventData)//拖拽事件
+        {
+
+
+            if (IgnoreMouse && eventData.pointerId < 0) return;//忽略鼠标
+
+            if (TouchPool.Count < TouchLimit.x || TouchPool.Count > TouchLimit.y) return;//触摸限制
+
+            TouchScreening();//稳定点筛选
+
+            FirstToSecond = Touch_Second - Touch_First;//手势向量计算
+
+            //===================================
+
+            TouchCenterPointer = Touch_First + FirstToSecond * 0.5f;//手势中心点位置
+
+            if (TouchCenterPointer_Last - TouchCenterPointer != Vector2.zero)
+                TouchDragAngle = SS_EulerAngleConversion.Get_Angle_In_Vector2(TouchCenterPointer_Last - TouchCenterPointer);
+
+
+            if (TouchAngleLimit.Count > 0)//触摸角度限制
+            {
+                for (int i = 0; i < TouchAngleLimit.Count; i++)
+                {
+                    if (SS_Mathf.If_IntervalAngle(TouchDragAngle, TouchAngleLimit[i].x, TouchAngleLimit[i].y)) break;
+
+                    if (i == TouchAngleLimit.Count - 1) DragAngleLimit = true;
+                }
+            }
+
+            if (!DragAngleLimit)
+            {
+
+                //当前手势向量角度 = 角度计算类.角度转换正负无限数值转换为正360度角（角度计算类.获得两个二维向量的角度差（二维向量.上，当前手势的向量，轴方向翻转））;
+                TouchAngle = SS_EulerAngleConversion.Angle_PN_To_P360(SS_EulerAngleConversion.Get_Angle_In_Vector2Deviation(Vector2.up, FirstToSecond, false));
+
+                //缩放后的大小
+                if ((Zoom && !Mobile) || (Zoom && TouchPool.Count > 1))
+                {
+                    //缩放比例差值 = ((当前手势向量长度-上一次手势向量长度)/上一次手势向量长度)
+                    TouchScale = ((FirstToSecond.magnitude - FirstToSecond_Last.magnitude) / FirstToSecond_Last.magnitude);
+
+                    //缩放后的虚拟计算大小 += 缩放比例差值 * 当前虚拟大小；
+                    Calculation_Scale += TouchScale * Calculation_Scale;
+
+                    //缩放后的 触摸点到物体中心向量的存档 += 缩放比例差值 * 触摸点到物体中心向量的存档
+                    if (Mobile) Save_TouchCenterToTransform_Position += TouchScale * Save_TouchCenterToTransform_Position;
+                }
+
+                //移动后的虚拟计算位置 = 触摸中心点 + 触摸中心点到物体中心向量存档；
+                if (Mobile) Calculation_Position = TouchCenterPointer + Save_TouchCenterToTransform_Position;
+
+
+                //旋转后的虚拟计算位置 = 角度计算类.获取_位置_环绕旋转（环绕物：虚拟计算位置，环绕中心点：当前触摸手势中心点，轴向：世界坐标.z轴 ，旋转角度：数学类.获取角度差（手势角度存档，当前手势角度））；
+                if (Mobile && Rotation) Calculation_Position = SS_EulerAngleConversion.Get_Vector3_RotateRound(Calculation_Position, TouchCenterPointer, Vector3.forward, Mathf.DeltaAngle(Save_TouchAngle, TouchAngle));
+
+                //物体旋转后的虚拟计算角度 = 手势角度与物体角度差存档 + 当前手势角度
+                if (Rotation) Calculation_Angle = Save_TouchToTransform_Angle + TouchAngle;
+
+            }
+
+            DragAngleLimit = false;
+
+            //更新双指的向量值
+
+            FirstToSecond_Last = FirstToSecond;
+
+            TouchCenterPointer_Last = TouchCenterPointer;
+
+
+            if (TouchMotor != null) TouchMotor.TouchOnDrag(Calculation_Position, Calculation_Angle, Calculation_Scale);
+
+
+        }
+
+
+        // OnPointerExit,OnPointerUp
+        public void OnPointerUp(PointerEventData eventData)//抬起事件
+        {
+            if (!TouchPool.ContainsKey(eventData.pointerId)) return;
+            if (IgnoreMouse && eventData.pointerId < 0) return;//忽略鼠标
+
+            if (TouchPool.Count < TouchLimit.x || TouchPool.Count > TouchLimit.y) return;//触摸限制
+
+            RemoveTouchData(eventData);
+
+            TouchScreening();//稳定点筛选
+
+            FirstToSecond = Touch_Second - Touch_First; //当前手势向量
+            FirstToSecond_Last = FirstToSecond;         //上一次的手势向量
+
+            //===================================
+
+            TouchCenterPointer = Touch_First + FirstToSecond * 0.5f;    //当前手势中心点位置
+            Save_TouchCenterPointer = TouchCenterPointer;               //手势中心位置存档
+
+            //当前手势向量角度 = 角度计算类.角度转换正负无限数值转换为正360度角（角度计算类.获得两个二维向量的角度差（二维向量.上，当前手势的向量，轴方向翻转））;
+            TouchAngle = SS_EulerAngleConversion.Angle_PN_To_P360(SS_EulerAngleConversion.Get_Angle_In_Vector2Deviation(Vector2.up, FirstToSecond, false));
+
+            Save_TouchAngle = TouchAngle;   //手势初始角度存档
+
+            Save_TouchScale = FirstToSecond.magnitude;  //手势向量长度存档
+
+            //触摸中心到本物体的向量存档 =虚拟计算位置 - 触摸中心位置存档；
+            Save_TouchCenterToTransform_Position = Calculation_Position - Save_TouchCenterPointer;
+
+            //手势向量角度与本物体角度差值存档 = 数学类.计算角度差（触摸向量角度存档，虚拟计算角度）;
+            Save_TouchToTransform_Angle = Mathf.DeltaAngle(Save_TouchAngle, Calculation_Angle);
+
+            if (TouchMotor != null && TouchPool.Count < 1) TouchMotor.TouchOnEndUp(Calculation_Position, Calculation_Angle, Calculation_Scale);
+
+        }
+
+        public void OnScroll(PointerEventData eventData)//鼠标滚动
+        {
+            if (IgnoreMouse && eventData.pointerId < 0) return;//忽略鼠标
+            if (!Zoom) return;
+
+            Calculation_Scale = TouchObject.localScale;     //缩放位置赋值
+
+            //缩放比例差值 = ((当前手势向量长度-上一次手势向量长度)/上一次手势向量长度)；
+            TouchScale = eventData.scrollDelta.y * 0.1f;
+
+            //缩放后的虚拟计算大小 +=缩放比例差值*当前虚拟大小；
+            Calculation_Scale += TouchScale * Calculation_Scale;
+
+            //缩放后的 触摸点到物体中心向量的存档 += ((当前手势向量长度-上一次手势向量长度)/上一次手势向量长度)*触摸点到物体中心向量的存档
+            if (Mobile) Save_TouchCenterToTransform_Position += eventData.scrollDelta.y * 0.1f * Save_TouchCenterToTransform_Position;
+
+        }
+
+
+        /// <summary>
+        /// 触摸点过滤：过滤计算出两个稳定点进行触摸计算
+        /// </summary>
+        private void TouchScreening()
+        {
+            if (TouchPool.Count == 0) return;
+
+            if (!Mobile && (Rotation || Zoom)) //移动禁用情况
+            {
+
+                Vector3 ScreenTouchPointFirst = (TouchPriority)//触摸优先判断
+                ? TouchPool[TouchIds[TouchIds.Count - 1]].position//最后一个触摸点
+                : TouchPool[TouchIds[0]].position//第一个触摸点
+                ;
+
+                if (renderMode == RenderMode.ScreenSpaceOverlay)//假如没有父物体则要转世界坐标
+                {
+                    Touch_First = SS_CoordinateConversion.World_To_local(TouchObject.parent, ScreenTouchPointFirst);
+                }
+                else
+                {
+                    Touch_First = SS_CoordinateConversion.Screen_To_Local(TouchObject.parent, ScreenTouchPointFirst, PlaneDistance);
+                }
+
+                Touch_Second = TouchObject.localPosition;              //第二个触摸点为物体中心
+            }
+            else//开启移动情况
+            {
+                if (TouchPriority)//触摸优先判断
+                {
+                    //优先筛选出最新的两个触摸点
+                    Vector3 ScreenTouchPointFirst = (TouchPool.Count < 2)
+                    ? TouchPool[TouchIds[TouchIds.Count - 1]].position
+                    : TouchPool[TouchIds[TouchIds.Count - 2]].position
+                    ;
+                    Vector3 ScreenTouchPointSecond = TouchPool[TouchIds[TouchIds.Count - 1]].position;
+
+                    if (renderMode == RenderMode.ScreenSpaceOverlay)
+                    {
+                        Touch_First = SS_CoordinateConversion.World_To_local(TouchObject.parent, ScreenTouchPointFirst);
+                        Touch_Second = SS_CoordinateConversion.World_To_local(TouchObject.parent, ScreenTouchPointSecond);
+                    }
+                    else//屏幕转世界坐标和屏幕直接当做世界坐标的区别//!!
+                    {
+                        Touch_First = SS_CoordinateConversion.Screen_To_Local(TouchObject.parent, ScreenTouchPointFirst, PlaneDistance);
+                        Touch_Second = SS_CoordinateConversion.Screen_To_Local(TouchObject.parent, ScreenTouchPointSecond, PlaneDistance);
+                    }
+
+                }
+                else
+                {
+                    //使用最早的两个触摸点
+                    Vector3 ScreenTouchPointFirst = TouchPool[TouchIds[0]].position;
+                    Vector3 ScreenTouchPointSecond = (TouchPool.Count < 2)
+                   ? TouchPool[TouchIds[0]].position
+                   : TouchPool[TouchIds[1]].position
+                   ;
+
+                    if (renderMode == RenderMode.ScreenSpaceOverlay)
+                    {
+                        Touch_First = SS_CoordinateConversion.World_To_local(TouchObject.parent, ScreenTouchPointFirst);
+                        Touch_Second = SS_CoordinateConversion.World_To_local(TouchObject.parent, ScreenTouchPointSecond);
+                    }
+                    else
+                    {
+                        Touch_First = SS_CoordinateConversion.Screen_To_Local(TouchObject.parent, ScreenTouchPointFirst, PlaneDistance);
+                        Touch_Second = SS_CoordinateConversion.Screen_To_Local(TouchObject.parent, ScreenTouchPointSecond, PlaneDistance);
+                    }
+                }
+            }
+
+        }
+
+
+        /// <summary>
+        /// 刷新Transform为当前：用于解除限制时的虚拟位置矫正
+        /// </summary>
+        public void Refresh_Touch()
+        {
+            Calculation_Position = TouchObject.localPosition;
+            Calculation_Angle = TouchObject.localEulerAngles.z;
+            Calculation_Scale = TouchObject.localScale;
+
+            if (TouchMotor != null) TouchMotor.Refresh();
+        }
+
+        private void FixedUpdate()//SDHK临时修改:Update肯能造成视觉卡顿？？？
+        {
+            if (TouchMotor != null)//判断电机是否存在
+            {
+                Transform_Position = TouchMotor.TouchMortor_Mobile(Calculation_Position);
+                Transform_Angle = TouchMotor.TouchMortor_Rotation(Calculation_Angle);
+                Transform_Scale = TouchMotor.TouchMortor_Zoom(Calculation_Scale);
+            }
+            else//不存在直接赋值
+            {
+                Transform_Position = Calculation_Position;
+                Transform_Angle = Calculation_Angle;
+                Transform_Scale = Calculation_Scale;
+            }
+
+            if (UseResults)//判断是否计算结果直接作用于物体
+            {
+                TouchObject.localPosition = Transform_Position;
+                TouchObject.SE_LocalEulerAngles_Z(Transform_Angle);
+                TouchObject.localScale = Transform_Scale;
+            }
+
+
+            if (DebugLine)
+            {
+                Debug.DrawLine(TouchObject.parent.SE_Local_To_World(Touch_First), TouchObject.parent.SE_Local_To_World(Touch_Second), Color.red);
+                Debug.DrawLine(TouchObject.parent.SE_Local_To_World(Touch_First), TouchObject.parent.SE_Local_To_World(Calculation_Position), Color.green);
+                Debug.DrawLine(TouchObject.parent.SE_Local_To_World(Touch_Second), TouchObject.parent.SE_Local_To_World(Calculation_Position), Color.green);
+                Debug.DrawLine(TouchObject.parent.SE_Local_To_World(TouchCenterPointer), TouchObject.parent.SE_Local_To_World(Calculation_Position), Color.yellow);
+            }
+        }
+        void Update()
+        {
+
+
+            // if (TouchMotor != null)//判断电机是否存在
+            // {
+            //     Transform_Position = TouchMotor.TouchMortor_Mobile(Calculation_Position);
+            //     Transform_Angle = TouchMotor.TouchMortor_Rotation(Calculation_Angle);
+            //     Transform_Scale = TouchMotor.TouchMortor_Zoom(Calculation_Scale);
+            // }
+            // else//不存在直接赋值
+            // {
+            //     Transform_Position = Calculation_Position;
+            //     Transform_Angle = Calculation_Angle;
+            //     Transform_Scale = Calculation_Scale;
+            // }
+
+            // if (UseResults)//判断是否计算结果直接作用于物体
+            // {
+            //     TouchObject.localPosition = Transform_Position;
+            //     TouchObject.SE_LocalEulerAngles_Z(Transform_Angle);
+            //     TouchObject.localScale = Transform_Scale;
+            // }
+
+
+            // if (DebugLine)
+            // {
+            //     Debug.DrawLine(TouchObject.parent.SE_Local_To_World(Touch_First), TouchObject.parent.SE_Local_To_World(Touch_Second), Color.red);
+            //     Debug.DrawLine(TouchObject.parent.SE_Local_To_World(Touch_First), TouchObject.parent.SE_Local_To_World(Calculation_Position), Color.green);
+            //     Debug.DrawLine(TouchObject.parent.SE_Local_To_World(Touch_Second), TouchObject.parent.SE_Local_To_World(Calculation_Position), Color.green);
+            //     Debug.DrawLine(TouchObject.parent.SE_Local_To_World(TouchCenterPointer), TouchObject.parent.SE_Local_To_World(Calculation_Position), Color.yellow);
+            // }
+
+        }
+
+
+
+    }
+}
\ No newline at end of file
diff --git a/SDHK_Tool/Component/Touch/TouchCalculator/SC_TouchTransform.cs.meta b/SDHK_Tool/Component/Touch/TouchCalculator/SC_TouchTransform.cs.meta
new file mode 100644
index 0000000..3196381
--- /dev/null
+++ b/SDHK_Tool/Component/Touch/TouchCalculator/SC_TouchTransform.cs.meta
@@ -0,0 +1,13 @@
+fileFormatVersion: 2
+guid: ddec520d796e5414ca785cb698900bb0
+timeCreated: 1563514437
+licenseType: Free
+MonoImporter:
+  externalObjects: {}
+  serializedVersion: 2
+  defaultReferences: []
+  executionOrder: 0
+  icon: {instanceID: 0}
+  userData: 
+  assetBundleName: 
+  assetBundleVariant: 
diff --git a/SDHK_Tool/Component/Touch/TouchEvent.meta b/SDHK_Tool/Component/Touch/TouchEvent.meta
new file mode 100644
index 0000000..a9b4307
--- /dev/null
+++ b/SDHK_Tool/Component/Touch/TouchEvent.meta
@@ -0,0 +1,10 @@
+fileFormatVersion: 2
+guid: 176d52c0dbc534141aa780066950d884
+folderAsset: yes
+timeCreated: 1585187510
+licenseType: Free
+DefaultImporter:
+  externalObjects: {}
+  userData: 
+  assetBundleName: 
+  assetBundleVariant: 
diff --git a/SDHK_Tool/Component/Touch/TouchEvent/RayCast.meta b/SDHK_Tool/Component/Touch/TouchEvent/RayCast.meta
new file mode 100644
index 0000000..5d3259a
--- /dev/null
+++ b/SDHK_Tool/Component/Touch/TouchEvent/RayCast.meta
@@ -0,0 +1,10 @@
+fileFormatVersion: 2
+guid: eb428aeba2937b44e81c281fb409ea26
+folderAsset: yes
+timeCreated: 1585187510
+licenseType: Free
+DefaultImporter:
+  externalObjects: {}
+  userData: 
+  assetBundleName: 
+  assetBundleVariant: 
diff --git a/SDHK_Tool/Component/Touch/TouchEvent/RayCast/SC_TouchEvent_RayCast.cs b/SDHK_Tool/Component/Touch/TouchEvent/RayCast/SC_TouchEvent_RayCast.cs
new file mode 100644
index 0000000..ea94197
--- /dev/null
+++ b/SDHK_Tool/Component/Touch/TouchEvent/RayCast/SC_TouchEvent_RayCast.cs
@@ -0,0 +1,249 @@
+﻿using System.Collections.Generic;
+using System.Linq;
+using SDHK_Tool.Static;
+using UnityEngine;
+using UnityEngine.EventSystems;
+using UnityEngine.UI;
+
+
+/*
+ * 作者：闪电Y黑客
+ * 
+ * 日期： 2019.7.24
+ *
+ * 2019.10.12 添加父物体事件渗透
+ *
+ * 2019.12.16 修复穿透抬起Bug
+ *
+ * 2020.03.12 解除画布射线，改用UI事件射线
+ * 
+ * 功能：将触摸事件变的可穿透
+ *
+ * 注：该组件要保持在所有ui的最上层
+ *
+ */
+
+namespace SDHK_Tool.Component
+{
+
+    /// <summary>
+    /// 触摸事件穿透器：将触摸事件穿透所有UI
+    /// </summary>
+    public class SC_TouchEvent_RayCast : MonoBehaviour
+    , IBeginDragHandler
+    , IEndDragHandler
+    , IDragHandler
+    , IPointerDownHandler
+    , IPointerUpHandler
+    , IScrollHandler
+    , IPointerEnterHandler
+    , IPointerExitHandler
+    {
+        public static SC_TouchEvent_RayCast instance;//单例
+
+        /// <summary>
+        /// 应用画布
+        /// </summary>
+        // [Tooltip("应用画布")]
+        // public GraphicRaycaster canvas;//作用画布
+
+        /// <summary>
+        /// 拦截标签
+        /// </summary>
+        [Tooltip("拦截标签")]
+        public string InterceptTag = "";//拦截标签
+
+        /// <summary>
+        /// 忽略层
+        /// </summary>
+        [Tooltip("忽略层")]
+        public string[] IgnoreLayer;//忽略层
+
+        /// <summary>
+        /// 点击获取的UI集合字典
+        /// </summary>
+        public Dictionary<int, List<RaycastResult>> TouchRayDownLists = new Dictionary<int, List<RaycastResult>>();//点击集合
+
+        /// <summary>
+        /// 拖拽获取的UI集合字典
+        /// </summary>
+        public Dictionary<int, List<RaycastResult>> TouchRayDragLists = new Dictionary<int, List<RaycastResult>>();//拖拽集合
+
+        /// <summary>
+        /// 停留获取的UI集合字典
+        /// </summary>
+        public Dictionary<int, List<RaycastResult>> TouchRayEnterLists = new Dictionary<int, List<RaycastResult>>();//停留集合
+
+        /// <summary>
+        /// 触摸字典[无序]
+        /// </summary>
+        public Dictionary<int, PointerEventData> TouchEnterPool = new Dictionary<int, PointerEventData>();
+
+
+        private Image Image;
+
+        private void Awake()
+        {
+            instance = this;//单例
+        }
+
+        // Use this for initialization
+        void Start()
+        {
+
+            Image //必须要有图片
+            = (GetComponent<Image>() == null)
+            ? gameObject.AddComponent<Image>()
+            : GetComponent<Image>()
+            ;
+
+            Image.color = new Color(1, 1, 1, 0);//颜色透明化
+
+        }
+
+        public void OnPointerDown(PointerEventData eventData)//按下事件
+        {
+            if (TouchRayDownLists.ContainsKey(eventData.pointerId)) return;
+
+            List<RaycastResult> UI_List = SS_Ray.UIRayCast(eventData.position, InterceptTag, IgnoreLayer);//提取物体列表
+
+            if (UI_List.Count < 1) return;
+            UI_List.RemoveAt(0);//顶层为自己，剔除。
+            if (!TouchRayDownLists.ContainsKey(eventData.pointerId)) TouchRayDownLists.Add(eventData.pointerId, UI_List);//添加物体列表到字典
+
+            //触摸事件穿透通知：按下
+            SS_Ray.UISendEvent(UI_List, eventData, ExecuteEvents.pointerDownHandler);
+            
+
+            // SS_Ray.UISendEvent(UI_List, eventData, ExecuteEvents.submitHandler);//!!!选中事件？
+
+        }
+
+        public void OnPointerUp(PointerEventData eventData)//抬起事件
+        {
+
+            if (!TouchRayDownLists.ContainsKey(eventData.pointerId)) return;
+            //抬起事件
+
+            //触摸事件穿透通知：停止拖拽，抬起
+            SS_Ray.UISendEvent(TouchRayDownLists[eventData.pointerId], eventData, ExecuteEvents.pointerUpHandler);
+            // SS_Ray.UISendEvent(TouchRayDownLists[eventData.pointerId], eventData, ExecuteEvents.deselectHandler);//!!!选中事件？
+
+            //点击事件
+
+            List<RaycastResult> UI_List = SS_Ray.UIRayCast(eventData.position, InterceptTag, IgnoreLayer);//提取物体列表
+
+            if (UI_List.Count > 0) UI_List.RemoveAt(0);//顶层为自己，剔除。
+
+            List<RaycastResult> Click_List = SS_GameObject.List_Intersect(TouchRayDownLists[eventData.pointerId], UI_List, (RaycastResult a, RaycastResult b) => { return object.ReferenceEquals(a.gameObject, b.gameObject); });
+
+            SS_Ray.UISendEvent(Click_List, eventData, ExecuteEvents.pointerClickHandler);
+
+            if (TouchRayDownLists.ContainsKey(eventData.pointerId)) TouchRayDownLists.Remove(eventData.pointerId);  //去除物体列表
+
+        }
+
+        public void OnBeginDrag(PointerEventData eventData)
+        {
+            if (TouchRayDragLists.ContainsKey(eventData.pointerId)) return;
+            List<RaycastResult> UI_List = SS_Ray.UIRayCast(eventData.position, InterceptTag, IgnoreLayer);//提取物体列表
+            if (UI_List.Count < 1) return;
+            UI_List.RemoveAt(0);//顶层为自己，剔除。
+            if (!TouchRayDragLists.ContainsKey(eventData.pointerId)) TouchRayDragLists.Add(eventData.pointerId, UI_List);//添加物体列表到字典
+            //触摸事件穿透通知：拖拽开始
+            SS_Ray.UISendEvent(TouchRayDragLists[eventData.pointerId], eventData, ExecuteEvents.beginDragHandler);
+        }
+
+        public void OnEndDrag(PointerEventData eventData)
+        {
+            if (!TouchRayDragLists.ContainsKey(eventData.pointerId)) return;
+            //触摸事件通知：拖拽结束
+            SS_Ray.UISendEvent(TouchRayDragLists[eventData.pointerId], eventData, ExecuteEvents.endDragHandler);
+            if (TouchRayDragLists.ContainsKey(eventData.pointerId)) TouchRayDragLists.Remove(eventData.pointerId);  //去除物体列表
+        }
+
+
+        public void OnPointerEnter(PointerEventData eventData)
+        {
+            if (TouchRayEnterLists.ContainsKey(eventData.pointerId)) return;
+            List<RaycastResult> UI_List = SS_Ray.UIRayCast(eventData.position, InterceptTag, IgnoreLayer);//提取物体列表
+            if (UI_List.Count < 1) return;
+            UI_List.RemoveAt(0);//顶层为自己，剔除。
+
+            if (!TouchRayEnterLists.ContainsKey(eventData.pointerId)) TouchRayEnterLists.Add(eventData.pointerId, UI_List);//停留UI集合池添加
+
+            //触摸事件通知：停留
+            SS_Ray.UISendEvent(UI_List, eventData, ExecuteEvents.pointerEnterHandler);
+
+            if (!TouchEnterPool.ContainsKey(eventData.pointerId)) TouchEnterPool.Add(eventData.pointerId, eventData);//停留池添加
+        }
+
+        public void OnPointerExit(PointerEventData eventData)
+        {
+            if (!TouchRayEnterLists.ContainsKey(eventData.pointerId)) return;
+            if (TouchEnterPool.ContainsKey(eventData.pointerId)) TouchEnterPool.Remove(eventData.pointerId);//停留池删除
+
+            //触摸事件通知：离开
+            SS_Ray.UISendEvent(TouchRayEnterLists[eventData.pointerId], eventData, ExecuteEvents.pointerExitHandler);
+
+            if (TouchRayEnterLists.ContainsKey(eventData.pointerId)) TouchRayEnterLists.Remove(eventData.pointerId);  //停留UI集合池剔除
+        }
+
+        public void OnDrag(PointerEventData eventData)//拖拽事件
+        {
+            if (!TouchRayDragLists.ContainsKey(eventData.pointerId)) return;
+            //触摸事件通知：拖拽
+            SS_Ray.UISendEvent(TouchRayDownLists[eventData.pointerId], eventData, ExecuteEvents.dragHandler);
+        }
+
+        public void OnScroll(PointerEventData eventData)
+        {
+            List<RaycastResult> UI_List = SS_Ray.UIRayCast(eventData.position, InterceptTag, IgnoreLayer);//提取物体列表
+            if (UI_List.Count < 1) return;
+            UI_List.RemoveAt(0);//顶层为自己，剔除。
+
+            //触摸事件通知：滚轮
+            SS_Ray.UISendEvent(UI_List, eventData, ExecuteEvents.scrollHandler);
+        }
+
+        public void OnStay(PointerEventData eventData)
+        {
+            List<RaycastResult> UI_List = SS_Ray.UIRayCast(eventData.position, InterceptTag, IgnoreLayer);//提取物体列表
+            if (UI_List.Count < 1) return;
+            UI_List.RemoveAt(0);//顶层为自己，剔除。
+
+            List<RaycastResult> Enter_List = SS_GameObject.List_Except(UI_List, TouchRayEnterLists[eventData.pointerId], (RaycastResult a, RaycastResult b) => { return object.ReferenceEquals(a.gameObject, b.gameObject); });
+            List<RaycastResult> Exit_List = SS_GameObject.List_Except(TouchRayEnterLists[eventData.pointerId], UI_List, (RaycastResult a, RaycastResult b) => { return object.ReferenceEquals(a.gameObject, b.gameObject); });
+
+            //触摸事件通知：停留
+            SS_Ray.UISendEvent(Enter_List, eventData, ExecuteEvents.pointerEnterHandler);
+
+            //触摸事件通知：离开
+            SS_Ray.UISendEvent(Exit_List, eventData, ExecuteEvents.pointerExitHandler);
+
+            TouchRayEnterLists[eventData.pointerId] = new List<RaycastResult>(UI_List);
+        }
+
+        /// <summary>
+        /// 刷新触摸点
+        /// </summary>
+        /// <param name="EventData">触摸点</param>
+        public void TouchRefresh(PointerEventData EventData)
+        {
+            OnPointerUp(EventData);
+            OnPointerDown(EventData);
+        }
+
+
+        // Update is called once per frame
+        private void LateUpdate()
+        {
+            foreach (var item in TouchEnterPool)
+            {
+                OnStay(item.Value);
+            }
+        }
+
+    }
+
+}
\ No newline at end of file
diff --git a/SDHK_Tool/Component/Touch/TouchEvent/RayCast/SC_TouchEvent_RayCast.cs.meta b/SDHK_Tool/Component/Touch/TouchEvent/RayCast/SC_TouchEvent_RayCast.cs.meta
new file mode 100644
index 0000000..6395273
--- /dev/null
+++ b/SDHK_Tool/Component/Touch/TouchEvent/RayCast/SC_TouchEvent_RayCast.cs.meta
@@ -0,0 +1,13 @@
+fileFormatVersion: 2
+guid: 65339bc0a2b83fe4e8d60c21baa35b25
+timeCreated: 1563946757
+licenseType: Free
+MonoImporter:
+  externalObjects: {}
+  serializedVersion: 2
+  defaultReferences: []
+  executionOrder: 0
+  icon: {instanceID: 0}
+  userData: 
+  assetBundleName: 
+  assetBundleVariant: 
diff --git a/SDHK_Tool/Component/Touch/TouchEvent/SC_TouchEvent_Down.cs b/SDHK_Tool/Component/Touch/TouchEvent/SC_TouchEvent_Down.cs
new file mode 100644
index 0000000..45bf724
--- /dev/null
+++ b/SDHK_Tool/Component/Touch/TouchEvent/SC_TouchEvent_Down.cs
@@ -0,0 +1,243 @@
+﻿using System;
+using UnityEngine;
+using UnityEngine.EventSystems;
+using SDHK_Tool.Dynamic;
+using System.Collections.Generic;
+
+/*
+ * 作者：闪电Y黑客
+ * 
+ * 日期： 2019.7.16
+ *
+ * 2019.10.09 :触摸池合并
+ * 
+ * 功能：点击事件监听
+ *
+ */
+
+
+namespace SDHK_Tool.Component
+{
+    
+    /// <summary>
+    /// 触摸事件监听器：【点击事件】
+    /// </summary>
+    public class SC_TouchEvent_Down : SB_TouchEvent
+    
+    , IPointerDownHandler
+    , IPointerUpHandler
+    , IPointerClickHandler
+    , IBeginDragHandler
+    , IEndDragHandler
+    , IDragHandler
+    {
+
+        [Space()]
+        [Tooltip("忽略拖拽事件影响")]
+        public bool IgnoreDrag = false;	//忽略拖拽
+
+        [Tooltip("触摸时间")]
+        public float TouchTime = 0.5f;  //触摸时间
+
+        /// <summary>
+        /// 触摸事件：按下
+        /// </summary>
+        public Action TouchOnDown;
+
+        /// <summary>
+        /// 触摸事件：长按按下
+        /// </summary>
+        public Action TouchOnLongDown;
+
+        /// <summary>
+        /// 触摸事件：按住【Update】
+        /// </summary>
+        public Action TouchOnStay;
+
+        /// <summary>
+        /// 触摸事件：短按按住【Update】
+        /// </summary>
+        public Action TouchOnShortStay;
+
+        /// <summary>
+        /// 触摸事件：长按按住【Update】
+        /// </summary>
+        public Action TouchOnLongStay;
+
+
+
+        /// <summary>
+        /// 触摸事件：按下后抬起
+        /// </summary>
+        public Action TouchOnUp;
+
+        /// <summary>
+        /// 触摸事件：短按后抬起
+        /// </summary>
+        public Action TouchOnShortUp;
+
+        /// <summary>
+        /// 触摸事件：长按后抬起
+        /// </summary>
+        public Action TouchOnLongUp;
+
+
+
+        /// <summary>
+        /// 触摸事件：点击
+        /// </summary>
+        public Action TouchOnClick;
+
+        /// <summary>
+        /// 触摸事件：短点击
+        /// </summary>
+        public Action TouchOnShortClick;
+
+        /// <summary>
+        /// 触摸事件：长点击
+        /// </summary>
+        public Action TouchOnLongClick;
+
+
+        private int touchCount = 0;		//触摸数量
+        public int TouchCount { get { return touchCount; } }
+
+
+        private SD_MarkerClock MarkerClock;
+
+        private bool isDown = false;     //已按下
+
+        private bool isTouch = true;
+
+        private bool isLongDown = false; //长按触发
+
+
+        void Awake()
+        {
+            MarkerClock = new SD_MarkerClock();
+            MarkerClock.Reset_Marker();//SDHK临时修改:计时器的理念设定不完善
+        }
+
+
+        /// <summary>
+        /// 添加触摸点
+        /// </summary>
+        /// <param name="eventData">触摸点</param>
+        public void AddTouchData(PointerEventData eventData)
+        {
+
+            TouchIds.Add(eventData.pointerId);
+            TouchPool.Add(eventData.pointerId, eventData);
+        }
+
+        /// <summary>
+        /// 删除触摸点
+        /// </summary>
+        /// <param name="eventData">触摸点</param>
+        public void RemoveTouchData(PointerEventData eventData)
+        {
+
+            TouchIds.Remove(eventData.pointerId);
+            TouchPool.Remove(eventData.pointerId);
+        }
+
+
+        public void OnPointerDown(PointerEventData eventData)
+        {
+            if (TouchPool.ContainsKey(eventData.pointerId)) return;
+            if (IgnoreMouse && eventData.pointerId < 0) return;
+            touchCount++;
+            if (touchCount == 1)
+            {
+                isDown = true;
+                MarkerClock.Reset_Marker();
+            }
+
+            //触摸池添加
+            AddTouchData(eventData);
+
+            if (TouchOnDown != null) TouchOnDown();
+        }
+
+        public void OnPointerUp(PointerEventData eventData)
+        {
+            if (!TouchPool.ContainsKey(eventData.pointerId)) return;
+            if (IgnoreMouse && eventData.pointerId < 0) return;
+            touchCount--;
+
+            if (TouchOnUp != null) TouchOnUp();
+
+            if (touchCount == 0 && isTouch)
+            {
+                if (!isLongDown && TouchOnShortUp != null) TouchOnShortUp();
+                if (isLongDown && TouchOnLongUp != null) TouchOnLongUp();
+            }
+
+            //触摸池删除
+            RemoveTouchData(eventData);
+
+            if (touchCount == 0)
+            {
+                isDown = false;
+                isLongDown = false;
+            }
+
+            isTouch = true;
+
+        }
+
+        public void OnPointerClick(PointerEventData eventData)
+        {
+            if (!TouchPool.ContainsKey(eventData.pointerId)) return;
+            if (IgnoreMouse && eventData.pointerId < 0) return;
+
+            if (TouchOnClick != null) TouchOnClick();
+
+            if (touchCount == 0 && isTouch)
+            {
+                if (!isLongDown && TouchOnShortClick != null) TouchOnShortClick();
+                if (isLongDown && TouchOnLongClick != null) TouchOnLongClick();
+            }
+
+            isTouch = true;
+
+        }
+
+        public void OnBeginDrag(PointerEventData eventData)
+        {
+            if (!IgnoreDrag) isTouch = false;
+        }
+        // public void
+
+        public void OnEndDrag(PointerEventData eventData)
+        {
+            // isTouch = true;
+        }
+        public void OnDrag(PointerEventData eventData)//SDHK临时修改:OnBeginDrag触发太晚？ OnEndDrag的触发太早？ 导致isTouch失效，也可能是穿透器设定不完善
+        {
+            if (!IgnoreDrag) isTouch = false;
+        }
+
+
+
+
+        void Update()
+        {
+            if (isDown && TouchOnStay != null) TouchOnStay();
+
+            if (isDown && isTouch)
+            {
+                if (MarkerClock.IF_Clock_System(TouchTime))
+                {
+                    isLongDown = true;
+                    if (TouchOnLongDown != null) TouchOnLongDown();
+                }
+
+                if (!isLongDown && TouchOnShortStay != null) TouchOnShortStay();
+                if (isLongDown && TouchOnLongStay != null) TouchOnLongStay();
+            }
+
+        }
+
+    }
+}
diff --git a/SDHK_Tool/Component/Touch/TouchEvent/SC_TouchEvent_Down.cs.meta b/SDHK_Tool/Component/Touch/TouchEvent/SC_TouchEvent_Down.cs.meta
new file mode 100644
index 0000000..88749bc
--- /dev/null
+++ b/SDHK_Tool/Component/Touch/TouchEvent/SC_TouchEvent_Down.cs.meta
@@ -0,0 +1,13 @@
+fileFormatVersion: 2
+guid: 2b0b2b74b18b4cc4f8f2c742f64ceae7
+timeCreated: 1562846240
+licenseType: Free
+MonoImporter:
+  externalObjects: {}
+  serializedVersion: 2
+  defaultReferences: []
+  executionOrder: 0
+  icon: {instanceID: 0}
+  userData: 
+  assetBundleName: 
+  assetBundleVariant: 
diff --git a/SDHK_Tool/Component/Touch/TouchEvent/SC_TouchEvent_Drag.cs b/SDHK_Tool/Component/Touch/TouchEvent/SC_TouchEvent_Drag.cs
new file mode 100644
index 0000000..b833de7
--- /dev/null
+++ b/SDHK_Tool/Component/Touch/TouchEvent/SC_TouchEvent_Drag.cs
@@ -0,0 +1,125 @@
+﻿using System;
+using System.Collections.Generic;
+using UnityEngine;
+using UnityEngine.EventSystems;
+
+
+/*
+ * 作者：闪电Y黑客
+ * 
+ * 日期： 2019.7.16
+ *
+ * 2019.10.09 触摸池合并
+ * 
+ * 功能：拖拽事件监听
+ *
+ */
+
+namespace SDHK_Tool.Component
+{
+    /// <summary>
+    /// 触摸事件监听器：【拖拽事件】
+    /// </summary>
+    public class SC_TouchEvent_Drag : SB_TouchEvent
+    , IBeginDragHandler
+    , IDragHandler
+    , IEndDragHandler
+    , IDropHandler
+    , IScrollHandler
+    {
+        [Space()]
+
+        /// <summary>
+        /// 触摸事件：拖拽第一帧
+        /// </summary>
+        public Action TouchOnStartDrag;
+
+        /// <summary>
+        /// 触摸事件：拖拽中
+        /// </summary>
+        public Action TouchOnDrag;
+
+        /// <summary>
+        /// 触摸事件：拖拽结束
+        /// </summary>
+        public Action TouchOnEndDrag;
+
+        /// <summary>
+        /// 触摸事件：在原对象上拖拽结束
+        /// </summary>
+        public Action TouchOnEndDrop;
+
+        public Action<float> TouchOnScroll; //鼠标滚轮
+
+
+        private void Start()
+        {
+
+        }
+
+
+        /// <summary>
+        /// 添加触摸点
+        /// </summary>
+        /// <param name="eventData">触摸点</param>
+        public void AddTouchData(PointerEventData eventData)
+        {
+
+            TouchIds.Add(eventData.pointerId);
+            TouchPool.Add(eventData.pointerId, eventData);
+        }
+
+        /// <summary>
+        /// 删除触摸点
+        /// </summary>
+        /// <param name="eventData">触摸点</param>
+        public void RemoveTouchData(PointerEventData eventData)
+        {
+            TouchIds.Remove(eventData.pointerId);
+            TouchPool.Remove(eventData.pointerId);
+        }
+
+
+        public void OnBeginDrag(PointerEventData eventData)
+        {
+            if (TouchPool.ContainsKey(eventData.pointerId)) return;
+            if (IgnoreMouse && eventData.pointerId < 0) return;
+
+            //拖拽池添加
+            AddTouchData(eventData);
+
+            if (TouchOnStartDrag != null) TouchOnStartDrag();
+        }
+
+        public void OnDrag(PointerEventData eventData)
+        {
+            if (IgnoreMouse && eventData.pointerId < 0) return;
+            if (TouchOnDrag != null) TouchOnDrag();
+        }
+
+        public void OnEndDrag(PointerEventData eventData)
+        {
+            if (!TouchPool.ContainsKey(eventData.pointerId)) return;
+            if (IgnoreMouse && eventData.pointerId < 0) return;
+
+            if (TouchOnEndDrag != null) TouchOnEndDrag();
+
+            //拖拽池删除
+            RemoveTouchData(eventData);
+        }
+
+        public void OnDrop(PointerEventData eventData)
+        {
+            if (IgnoreMouse && eventData.pointerId < 0) return;
+            if (TouchOnEndDrop != null) TouchOnEndDrop();
+        }
+
+        public void OnScroll(PointerEventData eventData)
+        {
+            if (IgnoreMouse && eventData.pointerId < 0) return;
+            if (TouchOnScroll != null) TouchOnScroll(eventData.scrollDelta.y);
+        }
+
+
+    }
+}
\ No newline at end of file
diff --git a/SDHK_Tool/Component/Touch/TouchEvent/SC_TouchEvent_Drag.cs.meta b/SDHK_Tool/Component/Touch/TouchEvent/SC_TouchEvent_Drag.cs.meta
new file mode 100644
index 0000000..9b0e02e
--- /dev/null
+++ b/SDHK_Tool/Component/Touch/TouchEvent/SC_TouchEvent_Drag.cs.meta
@@ -0,0 +1,13 @@
+fileFormatVersion: 2
+guid: f541595ad0c052543bb9dcbd0790748b
+timeCreated: 1562846267
+licenseType: Free
+MonoImporter:
+  externalObjects: {}
+  serializedVersion: 2
+  defaultReferences: []
+  executionOrder: 0
+  icon: {instanceID: 0}
+  userData: 
+  assetBundleName: 
+  assetBundleVariant: 
diff --git a/SDHK_Tool/Component/Touch/TouchEvent/SC_TouchEvent_Enter.cs b/SDHK_Tool/Component/Touch/TouchEvent/SC_TouchEvent_Enter.cs
new file mode 100644
index 0000000..5f40da0
--- /dev/null
+++ b/SDHK_Tool/Component/Touch/TouchEvent/SC_TouchEvent_Enter.cs
@@ -0,0 +1,172 @@
+﻿using System;
+using System.Collections.Generic;
+using SDHK_Tool.Dynamic;
+using UnityEngine;
+using UnityEngine.EventSystems;
+
+
+/*
+ * 作者：闪电Y黑客
+ * 
+ * 日期： 2019.7.16
+ *
+ * 2019.10.09 触摸池合并
+ * 
+ * 功能：经过事件监听
+ *
+ */
+
+namespace SDHK_Tool.Component
+{
+    /// <summary>
+    /// 触摸事件监听器：【经过事件】
+    /// </summary>
+    public class SC_TouchEvent_Enter : SB_TouchEvent
+    , IPointerEnterHandler
+    , IPointerExitHandler
+    {
+
+        [Space()]
+
+        [Tooltip("触摸时间")]
+        public float TouchTime = 0.5f;  //触摸时间
+
+        /// <summary>
+        /// 触摸事件：进入停留
+        /// </summary>
+        public Action TouchOnEnter;         //进入
+
+        /// <summary>
+        /// 触摸事件：进入长停留
+        /// </summary>
+        public Action TouchOnLongEnter;     //进入停留
+
+        /// <summary>
+        /// 触摸事件：进入停留【Update】
+        /// </summary>
+        public Action TouchOnInside;        //停留【Update】
+
+        /// <summary>
+        /// 触摸事件：进入短停留【Update】
+        /// </summary>
+        public Action TouchOnShortInside;   //短停留【Update】
+
+        /// <summary>
+        /// 触摸事件：进入长停留【Update】
+        /// </summary>
+        public Action TouchOnLongInside;    //长停留【Update】
+
+        /// <summary>
+        /// 触摸事件：离开
+        /// </summary>
+        public Action TouchOnExit;        //离开
+
+        /// <summary>
+        /// 触摸事件：短停留后离开
+        /// </summary>
+        public Action TouchOnShortExit;   //短停留后离开
+
+        /// <summary>
+        /// 触摸事件：长停留后离开
+        /// </summary>
+        public Action TouchOnLongExit;    //长停留后离开
+
+        private int touchCount = 0;      //触摸数量
+        public int TouchCount { get { return touchCount; } }
+
+        private SD_MarkerClock MarkerClock;
+
+        private bool isEnter = false;     //已进入
+
+        private bool isLongEnter = false; //长停留触发
+
+
+        void Awake()
+        {
+            MarkerClock = new SD_MarkerClock();
+            MarkerClock.Reset_Marker();//SDHK临时修改:计时器的理念设定不完善
+        }
+
+        /// <summary>
+        /// 添加触摸点
+        /// </summary>
+        /// <param name="eventData">触摸点</param>
+        public void AddTouchData(PointerEventData eventData)
+        {
+            TouchIds.Add(eventData.pointerId);
+            TouchPool.Add(eventData.pointerId, eventData);
+        }
+
+        /// <summary>
+        /// 删除触摸点
+        /// </summary>
+        /// <param name="eventData">触摸点</param>
+        public void RemoveTouchData(PointerEventData eventData)
+        {
+            TouchIds.Remove(eventData.pointerId);
+            TouchPool.Remove(eventData.pointerId);
+        }
+
+
+
+        public void OnPointerEnter(PointerEventData eventData)
+        {
+            if (TouchPool.ContainsKey(eventData.pointerId)) return;
+            if (IgnoreMouse && eventData.pointerId < 0) return;
+            touchCount++;
+            if (touchCount == 1)
+            {
+                isEnter = true;
+                MarkerClock.Reset_Marker();
+            }
+
+            //停留池添加
+            AddTouchData(eventData);
+
+            if (TouchOnEnter != null) TouchOnEnter();
+        }
+
+        public void OnPointerExit(PointerEventData eventData)
+        {
+            if (!TouchPool.ContainsKey(eventData.pointerId)) return;
+            if (IgnoreMouse && eventData.pointerId < 0) return;
+            touchCount--;
+
+            if (TouchOnExit != null) TouchOnExit();
+
+            if (touchCount == 0)
+            {
+                if (!isLongEnter && TouchOnShortExit != null) TouchOnShortExit();
+                if (isLongEnter && TouchOnLongExit != null) TouchOnLongExit();
+            }
+
+            //停留池删除
+            RemoveTouchData(eventData);
+
+            if (touchCount == 0)
+            {
+                isEnter = false;
+                isLongEnter = false;
+            }
+        }
+
+        void Update()
+        {
+
+            if (isEnter)
+            {
+                if (TouchOnInside != null) TouchOnInside();
+
+                if (MarkerClock.IF_Clock_Game(TouchTime))
+                {
+                    isLongEnter = true;
+                    if (TouchOnLongEnter != null) TouchOnLongEnter();
+                }
+
+                if (!isLongEnter && TouchOnShortInside != null) TouchOnShortInside();
+                if (isLongEnter && TouchOnLongInside != null) TouchOnLongInside();
+            }
+        }
+    }
+
+}
\ No newline at end of file
diff --git a/SDHK_Tool/Component/Touch/TouchEvent/SC_TouchEvent_Enter.cs.meta b/SDHK_Tool/Component/Touch/TouchEvent/SC_TouchEvent_Enter.cs.meta
new file mode 100644
index 0000000..db341c9
--- /dev/null
+++ b/SDHK_Tool/Component/Touch/TouchEvent/SC_TouchEvent_Enter.cs.meta
@@ -0,0 +1,13 @@
+fileFormatVersion: 2
+guid: 736eec066d2a4a947a6be280a03e6158
+timeCreated: 1562846303
+licenseType: Free
+MonoImporter:
+  externalObjects: {}
+  serializedVersion: 2
+  defaultReferences: []
+  executionOrder: 0
+  icon: {instanceID: 0}
+  userData: 
+  assetBundleName: 
+  assetBundleVariant: 
diff --git a/SDHK_Tool/Component/Touch/TouchTransfer/SC_TouchEvent_SendParent.cs b/SDHK_Tool/Component/Touch/TouchTransfer/SC_TouchEvent_SendParent.cs
new file mode 100644
index 0000000..efb20e8
--- /dev/null
+++ b/SDHK_Tool/Component/Touch/TouchTransfer/SC_TouchEvent_SendParent.cs
@@ -0,0 +1,95 @@
+﻿using UnityEngine;
+using UnityEngine.EventSystems;
+using SDHK_Tool.Static;
+
+/*
+ * 作者：闪电Y黑客
+ * 
+ * 日期： 2019.10.16
+ * 
+ * 功能：事件发送到父物体
+ *
+ */
+
+namespace SDHK_Tool.Component
+{
+    /// <summary>
+    /// 触摸事件渗透器：将触摸事件传给父物体
+    /// </summary>
+    public class SC_TouchEvent_SendParent : MonoBehaviour
+    , IPointerDownHandler
+    , IPointerUpHandler
+    , IPointerClickHandler
+    , IBeginDragHandler
+    , IEndDragHandler
+    , IDragHandler
+    , IDropHandler
+    , IScrollHandler
+    , IPointerEnterHandler
+    , IPointerExitHandler
+    {
+        /// <summary>
+        /// 事件传递给父物体
+        /// </summary>
+        [Tooltip("事件传给最近组件的父物体")]
+        public bool SendNearlyParent = false;
+
+        public void OnBeginDrag(PointerEventData eventData)
+        {
+            SendParent(SendNearlyParent, gameObject, eventData, ExecuteEvents.beginDragHandler);
+        }
+        public void OnDrag(PointerEventData eventData)
+        {
+            SendParent(SendNearlyParent, gameObject, eventData, ExecuteEvents.dragHandler);
+        }
+        public void OnDrop(PointerEventData eventData)
+        {
+            SendParent(SendNearlyParent, gameObject, eventData, ExecuteEvents.dropHandler);
+        }
+        public void OnEndDrag(PointerEventData eventData)
+        {
+            SendParent(SendNearlyParent, gameObject, eventData, ExecuteEvents.endDragHandler);
+        }
+        public void OnPointerDown(PointerEventData eventData)
+        {
+            SendParent(SendNearlyParent, gameObject, eventData, ExecuteEvents.pointerDownHandler);
+        }
+        public void OnPointerClick(PointerEventData eventData)
+        {
+            SendParent(SendNearlyParent, gameObject, eventData, ExecuteEvents.pointerClickHandler);
+        }
+        public void OnPointerUp(PointerEventData eventData)
+        {
+            SendParent(SendNearlyParent, gameObject, eventData, ExecuteEvents.pointerUpHandler);
+        }
+        public void OnPointerEnter(PointerEventData eventData)
+        {
+            SendParent(SendNearlyParent, gameObject, eventData, ExecuteEvents.pointerEnterHandler);
+        }
+        public void OnPointerExit(PointerEventData eventData)
+        {
+            SendParent(SendNearlyParent, gameObject, eventData, ExecuteEvents.pointerExitHandler);
+        }
+        public void OnScroll(PointerEventData eventData)
+        {
+            SendParent(SendNearlyParent, gameObject, eventData, ExecuteEvents.scrollHandler);
+        }
+
+        /// <summary>
+        /// 消息发送给父物体
+        /// </summary>
+        /// <param name="NearlyParent">是否为最近组件父物体</param>
+        /// <param name="ThisGameObject">当前游戏物体</param>
+        /// <param name="eventData">触摸点信息</param>
+        /// <param name="function">触摸事件类型</param>
+        /// <typeparam name="T">查找的组件</typeparam>
+        public void SendParent<T>(bool NearlyParent, GameObject ThisGameObject, PointerEventData eventData, ExecuteEvents.EventFunction<T> function)
+         where T : IEventSystemHandler//泛型约束
+        {
+            GameObject NewGameObject = (NearlyParent) ? SS_GameObject.GetParent_In_Component<T>(ThisGameObject) : ThisGameObject.transform.parent.gameObject;
+            if (NewGameObject != null) ExecuteEvents.Execute(NewGameObject, eventData, function);//触摸事件传递
+
+        }
+
+    }
+}
\ No newline at end of file
diff --git a/SDHK_Tool/Component/Touch/TouchTransfer/SC_TouchEvent_SendParent.cs.meta b/SDHK_Tool/Component/Touch/TouchTransfer/SC_TouchEvent_SendParent.cs.meta
new file mode 100644
index 0000000..4c61178
--- /dev/null
+++ b/SDHK_Tool/Component/Touch/TouchTransfer/SC_TouchEvent_SendParent.cs.meta
@@ -0,0 +1,13 @@
+fileFormatVersion: 2
+guid: 988ae857571d2f344bb2361e158851a4
+timeCreated: 1571195814
+licenseType: Pro
+MonoImporter:
+  externalObjects: {}
+  serializedVersion: 2
+  defaultReferences: []
+  executionOrder: 0
+  icon: {instanceID: 0}
+  userData: 
+  assetBundleName: 
+  assetBundleVariant: 
diff --git a/SDHK_Tool/Component/Touch/TouchTransfer/SC_TouchEvent_Transfer.cs b/SDHK_Tool/Component/Touch/TouchTransfer/SC_TouchEvent_Transfer.cs
new file mode 100644
index 0000000..8a0fd06
--- /dev/null
+++ b/SDHK_Tool/Component/Touch/TouchTransfer/SC_TouchEvent_Transfer.cs
@@ -0,0 +1,102 @@
+﻿using System.Collections;
+using System.Collections.Generic;
+using UnityEngine;
+using UnityEngine.EventSystems;
+using SDHK_Tool.Static;
+
+/*
+ * 作者：闪电Y黑客
+ * 
+ * 日期： 2019.10.16
+ * 
+ * 功能：把自身点击事件传给另一个物体
+ *
+ */
+
+
+namespace SDHK_Tool.Component
+{
+    /// <summary>
+    /// 触摸事件转接器：将触摸事件传给另一个物体
+    /// </summary>
+    public class SC_TouchEvent_Transfer : MonoBehaviour
+    , IPointerDownHandler
+    , IPointerUpHandler
+    {
+        /// <summary>
+        /// 穿透触摸事件转移延迟时间：实例化的物体需要时间生成0.02应该为最小值了
+        /// </summary>
+        [Tooltip("穿透触摸的转移延迟时间：实例化的物体需要时间生成")]
+        public float TransferTime = 0.02f;  //触摸时间
+
+        /// <summary>
+        /// 点击触摸id顺序链表[顺序列表]，通过列表id顺序去字典提取触摸
+        /// </summary>
+        [Tooltip("触摸点Id顺序表")]
+        public List<int> TouchDownIds = new List<int>();
+        /// <summary>
+        /// 点击触摸字典[无序]
+        /// </summary>
+        public Dictionary<int, PointerEventData> TouchDownPool = new Dictionary<int, PointerEventData>();
+        private GameObject TargetGameObject;//目标游戏物
+
+        /// <summary>
+        /// 点击触摸事件转移：触摸事件将由自身转移到目标物体上
+        /// </summary>
+        /// <param name="targetGameObject">目标物体</param>
+        public void Touch_Transfer(GameObject targetGameObject)
+        {
+            TargetGameObject = targetGameObject;
+
+            if (SC_TouchEvent_RayCast.instance == null)
+            {
+                Transfer();//普通触摸事件转移为直接转移触摸事件
+            }
+            else
+            {
+                Invoke("RayTransfer", TransferTime);//穿透触摸的触摸事件转移，原理为抬起后按下。
+            }
+        }
+
+        private void RayTransfer()//穿透转移：有穿透器的情况下用普通的触摸穿透器会拿不到这个物体
+        {
+            //触摸点刷新延迟时间：0.02是因为，实例化的物体需要时间生成
+
+            List<int> TouchDownIds = new List<int>(this.TouchDownIds);
+
+            Dictionary<int, PointerEventData> TouchDownPool = new Dictionary<int, PointerEventData>(this.TouchDownPool);
+
+            foreach (var TouchDownId in TouchDownIds)
+            {
+                SC_TouchEvent_RayCast.instance.TouchRefresh(TouchDownPool[TouchDownId]);
+            }
+        }
+
+        private void Transfer()//普通转移
+        {
+            List<int> TouchDownIds = new List<int>(this.TouchDownIds);
+
+            Dictionary<int, PointerEventData> TouchDownPool = new Dictionary<int, PointerEventData>(this.TouchDownPool);
+
+            foreach (var TouchDownId in TouchDownIds)
+            {
+                SS_Touch.Transfer_Down(gameObject, TargetGameObject, TouchDownPool[TouchDownId]);
+                TouchDownPool[TouchDownId].pointerDrag = TargetGameObject;
+            }
+        }
+
+        public void OnPointerDown(PointerEventData eventData)
+        {
+            if (TouchDownPool.ContainsKey(eventData.pointerId)) return;
+            TouchDownIds.Add(eventData.pointerId);
+            TouchDownPool.Add(eventData.pointerId, eventData);
+        }
+
+        public void OnPointerUp(PointerEventData eventData)
+        {
+            if (!TouchDownPool.ContainsKey(eventData.pointerId)) return;
+            TouchDownIds.Remove(eventData.pointerId);
+            TouchDownPool.Remove(eventData.pointerId);
+        }
+    }
+}
\ No newline at end of file
diff --git a/SDHK_Tool/Component/Touch/TouchTransfer/SC_TouchEvent_Transfer.cs.meta b/SDHK_Tool/Component/Touch/TouchTransfer/SC_TouchEvent_Transfer.cs.meta
new file mode 100644
index 0000000..6cf2c45
--- /dev/null
+++ b/SDHK_Tool/Component/Touch/TouchTransfer/SC_TouchEvent_Transfer.cs.meta
@@ -0,0 +1,13 @@
+fileFormatVersion: 2
+guid: a1102065800d3f641bc89d5cc87249b1
+timeCreated: 1571226561
+licenseType: Pro
+MonoImporter:
+  externalObjects: {}
+  serializedVersion: 2
+  defaultReferences: []
+  executionOrder: 0
+  icon: {instanceID: 0}
+  userData: 
+  assetBundleName: 
+  assetBundleVariant: 
diff --git a/SDHK_Tool/Component/UI.meta b/SDHK_Tool/Component/UI.meta
new file mode 100644
index 0000000..5ab8563
--- /dev/null
+++ b/SDHK_Tool/Component/UI.meta
@@ -0,0 +1,10 @@
+fileFormatVersion: 2
+guid: a3a180ad0ad3c834b9d0119e2b0aab9d
+folderAsset: yes
+timeCreated: 1585187510
+licenseType: Free
+DefaultImporter:
+  externalObjects: {}
+  userData: 
+  assetBundleName: 
+  assetBundleVariant: 
diff --git a/SDHK_Tool/Component/UI/Camera/SC_WebCamera.cs.meta b/SDHK_Tool/Component/UI/Camera/SC_WebCamera.cs.meta
new file mode 100644
index 0000000..491c23a
--- /dev/null
+++ b/SDHK_Tool/Component/UI/Camera/SC_WebCamera.cs.meta
@@ -0,0 +1,13 @@
+fileFormatVersion: 2
+guid: 1f3773777df3c2b46a2c763f87c0c63b
+timeCreated: 1567752780
+licenseType: Pro
+MonoImporter:
+  externalObjects: {}
+  serializedVersion: 2
+  defaultReferences: []
+  executionOrder: 0
+  icon: {instanceID: 0}
+  userData: 
+  assetBundleName: 
+  assetBundleVariant: 
diff --git a/SDHK_Tool/Component/UI/SC_DebugUILine.cs b/SDHK_Tool/Component/UI/SC_DebugUILine.cs
new file mode 100644
index 0000000..2d7d5c2
--- /dev/null
+++ b/SDHK_Tool/Component/UI/SC_DebugUILine.cs
@@ -0,0 +1,52 @@
+﻿
+
+using UnityEngine;
+using System.Collections;
+using UnityEngine.UI;
+
+
+/*
+ * 作者：闪电Y黑客
+ * 
+ * 日期： 2019.11.08
+ * 
+ * 功能：UI辅助线画线，可以查看UI的边框,挂在任意物体上即可生效
+ * 
+ *
+ */
+
+/// <summary>
+/// UI辅助线画线
+/// </summary>
+namespace SDHK_Tool.Component
+{
+#if UNITY_EDITOR
+    public class SC_DebugUILine : MonoBehaviour
+    {
+        /// <summary>
+        /// 画线颜色
+        /// </summary>
+        [SerializeField]
+        public Color color = Color.green;
+
+        static Vector3[] fourCorners = new Vector3[4];
+        void OnDrawGizmos()
+        {
+            foreach (MaskableGraphic g in GameObject.FindObjectsOfType<MaskableGraphic>())
+            {
+                if (g.raycastTarget)
+                {
+                    RectTransform rectTransform = g.transform as RectTransform;
+                    rectTransform.GetWorldCorners(fourCorners);
+                    Gizmos.color = color;
+                    for (int i = 0; i < 4; i++)
+                        Gizmos.DrawLine(fourCorners[i], fourCorners[(i + 1) % 4]);
+                }
+            }
+        }
+    }
+#endif
+}
+
+
+
diff --git a/SDHK_Tool/Component/UI/SC_DebugUILine.cs.meta b/SDHK_Tool/Component/UI/SC_DebugUILine.cs.meta
new file mode 100644
index 0000000..895cfe4
--- /dev/null
+++ b/SDHK_Tool/Component/UI/SC_DebugUILine.cs.meta
@@ -0,0 +1,13 @@
+fileFormatVersion: 2
+guid: 6240ed6141ded2a41886fc7db57212b9
+timeCreated: 1561370631
+licenseType: Free
+MonoImporter:
+  externalObjects: {}
+  serializedVersion: 2
+  defaultReferences: []
+  executionOrder: 0
+  icon: {instanceID: 0}
+  userData: 
+  assetBundleName: 
+  assetBundleVariant: 
diff --git a/SDHK_Tool/Component/UI/ScrollGroup/Base/SB_ScrollGroup_BoxProcessor.cs b/SDHK_Tool/Component/UI/ScrollGroup/Base/SB_ScrollGroup_BoxProcessor.cs
new file mode 100644
index 0000000..0af92c8
--- /dev/null
+++ b/SDHK_Tool/Component/UI/ScrollGroup/Base/SB_ScrollGroup_BoxProcessor.cs
@@ -0,0 +1,57 @@
+﻿using System.Collections;
+using System.Collections.Generic;
+using UnityEngine;
+
+
+/*
+ * 作者：闪电Y黑客
+ * 
+ * 日期： 2019.11.04
+ * 
+ * 功能：滚动列表对象处理器的抽象基类：共同属性：内容物体的添加删除等共同方法
+ *
+ */
+
+
+/// <summary>
+/// 滚动列表处理器的抽象基类：共同属性：内容物体的添加删除
+/// </summary>
+public abstract class SB_ScrollGroup_BoxProcessor : MonoBehaviour
+{
+    /// <summary>
+    /// 处理器刷新
+    /// </summary>
+    public abstract void RefreshGroup();
+
+    /// <summary>
+    /// 新建对象
+    /// </summary>
+    /// <param name="GroupBox">对象</param>
+    /// <param name="Index">数据编号</param>
+    public abstract void GroupBox_New(GameObject GroupBox, int Index);
+
+    /// <summary>
+    /// 删除对象
+    /// </summary>
+    /// <param name="GroupBox">对象</param>
+    /// <param name="Index">数据编号</param>
+    public abstract void GroupBox_Del(GameObject GroupBox, int Index);
+
+
+    /// <summary>
+    /// 工作对象
+    /// </summary>
+    /// <param name="GroupBox">对象</param>
+    /// <param name="Index">数据编号</param>
+    public abstract void GroupBox_Work(GameObject GroupBox, int Index);
+
+    /// <summary>
+    /// 闲置对象
+    /// </summary>
+    /// <param name="GroupBox">对象</param>
+    /// <param name="Index">数据编号</param>
+    public abstract void GroupBox_Idle(GameObject GroupBox, int Index);
+
+
+
+}
diff --git a/SDHK_Tool/Component/UI/ScrollGroup/Base/SB_ScrollGroup_BoxProcessor.cs.meta b/SDHK_Tool/Component/UI/ScrollGroup/Base/SB_ScrollGroup_BoxProcessor.cs.meta
new file mode 100644
index 0000000..ca490db
--- /dev/null
+++ b/SDHK_Tool/Component/UI/ScrollGroup/Base/SB_ScrollGroup_BoxProcessor.cs.meta
@@ -0,0 +1,13 @@
+fileFormatVersion: 2
+guid: e45dc70f9fb8a3e4c9c71d5247995214
+timeCreated: 1572849419
+licenseType: Pro
+MonoImporter:
+  externalObjects: {}
+  serializedVersion: 2
+  defaultReferences: []
+  executionOrder: 0
+  icon: {instanceID: 0}
+  userData: 
+  assetBundleName: 
+  assetBundleVariant: 
diff --git a/SDHK_Tool/Component/UI/ScrollGroup/BoxNum.cs b/SDHK_Tool/Component/UI/ScrollGroup/BoxNum.cs
new file mode 100644
index 0000000..44c0ad3
--- /dev/null
+++ b/SDHK_Tool/Component/UI/ScrollGroup/BoxNum.cs
@@ -0,0 +1,9 @@
+﻿using System.Collections;
+using System.Collections.Generic;
+using UnityEngine;
+
+public class BoxNum : MonoBehaviour
+{
+    public List<int> Num;
+
+}
diff --git a/SDHK_Tool/Component/UI/ScrollGroup/BoxNum.cs.meta b/SDHK_Tool/Component/UI/ScrollGroup/BoxNum.cs.meta
new file mode 100644
index 0000000..bf0e2b0
--- /dev/null
+++ b/SDHK_Tool/Component/UI/ScrollGroup/BoxNum.cs.meta
@@ -0,0 +1,13 @@
+fileFormatVersion: 2
+guid: 7978ec730008edb4c873dcb2ae6affc0
+timeCreated: 1562148201
+licenseType: Free
+MonoImporter:
+  externalObjects: {}
+  serializedVersion: 2
+  defaultReferences: []
+  executionOrder: 0
+  icon: {instanceID: 0}
+  userData: 
+  assetBundleName: 
+  assetBundleVariant: 
diff --git a/SDHK_Tool/Component/UI/ScrollGroup/SC_ScrollGroup.cs b/SDHK_Tool/Component/UI/ScrollGroup/SC_ScrollGroup.cs
new file mode 100644
index 0000000..7589da7
--- /dev/null
+++ b/SDHK_Tool/Component/UI/ScrollGroup/SC_ScrollGroup.cs
@@ -0,0 +1,387 @@
+using System;
+using System.Collections;
+using System.Collections.Generic;
+using System.Linq;
+using SDHK_Tool.Dynamic;
+using SDHK_Tool.Static;
+// using SDHK_Tool.Extension;
+using UnityEngine;
+
+/*
+ * 作者：闪电Y黑客
+ * 
+ * 日期： 2019.11.04
+ *
+ * 2019.11.27 改进为对象池列表
+ *
+ * 2020.03.12 修改 获取UI高宽方式 从 sizeDelta 改为 rect ，从此父物体mask层可任意设置锚点
+ * 
+ * 功能：
+ * 
+ * 动态列表，发放编号，并进行排列
+ * 更具父物体[mask] 高宽来计算内容盒子高宽
+ * 更具自身位置来移动物体并修改编号
+ *
+ */
+
+namespace SDHK_Tool.Component
+{
+
+    /// <summary>
+    /// 动态列表:[整齐布局]
+    /// </summary>
+    public class SC_ScrollGroup : MonoBehaviour
+    {
+
+        #region 公开属性
+
+        /// <summary>
+        /// 预制体
+        /// </summary>
+        [Tooltip("要生成的预制体")]
+        public GameObject Box_Pfb;
+
+        [Space()]
+        [Space()]
+
+        /// <summary>
+        /// 内容数量
+        /// </summary>
+        [Tooltip("要生成的内容数")]
+        public int BoxCount = 10;
+
+        [Space()]
+        [Space()]
+
+
+        /// <summary>
+        /// 启动后运行
+        /// </summary>
+        [Tooltip("启动后运行")]
+        public bool PlayOnAwake = true;
+
+        /// <summary>
+        /// 列表循环
+        /// </summary>
+        [Tooltip("列表循环")]
+        public bool Loop = false;
+
+        [Space()]
+        [Space()]
+
+        /// <summary>
+        /// 动态列表内容处理器：必须有
+        /// </summary>
+        [Tooltip("动态列表内容处理器：必须有")]
+        public SB_ScrollGroup_BoxProcessor ScrollGroup_Base;
+
+        [Space()]
+        [Space()]
+
+        /// <summary>
+        /// 反向排列
+        /// </summary>
+        [Tooltip("反向排列")]
+        public bool isReverse = false;//反向排列
+
+        [Space()]
+        [Space()]
+
+
+        /// <summary>
+        /// 垂直排列
+        /// </summary>
+        [Tooltip("垂直排列")]
+        public bool isVertical = false;//垂直排列
+
+        [Space()]
+        [Space()]
+
+        /// <summary>
+        /// 预加载数:预先加载的 列/行 数量                      
+        /// 注：因为外框不为整数时，下标计算的位置判断会有误差（过了界限没生成物体，不影响生成顺序）     
+        /// 所以预加载2组（拉高生成界限，提前生成）避免出现画面空缺                          
+        /// </summary>
+        [Tooltip("预加载数: 预先加载的 列/行 数量")]
+        public int Preload = 2;
+
+        [Space()]
+        [Space()]
+
+        /// <summary>
+        /// 内容盒子间隔宽高度
+        /// </summary>
+        [Tooltip("内容盒子间隔宽高度")]
+        public Vector2 BoxInterval = new Vector2(10, 10);
+
+        /// <summary>
+        /// 列表侧面顶部间隔[设置为间隔的一般即可]
+        /// </summary>
+        [Tooltip("列表侧面顶部间隔[设置为间隔的一半即可]")]
+        public Vector2 GroupGap = new Vector2(5, 5);
+
+        [Space()]
+        [Space()]
+
+        /// <summary>
+        /// 列行数[x为列，y为行]
+        /// </summary>
+        [Tooltip("列行数[必须整数]（显示数量）")]
+        public Vector2 GroupList = new Vector2(1, 1);
+
+        [Space()]
+        [Space()]
+
+        /// <summary>
+        /// 脚本计算出来的内容盒子高宽_画布坐标
+        /// </summary>
+        [Tooltip("脚本计算出来的内容盒子高宽_画布坐标")]
+        public Vector2 BoxSize;
+
+        /// <summary>
+        /// 脚本计算出来的格子高宽_画布坐标
+        /// </summary>
+        [Tooltip("脚本计算出来的格子高宽_画布坐标")]
+        public Vector2 GroupBox;
+
+        /// <summary>
+        /// 对象池句柄
+        /// </summary>
+        /// <typeparam name="int">编号</typeparam>
+        /// <typeparam name="GameObject">储存物体</typeparam>
+        public Dictionary<int, GameObject> IdPool = new Dictionary<int, GameObject>();
+
+        /// <summary>
+        /// 对象池
+        /// </summary>
+        public SD_ObjectPool<GameObject> objectPool;
+
+
+        #endregion
+
+        #region 私有属性
+
+        private List<int> BoxsId = new List<int>(); //当前存在的ID
+        private List<int> NewBoxsId = new List<int>();//新生成的ID
+
+        private List<int> EnterIds; //添加ID集合
+        private List<int> ExitIds;  //删除ID集合
+
+        private int PointerId = 0;//指针当前指向的Id
+
+        private int LatePointerId = 0;//指针上一次Id
+
+        private int Num;//数据Id
+
+        public RectTransform rectTransform; //当前物体
+
+        private RectTransform ParentTransform;//父物体
+
+        private float GroupPosition;//列表位置
+
+        private Vector2 groupList; //行列转换器
+
+        private Vector2 BoxSize_Half; //盒子一半大小：用于盒子放置的位置计算
+        private Vector2 GroupBox_multiple; //格子两倍大小：用于列表预加载的位置偏移
+
+        private bool isPlay = false;
+
+        #endregion
+
+        private void Start()
+        {
+            //===[初始化动态列表]=====
+
+            objectPool = new SD_ObjectPool<GameObject>(() => Instantiate(Box_Pfb), (Box) => Destroy(Box));//对象池创建
+
+            ParentTransform = (RectTransform)transform.parent;//获取父物体[mask]面板
+            rectTransform = (RectTransform)transform;//获取本物体面板
+
+            rectTransform.sizeDelta = Vector2.zero;//宽高为0
+
+            //初始化
+            if (PlayOnAwake) Refresh();
+
+            rectTransform.anchoredPosition3D = Vector3.zero;//动态列表面板归零（需要移动这个）
+
+        }
+
+        private void GroupRefresh()//列表计算刷新
+        {
+            if (GroupList.x < 1) GroupList.x = 1;//列表行列数不能为0
+            if (GroupList.y < 1) GroupList.y = 1;//列表行列数不能为0
+
+            BoxSize.x = ParentTransform.rect.width / (int)GroupList.x - BoxInterval.x;//计算内容盒子高宽
+            BoxSize.y = ParentTransform.rect.height / (int)GroupList.y - BoxInterval.y;
+
+            GroupBox.x = (BoxSize.x + BoxInterval.x);//计算格子宽高
+            GroupBox.y = (Mathf.Abs(-BoxSize.y - BoxInterval.y));
+
+            BoxSize_Half = BoxSize * 0.5f;
+            GroupBox_multiple = GroupBox * Preload;
+        }
+
+        /// <summary>
+        /// 列表刷新
+        /// </summary>
+        [ContextMenu("列表刷新")]
+        public void Refresh()
+        {
+
+            Vector2 anchor = (isReverse) ? new Vector2(1, 0) : new Vector2(0, 1);
+
+            rectTransform.pivot = anchor;//设置中心点为左上
+            rectTransform.anchorMin = anchor;//设置锚点为左上角
+            rectTransform.anchorMax = anchor;
+
+
+
+            if (objectPool == null) return;
+
+
+            Exit(new List<int>(BoxsId));
+
+            BoxsId.Clear();
+
+            objectPool.Clear_ObjectPool(); IdPool.Clear();//对象池清空
+
+            if (ScrollGroup_Base != null)//对象池委托绑定
+            {
+                objectPool.Object_New = (obj) =>
+                {
+                    obj.transform.SetParent(transform);
+                    obj.transform.localScale = Vector3.one;
+                    obj.transform.SE_LocalPosition_Z(0);
+
+                    ScrollGroup_Base.GroupBox_New(obj, Num);
+
+                    obj.transform.SetParent(this.transform);
+                };
+
+                objectPool.Object_Del = (obj) => ScrollGroup_Base.GroupBox_Del(obj, Num);
+
+                objectPool.Object_Work = (obj) =>
+                {
+                    ScrollGroup_Base.GroupBox_Work(obj, Num);//数据加载
+                };
+
+                objectPool.Object_Idle = (obj) => ScrollGroup_Base.GroupBox_Idle(obj, Num);
+
+                ScrollGroup_Base.RefreshGroup();
+            }
+
+            isPlay = true;
+
+            GroupRefresh();
+            Generate_List();
+
+        }
+
+        void Update()
+        {
+            if (isPlay)
+            {
+
+                if (isVertical)
+                {
+                    GroupPosition = rectTransform.anchoredPosition3D.y;//获取当前物体位置
+                    PointerId = SS_Mathf.Recent_Number(GroupPosition - GroupBox_multiple.y - ((isReverse) ? ParentTransform.rect.height : 0), GroupBox.y);//获取当前列表指针 （方法无法确定整数）
+                    groupList.x = GroupList.y;//生成的列表长宽
+                    groupList.y = GroupList.x;
+                }
+                else
+                {
+                    GroupPosition = -rectTransform.anchoredPosition3D.x;//获取当前物体位置
+                    PointerId = SS_Mathf.Recent_Number(GroupPosition - GroupBox_multiple.x - ((isReverse) ? ParentTransform.rect.width : 0), GroupBox.x);//获取当前列表指针（方法无法确定整数）
+                    groupList = GroupList;//生成的列表长宽
+                }
+
+                if (PointerId != LatePointerId) Generate_List();//指针变动时刷新
+                LatePointerId = PointerId;//ID指针刷新
+
+            }
+
+        }
+
+        private void Generate_List()//列表生成
+        {
+            NewBoxsId.Clear();//清空ID集合  
+            // Debug.Log(PointerId);
+            for (int x = 0; x < groupList.x + Preload * 2; x++)
+                for (int y = 0; y < groupList.y; y++)//添加要生成的ID集合  （方法无法确定整数）
+                {
+                    NewBoxsId.Add(((x + PointerId) * (int)groupList.y + y));
+                }
+
+            ExitIds = BoxsId.Except(NewBoxsId).ToList(); //当前集合 剔除 新集合 得到删除列表
+            EnterIds = NewBoxsId.Except(BoxsId).ToList(); //新集合 剔除 当前集合 得到生成列表
+
+            Exit(ExitIds);//删除物体
+            Enter(EnterIds);//生成物体
+
+        }
+
+
+        private void Enter(List<int> Ids)//生成物体
+        {
+            for (int i = 0; i < Ids.Count; i++)
+            {
+                if (BoxCount < 1) return; //数量不能为0
+
+
+                Num =
+                (Loop) ?
+                    SS_Mathf.Loop_Int((isReverse) ? -Ids[i] - 1 : Ids[i], BoxCount)
+                :
+                    (isReverse) ? -Ids[i] - 1 : Ids[i]
+                ; //换算成整数循环
+
+                if (!(Loop || SS_Mathf.If_IntervalValue(Num, 0, BoxCount - 1))) continue;//跳过这次循环
+
+                GameObject BoxObject = objectPool.Get_Object();
+                //  Debug.Log("工作对象池：" + objectPool.ObjectPool_Work.Count + " 闲置对象池：" + objectPool.ObjectPool_Idle.Count);
+
+
+                IdPool.Add(Ids[i], BoxObject);
+
+                if (BoxObject != null)
+                {
+                    Vector2 List2D = SS_Mathf.List1D_To_List2D(Ids[i], (int)groupList.y);//下标换算
+
+                    //蛇形排列计算
+                    if (List2D.x % 2 == ((isReverse) ? 0 : 1)) List2D.y = (int)groupList.y - 1 - List2D.y;
+
+                    Vector2 BoxPosition;//根据二维下标计算位置
+                    BoxPosition.x = ((isVertical) ? List2D.y : List2D.x) * GroupBox.x + GroupGap.x + BoxSize_Half.x + ((isVertical && isReverse) ? -ParentTransform.rect.width : 0);
+
+                    BoxPosition.y = ((isVertical) ? List2D.x : List2D.y) * -GroupBox.y - GroupGap.y - BoxSize_Half.y + ((!isVertical && isReverse) ? +ParentTransform.rect.height : 0);
+
+                    ((RectTransform)BoxObject.transform).SetSizeWithCurrentAnchors(RectTransform.Axis.Horizontal, BoxSize.x);//设置内容盒子高宽
+                    ((RectTransform)BoxObject.transform).SetSizeWithCurrentAnchors(RectTransform.Axis.Vertical, BoxSize.y);
+                    ((RectTransform)BoxObject.transform).pivot = new Vector2(0.5f, 0.5f);//设置中心点为中心
+                    ((RectTransform)BoxObject.transform).anchoredPosition = BoxPosition;//位置放置
+
+                    BoxsId.Add(Ids[i]);//Id存入列表
+
+                }
+            }
+        }
+
+        private void Exit(List<int> Ids)//删除物体
+        {
+            for (int i = 0; i < Ids.Count; i++)
+            {
+                objectPool.Set_Object(IdPool[Ids[i]]);
+                IdPool.Remove(Ids[i]);
+
+                BoxsId.Remove(Ids[i]);//Id列表删除
+            }
+            Resources.UnloadUnusedAssets();//释放无用对象
+            // System.GC.Collect();
+
+        }
+
+
+
+    }
+}
\ No newline at end of file
diff --git a/SDHK_Tool/Component/UI/ScrollGroup/SC_ScrollGroup.cs.meta b/SDHK_Tool/Component/UI/ScrollGroup/SC_ScrollGroup.cs.meta
new file mode 100644
index 0000000..07f0e0b
--- /dev/null
+++ b/SDHK_Tool/Component/UI/ScrollGroup/SC_ScrollGroup.cs.meta
@@ -0,0 +1,13 @@
+fileFormatVersion: 2
+guid: fa872340034be384984576f8bc6cb633
+timeCreated: 1562147998
+licenseType: Free
+MonoImporter:
+  externalObjects: {}
+  serializedVersion: 2
+  defaultReferences: []
+  executionOrder: 0
+  icon: {instanceID: 0}
+  userData: 
+  assetBundleName: 
+  assetBundleVariant: 
diff --git a/SDHK_Tool/Component/UI/ScrollGroup/SC_ScrollGroup_BoxProcessor.cs b/SDHK_Tool/Component/UI/ScrollGroup/SC_ScrollGroup_BoxProcessor.cs
new file mode 100644
index 0000000..0fd68b3
--- /dev/null
+++ b/SDHK_Tool/Component/UI/ScrollGroup/SC_ScrollGroup_BoxProcessor.cs
@@ -0,0 +1,62 @@
+﻿using System;
+using System.Collections;
+using System.Collections.Generic;
+using SDHK_Tool.Static;
+using UnityEngine;
+using UnityEngine.UI;
+using SDHK_Tool.Dynamic;
+
+
+/*
+ * 作者：闪电Y黑客
+ * 
+ * 日期： 2019.11.04
+ * 
+ * 功能：动态列表的内容物体处理器
+ * 继承 SB_ScrollGroup_BoxProcessor
+ * 可作为参考
+ *
+ */
+
+namespace SDHK_Tool.Component
+{
+
+    /// <summary>
+    /// 动态列表简易内容处理器
+    /// </summary>
+    public class SC_ScrollGroup_BoxProcessor : SB_ScrollGroup_BoxProcessor
+    {
+
+        public Dictionary<GameObject, BoxNum> ComponentPool = new Dictionary<GameObject, BoxNum>();
+
+
+        public override void RefreshGroup()
+        {
+            ComponentPool.Clear();
+        }
+
+        public override void GroupBox_New(GameObject GroupBox, int Index)
+        {
+            ComponentPool.Add(GroupBox, GroupBox.GetComponent<BoxNum>());
+        }
+
+        public override void GroupBox_Del(GameObject GroupBox, int Index)
+        {
+            ComponentPool.Remove(GroupBox);
+        }
+
+        public override void GroupBox_Work(GameObject GroupBox, int Index)
+        {
+            ComponentPool[GroupBox].Num[0] = Index;
+        }
+
+        public override void GroupBox_Idle(GameObject GroupBox, int Index)
+        {
+
+        }
+
+
+
+
+    }
+}
diff --git a/SDHK_Tool/Component/UI/ScrollGroup/SC_ScrollGroup_BoxProcessor.cs.meta b/SDHK_Tool/Component/UI/ScrollGroup/SC_ScrollGroup_BoxProcessor.cs.meta
new file mode 100644
index 0000000..d534870
--- /dev/null
+++ b/SDHK_Tool/Component/UI/ScrollGroup/SC_ScrollGroup_BoxProcessor.cs.meta
@@ -0,0 +1,13 @@
+fileFormatVersion: 2
+guid: 0f78da6d9ca65ae4ba3cda6945e541d3
+timeCreated: 1572851216
+licenseType: Pro
+MonoImporter:
+  externalObjects: {}
+  serializedVersion: 2
+  defaultReferences: []
+  executionOrder: 0
+  icon: {instanceID: 0}
+  userData: 
+  assetBundleName: 
+  assetBundleVariant: 
diff --git a/SDHK_Tool/Component/UI/ScrollGroup/SC_ScrollTouch_SpringBack.cs b/SDHK_Tool/Component/UI/ScrollGroup/SC_ScrollTouch_SpringBack.cs
new file mode 100644
index 0000000..b79b2f9
--- /dev/null
+++ b/SDHK_Tool/Component/UI/ScrollGroup/SC_ScrollTouch_SpringBack.cs
@@ -0,0 +1,103 @@
+﻿using System.Collections;
+using System.Collections.Generic;
+using SDHK_Tool.Component;
+using SDHK_Tool.Static;
+using UnityEngine;
+
+
+/*
+ * 作者：闪电Y黑客
+ * 
+ * 日期： 2019.11.20
+ * 
+ * 功能：滚动列表回弹器
+ * 
+ * 需要SC_TouchTransform计算器，并挂载SC_TouchMotor，其移动目标为SC_ScrollGroup物体
+ *
+ */
+
+
+
+namespace SDHK_Tool.Component
+{
+    /// <summary>
+    /// 滚动列表触摸回弹器
+    /// </summary>
+    public class SC_ScrollTouch_SpringBack : MonoBehaviour
+    {
+        /// <summary>
+        /// 触摸位置计算器
+        /// </summary>
+        [Tooltip("触摸位置计算器")]
+
+        public SC_TouchTransform touchTransform;
+
+        /// <summary>
+        /// 回弹灵敏度
+        /// </summary>
+        [Tooltip("回弹灵敏度")]
+        public float SpringSensitivity = 0.5f;
+
+
+        private SC_ScrollGroup scrollGroup; //滚动列表
+
+        private SC_TouchEvent_Down touchEvent_Down; //点击事件监听器
+
+        private bool isSpringBack = false;  //回弹标记
+
+        private Vector3 PositionLate;   //上一帧位置
+
+
+
+        // Use this for initialization
+        void Start()
+        {
+            if (touchTransform != null)
+            {
+                if (touchTransform.TouchObject.GetComponent<SC_ScrollGroup>() == null) return;
+
+                scrollGroup = touchTransform.TouchObject.GetComponent<SC_ScrollGroup>();
+
+                touchEvent_Down = (touchTransform.gameObject.GetComponent<SC_TouchEvent_Down>() != null)
+                ? touchTransform.gameObject.GetComponent<SC_TouchEvent_Down>()
+                : touchTransform.gameObject.AddComponent<SC_TouchEvent_Down>()
+                ;
+                touchEvent_Down.TouchOnUp += OnUp;
+
+                PositionLate = touchTransform.TouchObject.transform.localPosition;
+            }
+        }
+
+        public void OnUp()
+        {
+            if (touchTransform.TouchMotor != null && touchEvent_Down.TouchPool.Count <= 1)
+            {
+                isSpringBack = true;
+            }
+        }
+
+        public void Spring()
+        {
+            touchTransform.TouchMotor.Refresh();
+            touchTransform.Calculation_Position.x = SS_Mathf.Recent_Value(touchTransform.TouchObject.transform.localPosition.x, scrollGroup.GroupBox.x);
+            touchTransform.Calculation_Position.y = SS_Mathf.Recent_Value(touchTransform.TouchObject.transform.localPosition.y, scrollGroup.GroupBox.y);
+            isSpringBack = false;
+        }
+
+        // Update is called once per frame
+        void Update()
+        {
+            if (isSpringBack)
+            {
+                if ((touchTransform.TouchObject.transform.localPosition - PositionLate).magnitude < SpringSensitivity)//判断距离
+                {
+                    Spring();
+                }
+            }
+
+            PositionLate = touchTransform.TouchObject.transform.localPosition;
+        }
+
+    }
+
+}
\ No newline at end of file
diff --git a/SDHK_Tool/Component/UI/ScrollGroup/SC_ScrollTouch_SpringBack.cs.meta b/SDHK_Tool/Component/UI/ScrollGroup/SC_ScrollTouch_SpringBack.cs.meta
new file mode 100644
index 0000000..2268695
--- /dev/null
+++ b/SDHK_Tool/Component/UI/ScrollGroup/SC_ScrollTouch_SpringBack.cs.meta
@@ -0,0 +1,13 @@
+fileFormatVersion: 2
+guid: dc198a4eb0365104ba25a6aac0379ba0
+timeCreated: 1574219282
+licenseType: Pro
+MonoImporter:
+  externalObjects: {}
+  serializedVersion: 2
+  defaultReferences: []
+  executionOrder: 0
+  icon: {instanceID: 0}
+  userData: 
+  assetBundleName: 
+  assetBundleVariant: 
diff --git a/SDHK_Tool/Component/UI/SequenceFrame/SC_SequenceFrame_Sprite.cs b/SDHK_Tool/Component/UI/SequenceFrame/SC_SequenceFrame_Sprite.cs
new file mode 100644
index 0000000..6bf95ab
--- /dev/null
+++ b/SDHK_Tool/Component/UI/SequenceFrame/SC_SequenceFrame_Sprite.cs
@@ -0,0 +1,267 @@
+﻿using SDHK_Tool.Dynamic;
+using UnityEngine;
+using UnityEngine.UI;
+
+
+/*
+ * 作者：闪电Y黑客
+ * 
+ * 日期： 2019.9.29
+ * 
+ * 功能：序列帧播放工具【精灵图片】
+ *
+ */
+
+namespace SDHK_Tool.Component
+{
+
+    /// <summary>
+    /// 序列帧工具:[精灵]
+    /// </summary>
+    public class SC_SequenceFrame_Sprite : MonoBehaviour
+    {
+        [SerializeField]
+        public enum Mode
+        {
+            Image,
+            SpriteRenderer,
+            RawImage
+        }
+
+        private Image image;
+        private SpriteRenderer spriteRenderer;
+        private RawImage rawImage;
+
+        [Tooltip("播放组件")]
+        private Mode mode;
+
+        /// <summary>
+        /// 序列帧播放速度
+        /// </summary>
+        [Tooltip("播放速度")]
+        public float Speed = 1;
+
+        /// <summary>
+        /// 序列帧播放序号
+        /// </summary>
+        [Tooltip("播放序号")]
+        public int index = 0;
+
+        /// <summary>
+        /// 播发开关
+        /// </summary>
+        [Tooltip("播放")]
+        public bool isPlay = false;
+
+        /// <summary>
+        /// 循环开关
+        /// </summary>
+        [Tooltip("循环")]
+        public bool Loop = false;
+
+        /// <summary>
+        /// 倒放开关
+        /// </summary>
+        [Tooltip("倒放")]
+        public bool isRunBack = false;
+
+        /// <summary>
+        /// 序列帧图集
+        /// </summary>
+        [Tooltip("序列帧图集")]
+        public Sprite[] sprites;
+
+        private SD_MarkerClock markerClock;
+
+
+        // Use this for initialization
+        void Start()
+        {
+            markerClock = new SD_MarkerClock();
+
+            if (transform.GetType() == typeof(Transform))
+            {
+                spriteRenderer = (GetComponent<SpriteRenderer>() != null) ? GetComponent<SpriteRenderer>() : gameObject.AddComponent<SpriteRenderer>();
+                mode = Mode.SpriteRenderer;
+            }
+            else
+            {
+                if (GetComponent<Image>() != null)
+                {
+                    image = GetComponent<Image>();
+                    mode = Mode.Image;
+                }
+                else if (GetComponent<RawImage>() != null)
+                {
+                    rawImage = GetComponent<RawImage>();
+                    mode = Mode.RawImage;
+                }
+                else
+                {
+                    image = gameObject.AddComponent<Image>();
+                    mode = Mode.Image;
+                }
+            }
+        }
+
+        /// <summary>
+        /// 设置图片：精灵图片
+        /// </summary>
+        /// <param name="sprite">精灵图片</param>
+        public void Set_Sprite(Sprite sprite)
+        {
+            switch (mode)
+            {
+                case Mode.Image:
+                    image.sprite = sprite; break;
+                case Mode.SpriteRenderer:
+                    spriteRenderer.sprite = sprite; break;
+                case Mode.RawImage:
+                    rawImage.texture = sprite.texture;break;
+                default:
+                    image.sprite = sprite; break;
+            }
+
+        }
+
+        /// <summary>
+        /// 设置图片：序列帧图片
+        /// </summary>
+        /// <param name="index">序列帧序号</param>
+        public void Set_Sprite(int index)
+        {
+            Set_Sprite(sprites[index]);
+        }
+
+        /// <summary>
+        /// 设置图片：序列帧第一帧
+        /// </summary>
+        public void Set_SpriteHead()
+        {
+            Set_Sprite(sprites[0]);
+            this.index = 0;
+        }
+
+        /// <summary>
+        /// 设置图片：序列帧最后一帧
+        /// </summary>
+        public void Set_SpriteTail()
+        {
+            Set_Sprite(sprites[sprites.Length - 1]);
+            this.index = sprites.Length - 1;
+        }
+
+        /// <summary>
+        /// 序列帧播放
+        /// </summary>
+        public void Play()
+        {
+            isPlay = true;
+            isRunBack = false;
+        }
+
+        /// <summary>
+        /// 序列帧倒放
+        /// </summary>
+        public void PlayBack()
+        {
+            isPlay = true;
+            isRunBack = true;
+        }
+
+        /// <summary>
+        /// 序列帧播放
+        /// </summary>
+        /// <param name="index">序列帧序号</param>
+        public void Play(int index)
+        {
+            isPlay = true;
+            isRunBack = false;
+            this.index = index;
+        }
+
+        /// <summary>
+        /// 序列帧倒放
+        /// </summary>
+        /// <param name="index">序列帧序号</param>
+        public void PlayBack(int index)
+        {
+            isPlay = true;
+            isRunBack = true;
+            this.index = index;
+        }
+
+        /// <summary>
+        /// 序列帧暂停
+        /// </summary>
+        public void Stop()
+        {
+            isPlay = false;
+        }
+
+
+        /// <summary>
+        /// 序列帧判断：播放到第一帧
+        /// </summary>
+        /// <returns></returns>
+        public bool If_PlayHead()
+        {
+            return 0 == index;
+        }
+
+        /// <summary>
+        /// 序列帧判断：播放到最后一帧
+        /// </summary>
+        /// <returns>bool</returns>
+        public bool If_PlayTail()
+        {
+            return sprites.Length - 1 == index;
+        }
+
+        /// <summary>
+        /// 重置序列帧组件
+        /// </summary>
+        public void Reset()
+        {
+            index = 0;
+            isPlay = false;
+            isRunBack = false;
+            markerClock.Reset_Marker();
+        }
+
+
+        // Update is called once per frame
+        void FixedUpdate()
+        {
+            if (markerClock.IF_Clock_GameWorld(Speed, true) && isPlay)
+            {
+                if (isRunBack)
+                {
+                    if (index > 0)
+                    {
+                        index--;
+                        Set_Sprite(sprites[index]);
+                    }
+                    else
+                    {
+                        if (Loop) { Set_SpriteTail(); }
+                    }
+                }
+                else
+                {
+                    if (index < sprites.Length - 1)
+                    {
+                        index++;
+                        Set_Sprite(sprites[index]);
+                    }
+                    else
+                    {
+                        if (Loop) { Set_SpriteHead(); }
+                    }
+                }
+            }
+        }
+
+    }
+
+}
\ No newline at end of file
diff --git a/SDHK_Tool/Component/UI/SequenceFrame/SC_SequenceFrame_Sprite.cs.meta b/SDHK_Tool/Component/UI/SequenceFrame/SC_SequenceFrame_Sprite.cs.meta
new file mode 100644
index 0000000..d054296
--- /dev/null
+++ b/SDHK_Tool/Component/UI/SequenceFrame/SC_SequenceFrame_Sprite.cs.meta
@@ -0,0 +1,13 @@
+fileFormatVersion: 2
+guid: 1f5c51d2e3acdf945870ad1a4005011a
+timeCreated: 1569723182
+licenseType: Pro
+MonoImporter:
+  externalObjects: {}
+  serializedVersion: 2
+  defaultReferences: []
+  executionOrder: 0
+  icon: {instanceID: 0}
+  userData: 
+  assetBundleName: 
+  assetBundleVariant: 
diff --git a/SDHK_Tool/Component/UI/SequenceFrame/SC_SequenceFrame_Textrue.cs b/SDHK_Tool/Component/UI/SequenceFrame/SC_SequenceFrame_Textrue.cs
new file mode 100644
index 0000000..76e13c9
--- /dev/null
+++ b/SDHK_Tool/Component/UI/SequenceFrame/SC_SequenceFrame_Textrue.cs
@@ -0,0 +1,245 @@
+﻿using SDHK_Tool.Dynamic;
+using UnityEngine;
+using UnityEngine.UI;
+
+
+
+/*
+ * 作者：闪电Y黑客
+ * 
+ * 日期： 2019.9.29
+ * 
+ * 功能：序列帧播放工具【精灵图片】
+ *
+ */
+
+namespace SDHK_Tool.Component
+{
+    /// <summary>
+    /// 序列帧工具:[Textrue2D纹理]
+    /// </summary>
+    public class SC_SequenceFrame_Textrue : MonoBehaviour
+    {
+
+        [SerializeField]
+        public enum Mode
+        {
+            RawImage
+        }
+
+        private RawImage rawImage;
+
+        [Tooltip("播放组件")]
+        private Mode mode;
+
+        /// <summary>
+        /// 序列帧播放速度
+        /// </summary>
+        [Tooltip("播放速度")]
+        public float Speed = 1;
+
+        /// <summary>
+        /// 序列帧播放序号
+        /// </summary>
+        [Tooltip("播放序号")]
+        public int index = 0;
+
+        /// <summary>
+        /// 播发开关
+        /// </summary>
+        [Tooltip("播放")]
+        public bool isPlay = false;
+
+        /// <summary>
+        /// 循环开关
+        /// </summary>
+        [Tooltip("循环")]
+        public bool Loop = false;
+
+        /// <summary>
+        /// 倒放开关
+        /// </summary>
+        [Tooltip("倒放")]
+        public bool isRunBack = false;
+
+        /// <summary>
+        /// 序列帧图集
+        /// </summary>
+        [Tooltip("序列帧图集")]
+        public Texture2D[] textures;
+
+        private SD_MarkerClock markerClock;
+
+        // Use this for initialization
+        void Start()
+        {
+            markerClock = new SD_MarkerClock();
+
+            if (GetComponent<RawImage>() != null)
+            {
+                rawImage = GetComponent<RawImage>();
+                mode = Mode.RawImage;
+            }
+            else
+            {
+                rawImage = gameObject.AddComponent<RawImage>();
+                mode = Mode.RawImage;
+            }
+        }
+
+
+        /// <summary>
+        /// 设置图片：精灵图片
+        /// </summary>
+        /// <param name="texture2D">精灵图片</param>
+        public void Set_Texture2D(Texture2D texture2D)
+        {
+            switch (mode)
+            {
+                case Mode.RawImage:
+                    rawImage.texture = texture2D; break;
+                default:
+                    rawImage.texture = texture2D; break;
+            }
+        }
+
+        /// <summary>
+        /// 设置图片：序列帧图片
+        /// </summary>
+        /// <param name="index">序列帧序号</param>
+        public void Set_Texture2D(int index)
+        {
+            Set_Texture2D(textures[index]);
+        }
+
+        /// <summary>
+        /// 设置图片：序列帧第一帧
+        /// </summary>
+        public void Set_Texture2DHead()
+        {
+            Set_Texture2D(textures[0]);
+            this.index = 0;
+        }
+
+        /// <summary>
+        /// 设置图片：序列帧最后一帧
+        /// </summary>
+        public void Set_Texture2DTail()
+        {
+            Set_Texture2D(textures[textures.Length - 1]);
+            this.index = textures.Length - 1;
+        }
+
+        /// <summary>
+        /// 序列帧播放
+        /// </summary>
+        public void Play()
+        {
+            isPlay = true;
+            isRunBack = false;
+        }
+
+        /// <summary>
+        /// 序列帧倒放
+        /// </summary>
+        public void PlayBack()
+        {
+            isPlay = true;
+            isRunBack = true;
+        }
+
+        /// <summary>
+        /// 序列帧播放
+        /// </summary>
+        /// <param name="index">序列帧序号</param>
+        public void Play(int index)
+        {
+            isPlay = true;
+            isRunBack = false;
+            this.index = index;
+        }
+
+        /// <summary>
+        /// 序列帧倒放
+        /// </summary>
+        /// <param name="index">序列帧序号</param>
+        public void PlayBack(int index)
+        {
+            isPlay = true;
+            isRunBack = true;
+            this.index = index;
+        }
+
+        /// <summary>
+        /// 序列帧暂停
+        /// </summary>
+        public void Stop()
+        {
+            isPlay = false;
+        }
+
+
+        /// <summary>
+        /// 序列帧判断：播放到第一帧
+        /// </summary>
+        /// <returns></returns>
+        public bool If_PlayHead()
+        {
+            return 0 == index;
+        }
+
+        /// <summary>
+        /// 序列帧判断：播放到最后一帧
+        /// </summary>
+        /// <returns>bool</returns>
+        public bool If_PlayTail()
+        {
+            return textures.Length - 1 == index;
+        }
+
+        /// <summary>
+        /// 重置序列帧组件
+        /// </summary>
+        public void Reset()
+        {
+            index = 0;
+            isPlay = false;
+            isRunBack = false;
+            markerClock.Reset_Marker();
+        }
+
+
+        // Update is called once per frame
+        void FixedUpdate()
+        {
+            if (markerClock.IF_Clock_GameWorld(Speed, true) && isPlay)
+            {
+                if (isRunBack)
+                {
+                    if (index > 0)
+                    {
+                        index--;
+                        Set_Texture2D(textures[index]);
+                    }
+                    else
+                    {
+                        if (Loop) { Set_Texture2DTail(); }
+                    }
+                }
+                else
+                {
+                    if (index < textures.Length - 1)
+                    {
+                        index++;
+                        Set_Texture2D(textures[index]);
+                    }
+                    else
+                    {
+                        if (Loop) { Set_Texture2DHead(); }
+                    }
+                }
+            }
+        }
+    }
+
+}
\ No newline at end of file
diff --git a/SDHK_Tool/Component/UI/SequenceFrame/SC_SequenceFrame_Textrue.cs.meta b/SDHK_Tool/Component/UI/SequenceFrame/SC_SequenceFrame_Textrue.cs.meta
new file mode 100644
index 0000000..95fef08
--- /dev/null
+++ b/SDHK_Tool/Component/UI/SequenceFrame/SC_SequenceFrame_Textrue.cs.meta
@@ -0,0 +1,13 @@
+fileFormatVersion: 2
+guid: e63c51fb242094145af798c35cd0ff7e
+timeCreated: 1569723235
+licenseType: Pro
+MonoImporter:
+  externalObjects: {}
+  serializedVersion: 2
+  defaultReferences: []
+  executionOrder: 0
+  icon: {instanceID: 0}
+  userData: 
+  assetBundleName: 
+  assetBundleVariant: 
diff --git a/SDHK_Tool/DLL.meta b/SDHK_Tool/DLL.meta
new file mode 100644
index 0000000..9bfc1df
--- /dev/null
+++ b/SDHK_Tool/DLL.meta
@@ -0,0 +1,10 @@
+fileFormatVersion: 2
+guid: 2d0e269d11e58c443884128f4f350ae2
+folderAsset: yes
+timeCreated: 1585187510
+licenseType: Free
+DefaultImporter:
+  externalObjects: {}
+  userData: 
+  assetBundleName: 
+  assetBundleVariant: 
diff --git a/SDHK_Tool/DLL/Qr_code/zxing.unity.dll b/SDHK_Tool/DLL/Qr_code/zxing.unity.dll
new file mode 100644
index 0000000..f512096
Binary files /dev/null and b/SDHK_Tool/DLL/Qr_code/zxing.unity.dll differ
diff --git a/SDHK_Tool/DLL/Qr_code/zxing.unity.dll.meta b/SDHK_Tool/DLL/Qr_code/zxing.unity.dll.meta
new file mode 100644
index 0000000..86b341a
--- /dev/null
+++ b/SDHK_Tool/DLL/Qr_code/zxing.unity.dll.meta
@@ -0,0 +1,32 @@
+fileFormatVersion: 2
+guid: bc94aea574405dc40bc3d37cd6a1aa01
+timeCreated: 1582699721
+licenseType: Free
+PluginImporter:
+  externalObjects: {}
+  serializedVersion: 2
+  iconMap: {}
+  executionOrder: {}
+  isPreloaded: 0
+  isOverridable: 0
+  platformData:
+  - first:
+      Any: 
+    second:
+      enabled: 1
+      settings: {}
+  - first:
+      Editor: Editor
+    second:
+      enabled: 0
+      settings:
+        DefaultValueInitialized: true
+  - first:
+      Windows Store Apps: WindowsStoreApps
+    second:
+      enabled: 0
+      settings:
+        CPU: AnyCPU
+  userData: 
+  assetBundleName: 
+  assetBundleVariant: 
diff --git a/SDHK_Tool/DLL/Touch_TUIO/OSCsharp.dll b/SDHK_Tool/DLL/Touch_TUIO/OSCsharp.dll
new file mode 100644
index 0000000..f89b6e3
Binary files /dev/null and b/SDHK_Tool/DLL/Touch_TUIO/OSCsharp.dll differ
diff --git a/SDHK_Tool/DLL/Touch_TUIO/OSCsharp.dll.meta b/SDHK_Tool/DLL/Touch_TUIO/OSCsharp.dll.meta
new file mode 100644
index 0000000..4701033
--- /dev/null
+++ b/SDHK_Tool/DLL/Touch_TUIO/OSCsharp.dll.meta
@@ -0,0 +1,32 @@
+fileFormatVersion: 2
+guid: 6732ae66f003a5646beef7a604eca0fc
+timeCreated: 1582699727
+licenseType: Free
+PluginImporter:
+  externalObjects: {}
+  serializedVersion: 2
+  iconMap: {}
+  executionOrder: {}
+  isPreloaded: 0
+  isOverridable: 0
+  platformData:
+  - first:
+      Any: 
+    second:
+      enabled: 1
+      settings: {}
+  - first:
+      Editor: Editor
+    second:
+      enabled: 0
+      settings:
+        DefaultValueInitialized: true
+  - first:
+      Windows Store Apps: WindowsStoreApps
+    second:
+      enabled: 0
+      settings:
+        CPU: AnyCPU
+  userData: 
+  assetBundleName: 
+  assetBundleVariant: 
diff --git a/SDHK_Tool/DLL/Touch_TUIO/TUIOsharp.dll b/SDHK_Tool/DLL/Touch_TUIO/TUIOsharp.dll
new file mode 100644
index 0000000..b09a19d
Binary files /dev/null and b/SDHK_Tool/DLL/Touch_TUIO/TUIOsharp.dll differ
diff --git a/Component/DLL/OSCsharp.dll.meta b/SDHK_Tool/DLL/Touch_TUIO/TUIOsharp.dll.meta
similarity index 97%
rename from Component/DLL/OSCsharp.dll.meta
rename to SDHK_Tool/DLL/Touch_TUIO/TUIOsharp.dll.meta
index 18e5d2e..7f80621 100644
--- a/Component/DLL/OSCsharp.dll.meta
+++ b/SDHK_Tool/DLL/Touch_TUIO/TUIOsharp.dll.meta
@@ -1,5 +1,5 @@
 fileFormatVersion: 2
-guid: 710b2da019022fc49a1e7fbdf009cd6c
+guid: 79a4d43786071994f99fd36708a4fbb9
 PluginImporter:
   serializedVersion: 1
   iconMap: {}
diff --git a/SDHK_Tool/DLL/ZhongWenPinYin/NPinyinPro.dll.meta b/SDHK_Tool/DLL/ZhongWenPinYin/NPinyinPro.dll.meta
new file mode 100644
index 0000000..4fb34db
--- /dev/null
+++ b/SDHK_Tool/DLL/ZhongWenPinYin/NPinyinPro.dll.meta
@@ -0,0 +1,32 @@
+fileFormatVersion: 2
+guid: 522996206e5ff854ea5af3b7d36149bc
+timeCreated: 1578883618
+licenseType: Pro
+PluginImporter:
+  externalObjects: {}
+  serializedVersion: 2
+  iconMap: {}
+  executionOrder: {}
+  isPreloaded: 0
+  isOverridable: 0
+  platformData:
+  - first:
+      Any: 
+    second:
+      enabled: 1
+      settings: {}
+  - first:
+      Editor: Editor
+    second:
+      enabled: 0
+      settings:
+        DefaultValueInitialized: true
+  - first:
+      Windows Store Apps: WindowsStoreApps
+    second:
+      enabled: 0
+      settings:
+        CPU: AnyCPU
+  userData: 
+  assetBundleName: 
+  assetBundleVariant: 
diff --git a/SDHK_Tool/Dynamic/Marker.meta b/SDHK_Tool/Dynamic/Marker.meta
new file mode 100644
index 0000000..8690e79
--- /dev/null
+++ b/SDHK_Tool/Dynamic/Marker.meta
@@ -0,0 +1,10 @@
+fileFormatVersion: 2
+guid: 1d3f080efc945bf47bfd337cecbf7474
+folderAsset: yes
+timeCreated: 1585187510
+licenseType: Free
+DefaultImporter:
+  externalObjects: {}
+  userData: 
+  assetBundleName: 
+  assetBundleVariant: 
diff --git a/SDHK_Tool/Dynamic/Marker/SD_MarkerClock.cs b/SDHK_Tool/Dynamic/Marker/SD_MarkerClock.cs
new file mode 100644
index 0000000..831acc8
--- /dev/null
+++ b/SDHK_Tool/Dynamic/Marker/SD_MarkerClock.cs
@@ -0,0 +1,159 @@
+﻿using System;
+using SDHK_Tool.Static;
+using UnityEngine;
+
+/*
+ * 作者：闪电Y黑客
+ * 
+ * 日期： 2019.9.26
+ * 
+ * 功能：进行计时标记
+ */
+
+namespace SDHK_Tool.Dynamic
+{
+    /// <summary>
+    /// 计时标记器
+    /// </summary>
+    public class SD_MarkerClock
+    {
+        private DateTime StartTime_System;
+        private float StartTime_GameWorld;
+        private float StartTime_Game;
+
+        private bool isStart = false;
+
+        private SD_MarkerEdge MarkerEdge;
+
+
+        public SD_MarkerClock()
+        {
+            MarkerEdge = new SD_MarkerEdge();
+            StartTime_System = DateTime.Now;
+            StartTime_GameWorld = Time.time;
+            StartTime_Game = Time.unscaledTime;
+        }
+
+        /// <summary>
+        /// 计时器[系统时间]：判断执行时间(一次性)
+        /// 到达指定时间返回一帧true
+        /// </summary>
+        /// <param name="targetSeconds">定时</param>
+        /// <returns>return :　触发标记</returns>
+        public bool IF_Clock_System(float targetSeconds)
+        {
+            return isStart && MarkerEdge.isEdge(SS_TriggerMarker.Clock_System(StartTime_System, targetSeconds));
+        }
+
+        /// <summary>
+        /// 计时器[游戏世界时间]：判断执行时间(一次性)（被TimeScale影响）
+        /// 到达指定时间返回一帧true
+        /// </summary>
+        /// <param name="targetSeconds">定时</param>
+        /// <returns>return :　触发标记</returns>
+        public bool IF_Clock_GameWorld(float targetSeconds)
+        {
+            return isStart && MarkerEdge.isEdge(SS_TriggerMarker.Clock_GameWorld(StartTime_GameWorld, targetSeconds));
+        }
+
+
+        /// <summary>
+        /// 计时器[游戏时间]：判断执行时间(一次性)
+        /// 到达指定时间返回一帧true
+        /// </summary>
+        /// <param name="targetSeconds">定时</param>
+        /// <returns>return :　触发标记</returns>
+        public bool IF_Clock_Game(float targetSeconds)
+        {
+            return isStart && MarkerEdge.isEdge(SS_TriggerMarker.Clock_Game(StartTime_Game, targetSeconds));
+        }
+
+
+        /// <summary>
+        /// 计时器[系统时间]：判断执行时间
+        /// 循环触发：到达指定时间返回一帧true，并重置时间再次计时
+        /// 持续触发：到达指定时间后，一直返回true
+        /// </summary>
+        /// <param name="targetSeconds">定时</param>
+        ///	<param name="Switch">true/false（循环触发/持续触发）</param>
+        /// <returns>return :　触发标记</returns>
+        public bool IF_Clock_System(float targetSeconds, bool Switch)
+        {
+            bool bit = SS_TriggerMarker.Clock_System(StartTime_System, targetSeconds);
+            if (bit && Switch) Reset_Marker();
+            return isStart && (Switch) ? MarkerEdge.isEdge(bit) : bit;
+        }
+
+        /// <summary>
+        /// 计时器[游戏世界时间]：判断执行时间（被TimeScale影响）
+        /// 循环触发：到达指定时间返回一帧true，并重置时间再次计时
+        /// 持续触发：到达指定时间后，一直返回true
+        /// </summary>
+        /// <param name="targetSeconds">定时</param>
+        ///	<param name="Switch">true/false（循环触发/持续触发）</param>
+        /// <returns>return :　触发标记</returns>
+        public bool IF_Clock_GameWorld(float targetSeconds, bool Switch)
+        {
+            bool bit = SS_TriggerMarker.Clock_GameWorld(StartTime_GameWorld, targetSeconds);
+            if (bit && Switch) Reset_Marker();
+            return isStart && (Switch) ? MarkerEdge.isEdge(bit) : bit;
+        }
+
+        /// <summary>
+        /// 计时器[游戏时间]：判断执行时间
+        /// 循环触发：到达指定时间返回一帧true，并重置时间再次计时
+        /// 持续触发：到达指定时间后，一直返回true
+        /// </summary>
+        /// <param name="targetSeconds">定时</param>
+        ///	<param name="Switch">true/false（循环触发/持续触发）</param>
+        /// <returns>return :　触发标记</returns>
+        public bool IF_Clock_Game(float targetSeconds, bool Switch)
+        {
+            bool bit = SS_TriggerMarker.Clock_Game(StartTime_Game, targetSeconds);
+            if (bit && Switch) Reset_Marker();
+            return isStart && (Switch) ? MarkerEdge.isEdge(bit) : bit;
+        }
+
+
+        /// <summary>
+        /// 获取倒计时时间[系统时间]
+        /// </summary>
+        /// <returns>倒计时时间</returns>
+        public double Get_Clock_System()
+        {
+            return (DateTime.Now - StartTime_System).TotalSeconds;
+        }
+
+        /// <summary>
+        /// 获取倒计时时间[游戏世界时间]（被TimeScale影响）
+        /// </summary>
+        /// <returns>倒计时时间</returns>
+        public double Get_Clock_GameWorld()
+        {
+            return Time.time - StartTime_GameWorld;
+        }
+
+        /// <summary>
+        /// 获取倒计时时间[游戏时间]
+        /// </summary>
+        /// <returns>倒计时时间</returns>
+        public double Get_Clock_Game()
+        {
+            return Time.unscaledTime - StartTime_Game;
+        }
+
+        /// <summary>
+        /// 重置检测器
+        /// </summary>  
+        public void Reset_Marker()
+        {
+            StartTime_System = DateTime.Now;
+            StartTime_GameWorld = Time.time;
+            StartTime_Game = Time.unscaledTime;
+            isStart = true;
+            MarkerEdge.Reset_Marker();
+        }
+
+
+    }
+}
\ No newline at end of file
diff --git a/SDHK_Tool/Dynamic/Marker/SD_MarkerClock.cs.meta b/SDHK_Tool/Dynamic/Marker/SD_MarkerClock.cs.meta
new file mode 100644
index 0000000..2ed82b6
--- /dev/null
+++ b/SDHK_Tool/Dynamic/Marker/SD_MarkerClock.cs.meta
@@ -0,0 +1,13 @@
+fileFormatVersion: 2
+guid: 83559f804946ff6479ad7e9488877ad8
+timeCreated: 1569476244
+licenseType: Pro
+MonoImporter:
+  externalObjects: {}
+  serializedVersion: 2
+  defaultReferences: []
+  executionOrder: 0
+  icon: {instanceID: 0}
+  userData: 
+  assetBundleName: 
+  assetBundleVariant: 
diff --git a/SDHK_Tool/Dynamic/Marker/SD_MarkerCount.cs b/SDHK_Tool/Dynamic/Marker/SD_MarkerCount.cs
new file mode 100644
index 0000000..7d02501
--- /dev/null
+++ b/SDHK_Tool/Dynamic/Marker/SD_MarkerCount.cs
@@ -0,0 +1,84 @@
+﻿using SDHK_Tool.Static;
+
+
+/*
+ * 作者：闪电Y黑客
+ * 
+ * 日期： 2019.6.11
+ * 
+ * 功能：在Update 里进行计数标记
+ */
+
+namespace SDHK_Tool.Dynamic
+{
+
+    /// <summary>
+    /// 计数标记器
+    /// </summary>
+    public class SD_MarkerCount
+    {
+        private float StartCount = 0;
+
+        private SD_MarkerEdge MarkerEdge;
+
+        public SD_MarkerCount()
+        {
+            MarkerEdge = new SD_MarkerEdge();
+        }
+
+
+        /// <summary>
+        /// 计数器：判断累加数值(一次性)
+        /// 到达指定值返回一帧true
+        /// </summary>
+        /// <param name="targetCount">设定数</param>
+		/// <param name="Cumulative">累加数</param>
+        /// <returns>return :　触发标记</returns>
+        public bool IF_Count(float targetCount, float Cumulative)
+        {
+            return MarkerEdge.isEdge(SS_TriggerMarker.Count(ref StartCount, targetCount, Cumulative));
+        }
+
+        /// <summary>
+        /// 计数器：判断累加数值
+        /// 循环触发：到达指定值返回一帧true，并重置时间再次计时
+        /// 持续触发：到达指定值后，一直返回true
+        /// </summary>
+        /// <param name="targetCount">设定数</param>
+		/// <param name="Cumulative">累加数</param>
+        /// <param name="Switch">true/false（循环触发/持续触发）</param>
+        /// <returns>return :　触发标记</returns>
+        public bool IF_Count(float targetCount, float Cumulative, bool Switch)
+        {
+            bool bit = SS_TriggerMarker.Count(ref StartCount, targetCount, Cumulative);
+            if (bit && Switch) Reset_Marker();
+
+            return (Switch) ? MarkerEdge.isEdge(bit) : bit;
+        }
+
+        /// <summary>
+        /// 获取累加数值
+        /// </summary>
+        /// <returns>累加数值</returns>
+        public float Get_Count()
+        {
+            return StartCount;
+        }
+
+        /// <summary>
+        /// 重置检测器
+        /// </summary>
+        public void Reset_Marker()
+        {
+            StartCount = 0;
+            MarkerEdge.Reset_Marker();
+        }
+
+
+
+
+    }
+
+
+}
+
diff --git a/SDHK_Tool/Dynamic/Marker/SD_MarkerCount.cs.meta b/SDHK_Tool/Dynamic/Marker/SD_MarkerCount.cs.meta
new file mode 100644
index 0000000..7350e17
--- /dev/null
+++ b/SDHK_Tool/Dynamic/Marker/SD_MarkerCount.cs.meta
@@ -0,0 +1,13 @@
+fileFormatVersion: 2
+guid: f78557a239c3b014d8fd61350689f231
+timeCreated: 1560333072
+licenseType: Free
+MonoImporter:
+  externalObjects: {}
+  serializedVersion: 2
+  defaultReferences: []
+  executionOrder: 0
+  icon: {instanceID: 0}
+  userData: 
+  assetBundleName: 
+  assetBundleVariant: 
diff --git a/SDHK_Tool/Dynamic/Marker/SD_MarkerEdge.cs b/SDHK_Tool/Dynamic/Marker/SD_MarkerEdge.cs
new file mode 100644
index 0000000..b38f7f1
--- /dev/null
+++ b/SDHK_Tool/Dynamic/Marker/SD_MarkerEdge.cs
@@ -0,0 +1,42 @@
+﻿using SDHK_Tool.Static;
+
+
+/*
+ * 作者：闪电Y黑客
+ * 
+ * 日期： 2019.6.11
+ * 
+ * 功能：在Update 里进行变化标记
+ *
+ */
+
+namespace SDHK_Tool.Dynamic
+{
+	/// <summary>
+	/// 边缘检测器
+	/// </summary>
+    public class SD_MarkerEdge
+    {
+        private bool bit = false;
+
+		/// <summary>
+        /// 边缘检测：检测Switch是否发生变化,触发标记变成true一次 ;  用!Switch[与]运算过滤上下边缘
+        /// </summary>
+        /// <param name="Switch">标记开关</param>
+        /// <returns>return :　触发标记</returns>
+        public bool isEdge(bool Switch)
+        {
+            return SS_TriggerMarker.Edge(Switch, ref bit);
+        }
+
+		/// <summary>
+        /// 重置检测器
+        /// </summary>
+        public void Reset_Marker()
+        {
+            bit = false;
+        }
+
+    }
+}
+
diff --git a/SDHK_Tool/Dynamic/Marker/SD_MarkerEdge.cs.meta b/SDHK_Tool/Dynamic/Marker/SD_MarkerEdge.cs.meta
new file mode 100644
index 0000000..400a145
--- /dev/null
+++ b/SDHK_Tool/Dynamic/Marker/SD_MarkerEdge.cs.meta
@@ -0,0 +1,13 @@
+fileFormatVersion: 2
+guid: cac941c7bf78cf847acf8a56021e1984
+timeCreated: 1560332300
+licenseType: Free
+MonoImporter:
+  externalObjects: {}
+  serializedVersion: 2
+  defaultReferences: []
+  executionOrder: 0
+  icon: {instanceID: 0}
+  userData: 
+  assetBundleName: 
+  assetBundleVariant: 
diff --git a/SDHK_Tool/Dynamic/Marker/SD_MarkerTrigger.cs b/SDHK_Tool/Dynamic/Marker/SD_MarkerTrigger.cs
new file mode 100644
index 0000000..6317840
--- /dev/null
+++ b/SDHK_Tool/Dynamic/Marker/SD_MarkerTrigger.cs
@@ -0,0 +1,43 @@
+﻿using SDHK_Tool.Static;
+
+
+/*
+ * 作者：闪电Y黑客
+ * 
+ * 日期： 2019.6.11
+ * 
+ * 功能：在Update 里进行变化标记
+ */
+
+namespace SDHK_Tool.Dynamic
+{
+	/// <summary>
+	/// T触发检测器
+	/// </summary>
+    public class SD_MarkerTrigger
+    {
+        private bool bit = false;
+        private bool trigger = false;
+
+        /// <summary>
+        ///  T触发器：Switch间隔变成true，可改变触发标记状态（false/true）
+        /// </summary>
+        /// <param name="Switch">标记开关</param>
+        /// <returns>return :　触发标记</returns>
+        public bool isTrigger(bool Switch)
+        {
+            return SS_TriggerMarker.Trigger(Switch, ref bit, ref trigger);
+        }
+
+        /// <summary>
+        /// 重置检测器
+        /// </summary>
+        public void Reset_Marker()
+        {
+            bit = false;
+            trigger = false;
+        }
+
+    }
+}
+
diff --git a/SDHK_Tool/Dynamic/Marker/SD_MarkerTrigger.cs.meta b/SDHK_Tool/Dynamic/Marker/SD_MarkerTrigger.cs.meta
new file mode 100644
index 0000000..f8b6fa7
--- /dev/null
+++ b/SDHK_Tool/Dynamic/Marker/SD_MarkerTrigger.cs.meta
@@ -0,0 +1,13 @@
+fileFormatVersion: 2
+guid: 4f8a8e108aa6b704e88f854a8eea6e1a
+timeCreated: 1560332714
+licenseType: Free
+MonoImporter:
+  externalObjects: {}
+  serializedVersion: 2
+  defaultReferences: []
+  executionOrder: 0
+  icon: {instanceID: 0}
+  userData: 
+  assetBundleName: 
+  assetBundleVariant: 
diff --git a/SDHK_Tool/Dynamic/Motor/SD_Motor_Angle.cs b/SDHK_Tool/Dynamic/Motor/SD_Motor_Angle.cs
new file mode 100644
index 0000000..2ba7832
--- /dev/null
+++ b/SDHK_Tool/Dynamic/Motor/SD_Motor_Angle.cs
@@ -0,0 +1,344 @@
+﻿using UnityEngine;
+using SDHK_Tool.Static;
+
+
+/*
+ * 作者：闪电Y黑客
+ * 
+ * 日期： 2019.6.16
+ * 
+ * 功能：集合旋转方法
+ */
+
+
+namespace SDHK_Tool.Dynamic
+{
+
+    /// <summary>
+    /// 角度旋转电机
+    /// </summary>
+    public class SD_Motor_Angle
+    {
+
+        /// <summary>
+        /// 电机激活
+        /// </summary>
+        public bool MotorActivation = true;
+        /// <summary>
+        /// 电机速度
+        /// </summary>
+        public float MotorSpeed = 10;
+        /// <summary>
+        /// 限制器激活
+        /// </summary>
+        public bool MotorConstraint = false;
+        /// <summary>
+        /// 限制数：最小限制
+        /// </summary>
+        public float Limit_Min = 0;
+        /// <summary>
+        /// 限制数：最大限制
+        /// </summary>
+        public float Limit_Max = 0;
+        /// <summary>
+        /// 范围半径限制【用于范围限制】
+        /// </summary>
+        public float Limit_Radius = 0;
+        /// <summary>
+        /// 目标角度
+        /// </summary>
+        public float MotorTarget;
+        /// <summary>
+        /// 电机运行后的角度
+        /// </summary>
+        public float MotorSave;
+        /// <summary>
+        /// 平滑运行返回的速度
+        /// </summary>
+        public float MotorVelocity;
+
+
+
+        #region 数值赋值
+
+
+
+        /// <summary>
+        /// 设置电机激活
+        /// </summary>
+        /// <param name="Activation">激活</param>
+        /// <returns>电机</returns>
+        public SD_Motor_Angle Set_MotorActivation(bool Activation)
+        {
+            MotorActivation = Activation;
+            return this;
+        }
+
+        /// <summary>
+        /// 设置限制器激活
+        /// </summary>
+        /// <param name="Constraint">激活</param>
+        /// <returns>电机</returns>
+        public SD_Motor_Angle Set_MotorConstraint(bool Constraint)
+        {
+            MotorConstraint = Constraint;
+            return this;
+        }
+
+        /// <summary>
+        /// 设置电机限制半径
+        /// </summary>
+        /// <param name="Radius">半径值</param>
+        /// <returns>电机</returns>
+        public SD_Motor_Angle Set_MotorConstraint_Radius(float Radius)
+        {
+            Limit_Radius = Radius;
+            return this;
+        }
+
+        /// <summary>
+        /// 设置电机限制值
+        /// </summary>
+        /// <param name="Limit_Min">最小值</param>
+        /// <param name="Limit_Max">最大值</param>
+        /// <returns>电机</returns>
+        public SD_Motor_Angle Set_MotorConstraint_Limit(float Limit_Min, float Limit_Max)
+        {
+            this.Limit_Min = Limit_Min;
+            this.Limit_Max = Limit_Max;
+            return this;
+        }
+
+        /// <summary>
+        /// 设置电机速度
+        /// </summary>
+        /// <param name="Speed">速度值</param>
+        /// <returns>电机</returns>
+        public SD_Motor_Angle Set_MotorSpeed(float Speed)
+        {
+            MotorSpeed = Speed;
+            return this;
+        }
+
+
+        /// <summary>
+        /// 设置电机目标角度和当前角度
+        /// </summary>
+        /// <param name="Value">角度</param>
+        /// <returns>电机</returns>
+        public SD_Motor_Angle Set_MotorValue_Angle(float angle)
+        {
+            MotorTarget = angle;
+            MotorSave = angle;
+            return this;
+        }
+
+
+        /// <summary>
+        /// 设置电机目标角度和当前角度
+        /// </summary>
+        /// <param name="vector2">角度向量</param>
+        /// <returns>电机</returns>
+        public SD_Motor_Angle Set_MotorValue_Vector(Vector2 vector2)
+        {
+            MotorTarget = SS_EulerAngleConversion.Get_Angle_In_Vector2(vector2);
+            MotorSave = MotorTarget;
+            return this;
+        }
+
+        /// <summary>
+        /// 设置电机位置
+        /// </summary>
+        /// <param name="angle">角度值</param>
+        /// <returns>电机</returns>
+        public SD_Motor_Angle Set_MotorSave(float angle)
+        {
+            MotorSave = angle;
+            return this;
+        }
+
+
+
+
+        #endregion
+
+
+
+        #region 电机操控
+
+
+
+        /// <summary>
+        /// 设置电机旋转差值
+        /// </summary>
+        /// <param name="AngleDelta">旋转差值</param>
+        /// <returns>电机</returns>
+        public SD_Motor_Angle SetTarget_AngleDelta(float AngleDelta)
+        {
+            if (MotorActivation) MotorTarget += AngleDelta;
+            MotorTarget = SS_EulerAngleConversion.Angle_PN_To_P360(MotorTarget);
+            return this;
+        }
+
+        /// <summary>
+        /// 设置电机旋转目标
+        /// </summary>
+        /// <param name="Angle">旋转目标</param>
+        /// <returns>电机</returns>
+        public SD_Motor_Angle SetTarget_Angle(float Angle)
+        {
+            if (MotorActivation) MotorTarget = Angle;
+            MotorTarget = SS_EulerAngleConversion.Angle_PN_To_P360(MotorTarget);
+            return this;
+        }
+
+        /// <summary>
+        /// 设置电机旋转目标向量
+        /// </summary>
+        /// <param name="vector2">旋转目标角度向量</param>
+        /// <returns>电机</returns>
+        public SD_Motor_Angle SetTarget_Vector(Vector2 vector2)
+        {
+            if (MotorActivation && vector2 != Vector2.zero) MotorTarget = SS_EulerAngleConversion.Get_Angle_In_Vector2(vector2);
+            MotorTarget = SS_EulerAngleConversion.Angle_PN_To_P360(MotorTarget);
+            return this;
+        }
+
+
+        #endregion
+
+
+
+        #region 电机运行
+
+
+
+        /// <summary>
+        /// 电机运行 ： 匀速旋转
+        /// </summary>
+        /// <param name="Time_deltaTime">时间参数</param>
+        /// <returns>电机</returns>
+        public SD_Motor_Angle Run_MoveTowardsAngle(float Time_deltaTime)
+        {
+            MotorSave = Mathf.MoveTowardsAngle(MotorSave, MotorTarget, MotorSpeed * Time_deltaTime);
+            return this;
+        }
+
+        /// <summary>
+        /// 电机运行 ： 差值旋转
+        /// </summary>
+        /// <param name="Time_deltaTime">时间参数</param>
+        /// <returns>电机</returns>
+        public SD_Motor_Angle Run_LerpAngle(float Time_deltaTime)
+        {
+            MotorSave = Mathf.LerpAngle(MotorSave, MotorTarget, MotorSpeed * Time_deltaTime);
+            return this;
+        }
+
+        /// <summary>
+        /// 电机运行 ： 平滑旋转
+        /// </summary>
+        /// <returns>电机</returns>
+        public SD_Motor_Angle Run_SmoothDampAngle()
+        {
+            MotorSave = Mathf.SmoothDampAngle(MotorSave, MotorTarget, ref MotorVelocity, MotorSpeed);
+            return this;
+        }
+
+
+
+        #endregion
+
+
+
+        #region 限制器
+
+
+
+        /// <summary>
+        /// 旋转限制器 ： 本地限制【注：需要限制数值】
+        /// </summary>
+        /// <returns>电机</returns>
+        public SD_Motor_Angle Constraint_Angle_Local()
+        {
+            if (MotorConstraint) MotorSave = SS_Mathf.Clamp_Angle(MotorSave, Limit_Min, Limit_Max);
+            return this;
+        }
+
+        /// <summary>
+        /// 旋转限制器 ： 本地范围限制【注：需要半径值】
+        /// </summary>
+        /// <returns>电机</returns>
+        public SD_Motor_Angle Constraint_Angle_Local_Scope()
+        {
+            if (MotorConstraint) MotorSave = SS_Mathf.Clamp_Angle(MotorSave, -Limit_Radius, Limit_Radius);
+            return this;
+        }
+
+        /// <summary>
+        /// 旋转限制器 ： 本地全面角度限制【注：需要限制数值】
+        /// </summary>
+        /// <returns>电机</returns>
+        public SD_Motor_Angle Constraint_Angle_Complete_Local()
+        {
+            if (MotorConstraint) MotorSave = SS_Mathf.Clamp_Angle_Complete(MotorSave, Limit_Min, Limit_Max);
+            return this;
+        }
+
+        /// <summary>
+        /// 旋转限制器 ： 目标限制【注：需要限制数值】
+        /// </summary>
+        /// <returns>电机</returns>
+        public SD_Motor_Angle Constraint_Angle_Target()
+        {
+            if (MotorConstraint) MotorSave = SS_Mathf.Clamp_Angle_Complete(MotorSave, MotorTarget + Limit_Min, MotorTarget + Limit_Max);
+            return this;
+        }
+
+        /// <summary>
+        /// 旋转限制器 ： 目标范围限制【注：需要半径值】
+        /// </summary>
+        /// <returns>电机</returns>
+        public SD_Motor_Angle Constraint_Angle_Target_Scope()
+        {
+            if (MotorConstraint) MotorSave = SS_Mathf.Clamp_Angle_Complete_Scope(MotorSave, MotorTarget, Limit_Radius);
+            return this;
+        }
+
+        #endregion
+
+
+
+        #region 数值获取
+
+
+
+        /// <summary>
+        /// 获取电机当前角度
+        /// </summary>
+        /// <returns>return : 电机角度</returns>
+        public float Get_MotorSave()
+        {
+            return MotorSave;
+        }
+
+        /// <summary>
+        /// 判断电机旋转完成
+        /// </summary>
+        /// <param name="Deviation">偏差值</param>
+        /// <returns>bool</returns>
+        public bool If_MotorSpinFinish(float Deviation)
+        {
+            return Mathf.Abs(Mathf.DeltaAngle(MotorTarget, MotorSave)) < Deviation;
+        }
+
+
+
+        #endregion
+
+
+
+
+    }
+}
+
diff --git a/SDHK_Tool/Dynamic/Motor/SD_Motor_Angle.cs.meta b/SDHK_Tool/Dynamic/Motor/SD_Motor_Angle.cs.meta
new file mode 100644
index 0000000..de480d5
--- /dev/null
+++ b/SDHK_Tool/Dynamic/Motor/SD_Motor_Angle.cs.meta
@@ -0,0 +1,13 @@
+fileFormatVersion: 2
+guid: 3ea25a51f6b0e9b47925168bd1bfb907
+timeCreated: 1560751766
+licenseType: Free
+MonoImporter:
+  externalObjects: {}
+  serializedVersion: 2
+  defaultReferences: []
+  executionOrder: 0
+  icon: {instanceID: 0}
+  userData: 
+  assetBundleName: 
+  assetBundleVariant: 
diff --git a/SDHK_Tool/Dynamic/Motor/SD_Motor_EulerAngle.cs b/SDHK_Tool/Dynamic/Motor/SD_Motor_EulerAngle.cs
new file mode 100644
index 0000000..0b948cc
--- /dev/null
+++ b/SDHK_Tool/Dynamic/Motor/SD_Motor_EulerAngle.cs
@@ -0,0 +1,383 @@
+﻿using UnityEngine;
+using SDHK_Tool.Static;
+
+/*
+ * 作者：闪电Y黑客
+ * 
+ * 日期： 2019.6.16
+ * 
+ * 功能：集合欧拉角旋转方法
+ */
+
+namespace SDHK_Tool.Dynamic
+{
+
+    /// <summary>
+    /// 欧拉角旋转电机
+    /// </summary>
+    public class SD_Motor_EulerAngle
+    {
+
+        /// <summary>
+        /// 电机激活
+        /// </summary>
+        public bool MotorActivation = true;
+        /// <summary>
+        /// 电机速度
+        /// </summary>
+        public float MotorSpeed = 10;
+        /// <summary>
+        /// 限制器激活
+        /// </summary>
+        public bool MotorConstraint = false;
+        /// <summary>
+        /// 限制X轴激活
+        /// </summary>
+        public bool Constraint_X = true;
+        /// <summary>
+        /// 限制Y轴激活
+        /// </summary>
+        public bool Constraint_Y = true;
+        /// <summary>
+        /// 限制Z轴激活
+        /// </summary>
+        public bool Constraint_Z = true;
+        /// <summary>
+        /// 限制数：最小限制
+        /// </summary>
+        public Vector3 Limit_Min = Vector3.zero;
+        /// <summary>
+        /// 限制数：最大限制
+        /// </summary>
+        public Vector3 Limit_Max = Vector3.zero;
+        /// <summary>
+        /// 范围自由半径限制【用于自定义范围限制】
+        /// </summary>
+        public Vector3 Limit_RadiusFree = Vector3.zero;
+        /// <summary>
+        /// 目标位置
+        /// </summary>
+        public Vector3 MotorTarget;
+        /// <summary>
+        /// 电机运行后的位置
+        /// </summary>
+        public Vector3 MotorSave;
+        /// <summary>
+        /// 平滑运行返回的速度
+        /// </summary>
+        public Vector3 MotorVelocity;
+
+
+
+        #region 数值赋值
+
+
+
+        /// <summary>
+        /// 设置电机激活
+        /// </summary>
+        /// <param name="Activation">激活</param>
+        /// <returns>电机</returns>
+        public SD_Motor_EulerAngle Set_MotorActivation(bool Activation)
+        {
+            MotorActivation = Activation;
+            return this;
+        }
+
+        /// <summary>
+        /// 设置限制器激活
+        /// </summary>
+        /// <param name="Constraint">激活</param>
+        /// <returns>电机</returns>
+        public SD_Motor_EulerAngle Set_MotorConstraint(bool Constraint)
+        {
+            MotorConstraint = Constraint;
+            return this;
+        }
+
+        /// <summary>
+        /// 设置限制轴激活
+        /// </summary>
+        /// <param name="Constraint_Shaft">轴激活</param>
+        /// <returns>电机</returns>
+        public SD_Motor_EulerAngle Set_MotorConstraint_Shaft(bool X = true, bool Y = true, bool Z = true)
+        {
+            Constraint_X = X;
+            Constraint_Y = Y;
+            Constraint_Z = Z;
+            return this;
+        }
+
+        /// <summary>
+        /// 设置电机限制半径
+        /// </summary>
+        /// <param name="Radius">半径值</param>
+        /// <returns>电机</returns>
+        public SD_Motor_EulerAngle Set_MotorConstraint_Radius(Vector3 Radius)
+        {
+            Limit_RadiusFree = Radius;
+            return this;
+        }
+
+        /// <summary>
+        /// 设置电机限制值
+        /// </summary>
+        /// <param name="Limit_Min">最小值</param>
+        /// <param name="Limit_Max">最大值</param>
+        /// <returns>电机</returns>
+        public SD_Motor_EulerAngle Set_MotorConstraint_Limit(Vector3 Limit_Min, Vector3 Limit_Max)
+        {
+            this.Limit_Min = Limit_Min;
+            this.Limit_Max = Limit_Max;
+            return this;
+        }
+
+        /// <summary>
+        /// 设置电机速度
+        /// </summary>
+        /// <param name="Speed">速度值</param>
+        /// <returns>电机</returns>
+        public SD_Motor_EulerAngle Set_MotorSpeed(float Speed)
+        {
+            MotorSpeed = Speed;
+            return this;
+        }
+
+
+
+        /// <summary>
+        /// 设置电机目标角度和当前
+        /// </summary>
+        /// <param name="EulerAngle">欧拉角</param>
+        /// <returns>电机</returns>
+        public SD_Motor_EulerAngle Set_MotorValue_Angle(Vector3 EulerAngle)
+        {
+            MotorTarget = EulerAngle;
+            MotorSave = EulerAngle;
+            return this;
+        }
+
+        /// <summary>
+        /// 设置电机目标角度和当前
+        /// </summary>
+        /// <param name="vector3">角度向量</param>
+        /// <returns>电机</returns>
+        public SD_Motor_EulerAngle Set_MotorValue_Vector3(Vector3 vector3)
+        {
+            MotorTarget = vector3;
+            MotorSave = vector3;
+            return this;
+        }
+
+        /// <summary>
+        /// 设置电机位置
+        /// </summary>
+        /// <param name="angle">欧拉角</param>
+        /// <returns>电机</returns>
+        public SD_Motor_EulerAngle Set_MotorSave(Vector3 EulerAngle)
+        {
+            MotorSave = EulerAngle;
+            return this;
+        }
+
+
+
+        #endregion
+
+
+
+        #region 电机操控
+
+
+
+        /// <summary>
+        /// 设置电机旋转差值
+        /// </summary>
+        /// <param name="VectorDelta">旋转差值</param>
+        /// <returns>电机</returns>
+        public SD_Motor_EulerAngle SetTarget_AngleDelta(Vector3 VectorDelta)
+        {
+            if (MotorActivation) MotorTarget += VectorDelta;
+            MotorTarget = SS_EulerAngleConversion.EulerAngle_PN_To_P360(MotorTarget);
+            return this;
+        }
+
+        /// <summary>
+        /// 设置电机旋转目标
+        /// </summary>
+        /// <param name="Vector">旋转目标</param>
+        /// <returns>电机</returns>
+        public SD_Motor_EulerAngle SetTarget_Angle(Vector3 Vector)
+        {
+            if (MotorActivation) MotorTarget = Vector;
+            MotorTarget = SS_EulerAngleConversion.EulerAngle_PN_To_P360(MotorTarget);
+            return this;
+        }
+
+
+        /// <summary>
+        /// 设置电机旋转目标向量
+        /// </summary>
+        /// <param name="Vector">旋转目标角度向量</param>
+        /// <returns>电机</returns>
+        public SD_Motor_EulerAngle SetTarget_Vector(Vector3 Vector)
+        {
+            if (MotorActivation && Vector != Vector3.zero) MotorTarget = SS_EulerAngleConversion.Get_EulerAngle_In_Vector3(Vector);
+            MotorTarget = SS_EulerAngleConversion.EulerAngle_PN_To_P360(MotorTarget);
+            return this;
+        }
+
+
+        #endregion
+
+
+
+        #region 电机运行
+
+
+
+        /// <summary>
+        /// 电机运行 ： 匀速旋转
+        /// </summary>
+        /// <param name="Time_deltaTime">时间参数</param>
+        /// <returns>电机</returns>
+        public SD_Motor_EulerAngle Run_MoveTowardsAngle(float Time_deltaTime)
+        {
+            MotorSave = SS_Rotation.EulerAngles_MoveTowards(MotorSave, MotorTarget, MotorSpeed * Time_deltaTime);
+            return this;
+        }
+
+        /// <summary>
+        /// 电机运行 ： 差值旋转
+        /// </summary>
+        /// <param name="Time_deltaTime">时间参数</param>
+        /// <returns>电机</returns>
+        public SD_Motor_EulerAngle Run_LerpAngle(float Time_deltaTime)
+        {
+            MotorSave = SS_Rotation.EulerAngles_Lerp(MotorSave, MotorTarget, MotorSpeed * Time_deltaTime);
+            return this;
+        }
+
+        /// <summary>
+        /// 电机运行 ： 平滑旋转
+        /// </summary>
+        /// <returns>电机</returns>
+        public SD_Motor_EulerAngle Run_SmoothDampAngle()
+        {
+            MotorSave = SS_Rotation.EulerAngles_SmoothDamp(MotorSave, MotorTarget, ref MotorVelocity, MotorSpeed);
+            return this;
+        }
+
+        //===[自轴旋转]======
+        /// <summary>
+        /// 电机运行：欧拉角操控式自转（相对于自身坐标系的轴旋转）
+        /// </summary>
+        /// <param name="OriginEulerAngle">物体欧拉角（transform.eulerAngles）</param>
+        /// <param name="direction">方向（Vector3.up）</param>
+        /// <param name="Time_deltaTime">时间参数</param>
+        /// <returns>return : 电机组件</returns>
+        public SD_Motor_EulerAngle Run_ShaftControlled(Vector3 OriginEulerAngle, Vector3 direction, float Time_deltaTime)
+        {
+            if (MotorActivation)
+            {
+                MotorSave = SS_Rotation.EulerAngles_AxisRotation(OriginEulerAngle, direction * MotorSpeed * Time_deltaTime);
+            }
+            return this;
+        }
+
+
+
+        #endregion
+
+
+
+        #region 限制器
+
+
+
+        /// <summary>
+        /// 旋转限制器 ： 本地限制【注：需要限制数值】
+        /// </summary>
+        /// <returns>电机</returns>
+        public SD_Motor_EulerAngle Constraint_Angle_Local()
+        {
+            if (MotorConstraint) MotorSave = SS_Mathf.Clamp_EulerAngle(MotorSave, Limit_Min, Limit_Max, Constraint_X, Constraint_Y, Constraint_Z);
+            return this;
+        }
+
+        /// <summary>
+        /// 旋转限制器 ： 本地范围限制 【注：需要自由半径值】
+        /// </summary>
+        /// <returns>电机</returns>
+        public SD_Motor_EulerAngle Constraint_Angle_Local_Scope()
+        {
+            if (MotorConstraint) MotorSave = SS_Mathf.Clamp_EulerAngle(MotorSave, -Limit_RadiusFree, Limit_RadiusFree, Constraint_X, Constraint_Y, Constraint_Z);
+            return this;
+        }
+
+        /// <summary>
+        /// 旋转限制器 ： 本地全面角度限制【注：需要限制数值】
+        /// </summary>
+        /// <returns>电机</returns>
+        public SD_Motor_EulerAngle Constraint_Angle_Complete_Local()
+        {
+            if (MotorConstraint) MotorSave = SS_Mathf.Clamp_EulerAngle_Complete(MotorSave, Limit_Min, Limit_Max, Constraint_X, Constraint_Y, Constraint_Z);
+            return this;
+        }
+
+        /// <summary>
+        /// 旋转限制器 ： 目标限制【注：需要限制数值】
+        /// </summary>
+        /// <returns>电机</returns>
+        public SD_Motor_EulerAngle Constraint_Angle_Target()
+        {
+            if (MotorConstraint) MotorSave = SS_Mathf.Clamp_EulerAngle_Complete(MotorSave, MotorTarget + Limit_Min, MotorTarget + Limit_Max, Constraint_X, Constraint_Y, Constraint_Z);
+            return this;
+        }
+
+        /// <summary>
+        /// 旋转限制器 ： 目标范围限制【注：需要自由半径值】
+        /// </summary>
+        /// <returns>电机</returns>
+        public SD_Motor_EulerAngle Constraint_Angle_Target_Scope()
+        {
+            if (MotorConstraint) MotorSave = SS_Mathf.Clamp_EulerAngle_Complete_Scope(MotorSave, MotorTarget, Limit_RadiusFree, Constraint_X, Constraint_Y, Constraint_Z);
+            return this;
+        }
+
+        #endregion
+
+
+
+        #region 数值获取
+
+
+
+        /// <summary>
+        /// 获取电机当前角度
+        /// </summary>
+        /// <returns>return : 电机角度</returns>
+        public Vector3 Get_MotorSave()
+        {
+            return MotorSave;
+        }
+
+        /// <summary>
+        /// 判断电机旋转完成
+        /// </summary>
+        /// <param name="Deviation">偏差值</param>
+        /// <returns>bool</returns>
+        public bool If_MotorSpinFinish(float Deviation)
+        {
+            return Mathf.Abs(Vector3.Angle(MotorTarget, MotorSave)) < Deviation;
+        }
+
+
+
+        #endregion
+
+
+
+    }
+
+}
diff --git a/SDHK_Tool/Dynamic/Motor/SD_Motor_EulerAngle.cs.meta b/SDHK_Tool/Dynamic/Motor/SD_Motor_EulerAngle.cs.meta
new file mode 100644
index 0000000..868827c
--- /dev/null
+++ b/SDHK_Tool/Dynamic/Motor/SD_Motor_EulerAngle.cs.meta
@@ -0,0 +1,13 @@
+fileFormatVersion: 2
+guid: d18b1850495bee84586e85d506c9dbc3
+timeCreated: 1560753009
+licenseType: Free
+MonoImporter:
+  externalObjects: {}
+  serializedVersion: 2
+  defaultReferences: []
+  executionOrder: 0
+  icon: {instanceID: 0}
+  userData: 
+  assetBundleName: 
+  assetBundleVariant: 
diff --git a/SDHK_Tool/Dynamic/Motor/SD_Motor_Vector1.cs b/SDHK_Tool/Dynamic/Motor/SD_Motor_Vector1.cs
new file mode 100644
index 0000000..d12ae2f
--- /dev/null
+++ b/SDHK_Tool/Dynamic/Motor/SD_Motor_Vector1.cs
@@ -0,0 +1,306 @@
+﻿using UnityEngine;
+using SDHK_Tool.Static;
+
+/*
+ * 作者：闪电Y黑客
+ * 
+ * 日期： 2019.6.16
+ * 
+ * 功能：集合移动方法
+ */
+
+namespace SDHK_Tool.Dynamic
+{
+
+    /// <summary>
+    /// 一维移动电机
+    /// </summary>
+    public class SD_Motor_Vector1
+    {
+        /// <summary>
+        /// 电机激活
+        /// </summary>
+        public bool MotorActivation = true;
+        /// <summary>
+        /// 电机速度
+        /// </summary>
+        public float MotorSpeed = 10;
+        /// <summary>
+        /// 限制器激活
+        /// </summary>
+        public bool MotorConstraint = false;
+        /// <summary>
+        /// 限制数：最小限制
+        /// </summary>
+        public float Limit_Min = 0;
+        /// <summary>
+        /// 限制数：最大限制
+        /// </summary>
+        public float Limit_Max = 0;
+        /// <summary>
+        /// 范围半径限制【用于范围限制】
+        /// </summary>
+        public float Limit_Radius = 0;
+        /// <summary>
+        /// 目标位置
+        /// </summary>
+        public float MotorTarget;
+        /// <summary>
+        /// 电机运行后的位置
+        /// </summary>
+        public float MotorSave;
+        /// <summary>
+        /// 平滑运行返回的速度
+        /// </summary>
+        public float MotorVelocity;
+
+
+
+        #region 数值赋值
+
+
+
+        /// <summary>
+        /// 设置电机激活
+        /// </summary>
+        /// <param name="Activation">激活</param>
+        /// <returns>电机</returns>
+        public SD_Motor_Vector1 Set_MotorActivation(bool Activation)
+        {
+            MotorActivation = Activation;
+            return this;
+        }
+
+        /// <summary>
+        /// 设置限制器激活
+        /// </summary>
+        /// <param name="Constraint">激活</param>
+        /// <returns>电机</returns>
+        public SD_Motor_Vector1 Set_MotorConstraint(bool Constraint)
+        {
+            MotorConstraint = Constraint;
+            return this;
+        }
+
+        /// <summary>
+        /// 设置电机限制半径
+        /// </summary>
+        /// <param name="Radius">半径值</param>
+        /// <returns>电机</returns>
+        public SD_Motor_Vector1 Set_MotorConstraint_Radius(float Radius)
+        {
+            Limit_Radius = Radius;
+            return this;
+        }
+
+        /// <summary>
+        /// 设置电机限制值
+        /// </summary>
+        /// <param name="Limit_Min">最小值</param>
+        /// <param name="Limit_Max">最大值</param>
+        /// <returns>电机</returns>
+        public SD_Motor_Vector1 Set_MotorConstraint_Limit(float Limit_Min, float Limit_Max)
+        {
+            this.Limit_Min = Limit_Min;
+            this.Limit_Max = Limit_Max;
+            return this;
+        }
+
+        /// <summary>
+        /// 设置电机速度
+        /// </summary>
+        /// <param name="Speed">速度值</param>
+        /// <returns>电机</returns>
+        public SD_Motor_Vector1 Set_MotorSpeed(float Speed)
+        {
+            MotorSpeed = Speed;
+            return this;
+        }
+
+
+        /// <summary>
+        /// 设置电机目标和位置
+        /// </summary>
+        /// <param name="Value">值</param>
+        /// <returns>电机</returns>
+        public SD_Motor_Vector1 Set_MotorValue(float Value)
+        {
+            MotorTarget = Value;
+            MotorSave = Value;
+            return this;
+        }
+
+
+
+        #endregion
+
+
+
+        #region 电机操控
+
+
+
+        /// <summary>
+        /// 设置电机移动差值
+        /// </summary>
+        /// <param name="VectorDelta">移动差值</param>
+        /// <returns>电机</returns>
+        public SD_Motor_Vector1 SetTarget_VectorDelta(float VectorDelta)
+        {
+            if (MotorActivation) MotorTarget += VectorDelta;
+            return this;
+        }
+
+        /// <summary>
+        /// 设置电机移动目标
+        /// </summary>
+        /// <param name="Vector">移动目标</param>
+        /// <returns>电机</returns>
+        public SD_Motor_Vector1 SetTarget_Vector(float Vector)
+        {
+            if (MotorActivation) MotorTarget = Vector;
+            return this;
+        }
+
+        /// <summary>
+        /// 设置电机位置
+        /// </summary>
+        /// <param name="Vector">位置值</param>
+        /// <returns>电机</returns>
+        public SD_Motor_Vector1 Set_MotorSave(float Value)
+        {
+            MotorSave = Value;
+            return this;
+        }
+
+
+
+        #endregion
+
+
+
+        #region 电机运行
+
+
+
+        /// <summary>
+        /// 电机运行 ： 匀速移动
+        /// </summary>
+        /// <param name="Time_deltaTime">时间参数</param>
+        /// <returns>电机</returns>
+        public SD_Motor_Vector1 Run_MoveTowards(float Time_deltaTime)
+        {
+            MotorSave = Mathf.MoveTowards(MotorSave, MotorTarget, MotorSpeed * Time_deltaTime);
+            return this;
+        }
+
+        /// <summary>
+        /// 电机运行 ： 差值移动
+        /// </summary>
+        /// <param name="Time_deltaTime">时间参数</param>
+        /// <returns>电机</returns>
+        public SD_Motor_Vector1 Run_Lerp(float Time_deltaTime)
+        {
+            MotorSave = Mathf.Lerp(MotorSave, MotorTarget, MotorSpeed * Time_deltaTime);
+            return this;
+        }
+
+        /// <summary>
+        /// 电机运行 ： 平滑移动
+        /// </summary>
+        /// <returns>电机</returns>
+        public SD_Motor_Vector1 Run_SmoothDamp()
+        {
+            MotorSave = Mathf.SmoothDamp(MotorSave, MotorTarget, ref MotorVelocity, MotorSpeed);
+            return this;
+        }
+
+
+
+        #endregion 
+
+
+
+        #region 限制器
+
+
+
+        /// <summary>
+        /// 移动限制器 ： 本地限制【注：需要限制数值】
+        /// </summary>
+        /// <returns>电机</returns>
+        public SD_Motor_Vector1 Constraint_Vector_Local()
+        {
+            if (MotorConstraint) MotorSave = SS_Mathf.Clamp_Vector1(MotorSave, Limit_Min, Limit_Max);
+            return this;
+        }
+
+        /// <summary>
+        /// 移动限制器 ： 本地范围限制【注：需要半径值】
+        /// </summary>
+        /// <returns>电机</returns>
+        public SD_Motor_Vector1 Constraint_Vector_Local_Scope()
+        {
+            if (MotorConstraint) MotorSave = SS_Mathf.Clamp_Vector1_Scope(MotorSave, 0, Limit_Radius);
+            return this;
+        }
+
+        /// <summary>
+        /// 移动限制器 ： 目标限制【注：需要限制数值】
+        /// </summary>
+        /// <returns>电机</returns>
+        public SD_Motor_Vector1 Constraint_Vector_Target()
+        {
+            if (MotorConstraint) MotorSave = SS_Mathf.Clamp_Vector1(MotorSave, MotorTarget + Limit_Min, MotorTarget + Limit_Max);
+            return this;
+        }
+
+        /// <summary>
+        /// 移动限制器 ： 目标范围限制【注：需要半径值】
+        /// </summary>
+        /// <returns>电机</returns>
+        public SD_Motor_Vector1 Constraint_Vector_Target_Scope()
+        {
+            if (MotorConstraint) MotorSave = SS_Mathf.Clamp_Vector1_Scope(MotorSave, MotorTarget, Limit_Radius);
+            return this;
+        }
+
+
+
+        #endregion
+
+
+
+        #region 数值获取
+
+
+
+        /// <summary>
+        /// 获取电机当前位置
+        /// </summary>
+        /// <returns>return : 电机位置</returns>
+        public float Get_MotorSave()
+        {
+            return MotorSave;
+        }
+
+        /// <summary>
+        /// 判断电机运行完成
+        /// </summary>
+        /// <param name="Deviation">偏差值</param>
+        /// <returns>bool</returns>
+        public bool If_MotorRunFinish(float Deviation)
+        {
+            return Mathf.Abs(MotorTarget - MotorSave) < Deviation;
+        }
+
+
+
+        #endregion
+
+
+
+    }
+
+}
+
diff --git a/SDHK_Tool/Dynamic/Motor/SD_Motor_Vector1.cs.meta b/SDHK_Tool/Dynamic/Motor/SD_Motor_Vector1.cs.meta
new file mode 100644
index 0000000..7004faa
--- /dev/null
+++ b/SDHK_Tool/Dynamic/Motor/SD_Motor_Vector1.cs.meta
@@ -0,0 +1,13 @@
+fileFormatVersion: 2
+guid: 6e922051504bede459b47c16282ce8b4
+timeCreated: 1560416864
+licenseType: Free
+MonoImporter:
+  externalObjects: {}
+  serializedVersion: 2
+  defaultReferences: []
+  executionOrder: 0
+  icon: {instanceID: 0}
+  userData: 
+  assetBundleName: 
+  assetBundleVariant: 
diff --git a/SDHK_Tool/Dynamic/Motor/SD_Motor_Vector2.cs b/SDHK_Tool/Dynamic/Motor/SD_Motor_Vector2.cs
new file mode 100644
index 0000000..5aa3a6d
--- /dev/null
+++ b/SDHK_Tool/Dynamic/Motor/SD_Motor_Vector2.cs
@@ -0,0 +1,398 @@
+﻿using UnityEngine;
+using SDHK_Tool.Static;
+
+/*
+ * 作者：闪电Y黑客
+ * 
+ * 日期： 2019.6.16
+ * 
+ * 功能：集合二维移动方法
+ */
+
+namespace SDHK_Tool.Dynamic
+{
+
+    /// <summary>
+    /// 二维移动电机
+    /// </summary>
+    public class SD_Motor_Vector2
+    {
+
+        /// <summary>
+        /// 电机激活
+        /// </summary>
+        public bool MotorActivation = true;
+        /// <summary>
+        /// 电机速度
+        /// </summary>
+        public float MotorSpeed = 10;
+        /// <summary>
+        /// 限制器激活
+        /// </summary>
+        public bool MotorConstraint = false;
+
+        /// <summary>
+        /// 限制X轴激活
+        /// </summary>
+        public bool Constraint_X = true;
+        /// <summary>
+        /// 限制Y轴激活
+        /// </summary>
+        public bool Constraint_Y = true;
+
+
+        /// <summary>
+        /// 限制数：最小限制
+        /// </summary>
+        public Vector2 Limit_Min = Vector2.zero;
+        /// <summary>
+        /// 限制数：最大限制
+        /// </summary>
+        public Vector2 Limit_Max = Vector2.zero;
+        /// <summary>
+        /// 范围半径限制【用于范围限制】
+        /// </summary>
+        public float Limit_Radius = 0;
+        /// <summary>
+        /// 范围自由半径限制【用于自定义范围限制】
+        /// </summary>
+        public Vector2 Limit_RadiusFree = Vector2.zero;
+        /// <summary>
+        /// 目标位置
+        /// </summary>
+        public Vector2 MotorTarget;
+        /// <summary>
+        /// 电机运行后的位置
+        /// </summary>
+        public Vector2 MotorSave;
+        /// <summary>
+        /// 平滑运行返回的速度
+        /// </summary>
+        public Vector2 MotorVelocity;
+
+
+
+        #region 数值赋值
+
+
+
+        /// <summary>
+        /// 设置电机激活
+        /// </summary>
+        /// <param name="Activation">激活</param>
+        /// <returns>电机</returns>
+        public SD_Motor_Vector2 Set_MotorActivation(bool Activation)
+        {
+            MotorActivation = Activation;
+            return this;
+        }
+
+        /// <summary>
+        /// 设置限制器激活
+        /// </summary>
+        /// <param name="Constraint">激活</param>
+        /// <returns>电机</returns>
+        public SD_Motor_Vector2 Set_MotorConstraint(bool Constraint)
+        {
+            MotorConstraint = Constraint;
+            return this;
+        }
+
+        /// <summary>
+        /// 设置限制轴激活
+        /// </summary>
+        /// <param name="Constraint_Shaft">轴激活</param>
+        /// <returns>电机</returns>
+        public SD_Motor_Vector2 Set_MotorConstraint_Shaft(bool X = true, bool Y = true)
+        {
+            Constraint_X = X;
+            Constraint_Y = Y;
+
+            return this;
+        }
+
+        /// <summary>
+        /// 设置电机限制半径
+        /// </summary>
+        /// <param name="Radius">半径值</param>
+        /// <returns>电机</returns>
+        public SD_Motor_Vector2 Set_MotorConstraint_Radius(float Radius)
+        {
+            Limit_Radius = Radius;
+            return this;
+        }
+
+        /// <summary>
+        /// 设置电机限制半径（自由半径）
+        /// </summary>
+        /// <param name="Radius">半径值</param>
+        /// <returns>电机</returns>
+        public SD_Motor_Vector2 Set_MotorConstraint_Radius(Vector2 RadiusFree)
+        {
+            Limit_RadiusFree = RadiusFree;
+            return this;
+        }
+
+        /// <summary>
+        /// 设置电机限制值
+        /// </summary>
+        /// <param name="Limit_Min">最小值</param>
+        /// <param name="Limit_Max">最大值</param>
+        /// <returns>电机</returns>
+        public SD_Motor_Vector2 Set_MotorConstraint_Limit(Vector2 Limit_Min, Vector2 Limit_Max)
+        {
+            this.Limit_Min = Limit_Min;
+            this.Limit_Max = Limit_Max;
+            return this;
+        }
+
+        /// <summary>
+        /// 设置电机速度
+        /// </summary>
+        /// <param name="Speed">速度值</param>
+        /// <returns>电机</returns>
+        public SD_Motor_Vector2 Set_MotorSpeed(float Speed)
+        {
+            MotorSpeed = Speed;
+            return this;
+        }
+
+        /// <summary>
+        /// 设置电机目标
+        /// </summary>
+        /// <param name="Value">目标值</param>
+        /// <returns>电机</returns>
+        public SD_Motor_Vector2 Set_MotorTarget(Vector2 Value)
+        {
+            MotorTarget = Value;
+            return this;
+        }
+
+        /// <summary>
+        /// 设置电机位置
+        /// </summary>
+        /// <param name="Value">位置值</param>
+        /// <returns>电机</returns>
+        public SD_Motor_Vector2 Set_MotorSave(Vector2 Value)
+        {
+            MotorSave = Value;
+            return this;
+        }
+
+        /// <summary>
+        /// 设置电机目标和位置
+        /// </summary>
+        /// <param name="Value">值</param>
+        /// <returns>电机</returns>
+        public SD_Motor_Vector2 Set_MotorValue(Vector2 Value)
+        {
+            MotorTarget = Value;
+            MotorSave = Value;
+            return this;
+        }
+
+
+
+        #endregion
+
+
+
+        #region 电机操控
+
+
+
+        /// <summary>
+        /// 设置电机移动差值
+        /// </summary>
+        /// <param name="VectorDelta">移动差值</param>
+        /// <returns>电机</returns>
+        public SD_Motor_Vector2 SetTarget_VectorDelta(Vector2 VectorDelta)
+        {
+            if (MotorActivation) MotorTarget += VectorDelta;
+            return this;
+        }
+
+        /// <summary>
+        /// 设置电机移动目标
+        /// </summary>
+        /// <param name="Vector">移动目标</param>
+        /// <returns>电机</returns>
+        public SD_Motor_Vector2 SetTarget_Vector(Vector2 Vector)
+        {
+            if (MotorActivation) MotorTarget = Vector;
+            return this;
+        }
+
+
+
+        #endregion
+
+
+
+        #region 电机运行
+
+
+
+        /// <summary>
+        /// 电机运行 ： 匀速移动（速度越大越快，需要较大的值）
+        /// </summary>
+        /// <param name="Time_deltaTime">时间参数</param>
+        /// <returns>电机</returns>
+        public SD_Motor_Vector2 Run_MoveTowards(float Time_deltaTime)
+        {
+            MotorSave = Vector2.MoveTowards(MotorSave, MotorTarget, MotorSpeed * Time_deltaTime);
+            return this;
+        }
+
+        /// <summary>
+        /// 电机运行 ： 差值移动（速度越大越快）
+        /// </summary>
+        /// <param name="Time_deltaTime">时间参数</param>
+        /// <returns>电机</returns>
+        public SD_Motor_Vector2 Run_Lerp(float Time_deltaTime)
+        {
+            MotorSave = Vector2.Lerp(MotorSave, MotorTarget, MotorSpeed * Time_deltaTime);
+            return this;
+        }
+
+        /// <summary>
+        /// 电机运行 ： 平滑移动（速度越小越快）
+        /// </summary>
+        /// <param name="Time_deltaTime">时间参数</param>
+        /// <returns>电机</returns>
+        public SD_Motor_Vector2 Run_SmoothDamp(float Time_deltaTime)
+        {
+            MotorSave = Vector2.SmoothDamp(MotorSave, MotorTarget, ref MotorVelocity, MotorSpeed, Mathf.Infinity, Time_deltaTime);
+            return this;
+        }
+
+        //===[自轴移动]======
+        /// <summary>
+        /// 电机运行：自轴移动操控式（相对于自身坐标系的轴移动）
+        /// </summary>
+        /// <param name="Origin">物体位置（transform.position）</param>
+        /// <param name="direction">方向（transform.forward为正前方）</param>
+        /// <param name="Time_deltaTime">时间参数</param>
+        /// <returns>return : 电机组件</returns>
+        public SD_Motor_Vector2 Run_ShaftDelta(Vector2 Origin, Vector2 direction, float Time_deltaTime)
+        {
+            if (MotorActivation)
+            {
+                MotorSave = Origin + direction * MotorSpeed * Time_deltaTime;
+            }
+            return this;
+        }
+
+
+
+        #endregion
+
+
+
+        #region 限制器
+
+
+
+        /// <summary>
+        /// 移动限制器 ： 本地限制【注：需要限制数值】
+        /// </summary>
+        /// <returns>电机</returns>
+        public SD_Motor_Vector2 Constraint_Vector_Local()
+        {
+            if (MotorConstraint)MotorSave = SS_Mathf.Clamp_Vector2(MotorSave, Limit_Min, Limit_Max, Constraint_X, Constraint_Y);
+                // else 软回弹
+                // {
+                //     MotorTarget = SS_VectorConstraint.Constraint_Vector2(MotorTarget, Limit_Min, Limit_Max, Constraint_X, Constraint_Y);
+                // }
+                
+            return this;
+        }
+
+        /// <summary>
+        /// 移动限制器 ： 本地范围限制(圆形范围限制)【注：需要半径值】
+        /// </summary>
+        /// <returns>电机</returns>
+        public SD_Motor_Vector2 Constraint_Vector_Local_Scope()
+        {
+            if (MotorConstraint) MotorSave = SS_Mathf.Clamp_Vector2_Scope(MotorSave, Vector2.zero, Limit_Radius);
+            return this;
+        }
+
+        /// <summary>
+        /// 移动限制器 ： 本地范围限制（自由范围限制）【注：需要自由半径值】
+        /// </summary>
+        /// <returns>电机</returns>
+        public SD_Motor_Vector2 Constraint_Vector_Local_Scope_Free()
+        {
+            if (MotorConstraint) MotorSave = SS_Mathf.Clamp_Vector2(MotorSave, -Limit_RadiusFree, Limit_RadiusFree, Constraint_X, Constraint_Y);
+            return this;
+        }
+
+        /// <summary>
+        /// 移动限制器 ： 目标限制【注：需要限制数值】
+        /// </summary>
+        /// <returns>电机</returns>
+        public SD_Motor_Vector2 Constraint_Vector_Target()
+        {
+            if (MotorConstraint) MotorSave = SS_Mathf.Clamp_Vector2(MotorSave, MotorTarget + Limit_Min, MotorTarget + Limit_Max, Constraint_X, Constraint_Y);
+            return this;
+        }
+
+        /// <summary>
+        /// 移动限制器 ： 目标范围限制（圆形半径范围限制）【注：需要半径值】
+        /// </summary>
+        /// <returns>电机</returns>
+        public SD_Motor_Vector2 Constraint_Vector_Target_Scope()
+        {
+            if (MotorConstraint) MotorSave = SS_Mathf.Clamp_Vector2_Scope(MotorSave, MotorTarget, Limit_Radius);
+            return this;
+        }
+
+        /// <summary>
+        /// 移动限制器 ： 目标范围限制（自由半径范围限制）【注：需要自由半径值】
+        /// </summary>
+        /// <returns>电机</returns>
+        public SD_Motor_Vector2 Constraint_Vector_Target_Scope_Free()
+        {
+            if (MotorConstraint) MotorSave = SS_Mathf.Clamp_Vector2(MotorSave, MotorTarget - Limit_RadiusFree, MotorTarget + Limit_RadiusFree, Constraint_X, Constraint_Y);
+            return this;
+        }
+
+
+
+        #endregion
+
+
+
+        #region 数值获取
+
+
+
+        /// <summary>
+        /// 获取电机当前位置
+        /// </summary>
+        /// <returns>return : 电机位置</returns>
+        public Vector2 Get_MotorSave()
+        {
+            return MotorSave;
+        }
+
+        /// <summary>
+        /// 判断电机运行完成
+        /// </summary>
+        /// <param name="Deviation">偏差值</param>
+        /// <returns>bool</returns>
+        public bool If_MotorRunFinish(float Deviation)
+        {
+            return (MotorTarget - MotorSave).magnitude < Deviation;
+        }
+
+
+
+        #endregion
+
+
+    }
+
+
+}
\ No newline at end of file
diff --git a/SDHK_Tool/Dynamic/Motor/SD_Motor_Vector2.cs.meta b/SDHK_Tool/Dynamic/Motor/SD_Motor_Vector2.cs.meta
new file mode 100644
index 0000000..68f7850
--- /dev/null
+++ b/SDHK_Tool/Dynamic/Motor/SD_Motor_Vector2.cs.meta
@@ -0,0 +1,13 @@
+fileFormatVersion: 2
+guid: b5b8f96de178c72488ee1cf5f835f391
+timeCreated: 1560737845
+licenseType: Free
+MonoImporter:
+  externalObjects: {}
+  serializedVersion: 2
+  defaultReferences: []
+  executionOrder: 0
+  icon: {instanceID: 0}
+  userData: 
+  assetBundleName: 
+  assetBundleVariant: 
diff --git a/SDHK_Tool/Dynamic/Motor/SD_Motor_Vector3.cs b/SDHK_Tool/Dynamic/Motor/SD_Motor_Vector3.cs
new file mode 100644
index 0000000..b4c87c0
--- /dev/null
+++ b/SDHK_Tool/Dynamic/Motor/SD_Motor_Vector3.cs
@@ -0,0 +1,397 @@
+﻿using UnityEngine;
+using SDHK_Tool.Static;
+
+/*
+ * 作者：闪电Y黑客
+ * 
+ * 日期： 2019.6.16
+ * 
+ * 功能：集合移动方法
+ */
+
+namespace SDHK_Tool.Dynamic
+{
+
+    /// <summary>
+    /// 三维移动电机
+    /// </summary>
+    public class SD_Motor_Vector3
+    {
+
+        /// <summary>
+        /// 电机激活
+        /// </summary>
+        public bool MotorActivation = true;
+        /// <summary>
+        /// 电机速度
+        /// </summary>
+        public float MotorSpeed = 10;
+        /// <summary>
+        /// 限制器激活
+        /// </summary>
+        public bool MotorConstraint = false;
+        /// <summary>
+        /// 限制X轴激活
+        /// </summary>
+        public bool Constraint_X = true;
+        /// <summary>
+        /// 限制Y轴激活
+        /// </summary>
+        public bool Constraint_Y = true;
+        /// <summary>
+        /// 限制Z轴激活
+        /// </summary>
+        public bool Constraint_Z = true;
+
+        /// <summary>
+        /// 限制数：最小限制
+        /// </summary>
+        public Vector3 Limit_Min = Vector3.zero;
+        /// <summary>
+        /// 限制数：最大限制
+        /// </summary>
+        public Vector3 Limit_Max = Vector3.zero;
+        /// <summary>
+        /// 范围半径限制【用于范围限制】
+        /// </summary>
+        public float Limit_Radius = 0;
+        /// <summary>
+        /// 范围自由半径限制【用于自定义范围限制】
+        /// </summary>
+        public Vector3 Limit_RadiusFree = Vector3.zero;
+        /// <summary>
+        /// 目标位置
+        /// </summary>
+        public Vector3 MotorTarget;
+        /// <summary>
+        /// 电机运行后的位置
+        /// </summary>
+        public Vector3 MotorSave;
+        /// <summary>
+        /// 平滑运行返回的速度
+        /// </summary>
+        public Vector3 MotorVelocity;
+
+
+
+        #region 数值赋值
+
+
+
+        /// <summary>
+        /// 设置电机激活
+        /// </summary>
+        /// <param name="Activation">激活</param>
+        /// <returns>电机</returns>
+        public SD_Motor_Vector3 Set_MotorActivation(bool Activation)
+        {
+            MotorActivation = Activation;
+            return this;
+        }
+
+        /// <summary>
+        /// 设置限制器激活
+        /// </summary>
+        /// <param name="Constraint">激活</param>
+        /// <returns>电机</returns>
+        public SD_Motor_Vector3 Set_MotorConstraint(bool Constraint)
+        {
+            MotorConstraint = Constraint;
+            return this;
+        }
+
+        /// <summary>
+        /// 设置限制轴激活
+        /// </summary>
+        /// <param name="Constraint_Shaft">轴激活</param>
+        /// <returns>电机</returns>
+        public SD_Motor_Vector3 Set_MotorConstraint_Shaft(bool X = true, bool Y = true, bool Z = true)
+        {
+
+            Constraint_X = X;
+            Constraint_Y = Y;
+            Constraint_Z = Z;
+
+            return this;
+        }
+
+        /// <summary>
+        /// 设置电机限制半径
+        /// </summary>
+        /// <param name="Radius">半径值</param>
+        /// <returns>电机</returns>
+        public SD_Motor_Vector3 Set_MotorConstraint_Radius(float Radius)
+        {
+            Limit_Radius = Radius;
+            return this;
+        }
+
+        /// <summary>
+        /// 设置电机限制半径（自由半径）
+        /// </summary>
+        /// <param name="Radius">半径值</param>
+        /// <returns>电机</returns>
+        public SD_Motor_Vector3 Set_MotorConstraint_Radius(Vector3 RadiusFree)
+        {
+            Limit_RadiusFree = RadiusFree;
+            return this;
+        }
+
+        /// <summary>
+        /// 设置电机限制值
+        /// </summary>
+        /// <param name="Limit_Min">最小值</param>
+        /// <param name="Limit_Max">最大值</param>
+        /// <returns>电机</returns>
+        public SD_Motor_Vector3 Set_MotorConstraint_Limit(Vector3 Limit_Min, Vector3 Limit_Max)
+        {
+            this.Limit_Min = Limit_Min;
+            this.Limit_Max = Limit_Max;
+            return this;
+        }
+
+        /// <summary>
+        /// 设置电机速度
+        /// </summary>
+        /// <param name="Speed">速度值</param>
+        /// <returns>电机</returns>
+        public SD_Motor_Vector3 Set_MotorSpeed(float Speed)
+        {
+            MotorSpeed = Speed;
+            return this;
+        }
+
+        /// <summary>
+        /// 设置电机目标
+        /// </summary>
+        /// <param name="Value">目标值</param>
+        /// <returns>电机</returns>
+        public SD_Motor_Vector3 Set_MotorTarget(Vector3 Value)
+        {
+            MotorTarget = Value;
+            return this;
+        }
+
+        /// <summary>
+        /// 设置电机位置
+        /// </summary>
+        /// <param name="Value">位置值</param>
+        /// <returns>电机</returns>
+        public SD_Motor_Vector3 Set_MotorSave(Vector3 Value)
+        {
+            MotorSave = Value;
+            return this;
+        }
+
+        /// <summary>
+        /// 设置电机目标和位置
+        /// </summary>
+        /// <param name="Value">值</param>
+        /// <returns>电机</returns>
+        public SD_Motor_Vector3 Set_MotorValue(Vector3 Value)
+        {
+            MotorTarget = Value;
+            MotorSave = Value;
+            return this;
+        }
+
+
+
+        #endregion
+
+
+
+        #region 电机操控
+
+
+
+        /// <summary>
+        /// 设置电机移动差值
+        /// </summary>
+        /// <param name="VectorDelta">移动差值</param>
+        /// <returns>电机</returns>
+        public SD_Motor_Vector3 SetTarget_VectorDelta(Vector3 VectorDelta)
+        {
+            if (MotorActivation) MotorTarget += VectorDelta;
+            return this;
+        }
+
+        /// <summary>
+        /// 设置电机移动目标
+        /// </summary>
+        /// <param name="Vector">移动目标</param>
+        /// <returns>电机</returns>
+        public SD_Motor_Vector3 SetTarget_Vector(Vector3 Vector)
+        {
+            if (MotorActivation) MotorTarget = Vector;
+            return this;
+        }
+
+
+
+        #endregion
+
+
+
+
+        #region 电机运行
+
+        /// <summary>
+        /// 电机运行 ： 匀速移动（速度越大越快，需要较大的值）
+        /// </summary>
+        /// <param name="Time_deltaTime">时间参数</param>
+        /// <returns>电机</returns>
+        public SD_Motor_Vector3 Run_MoveTowards(float Time_deltaTime)
+        {
+            MotorSave = Vector3.MoveTowards(MotorSave, MotorTarget, MotorSpeed * Time_deltaTime);
+            return this;
+        }
+
+        /// <summary>
+        /// 电机运行 ： 差值移动（速度越大越快）
+        /// </summary>
+        /// <param name="Time_deltaTime">时间参数</param>
+        /// <returns>电机</returns>
+        public SD_Motor_Vector3 Run_Lerp(float Time_deltaTime)
+        {
+            MotorSave = Vector3.Lerp(MotorSave, MotorTarget, MotorSpeed * Time_deltaTime);
+            return this;
+        }
+
+        /// <summary>
+        /// 电机运行 ： 平滑移动（速度越小越快）
+        /// </summary>
+        /// <returns>电机</returns>
+        public SD_Motor_Vector3 Run_SmoothDamp()
+        {
+            MotorSave = Vector3.SmoothDamp(MotorSave, MotorTarget, ref MotorVelocity, MotorSpeed);
+            return this;
+        }
+
+        //===[自轴移动]======
+        /// <summary>
+        /// 电机运行：自轴移动操控式（相对于自身坐标系的轴移动）
+        /// </summary>
+        /// <param name="Origin">物体位置（transform.position）</param>
+        /// <param name="direction">方向（transform.forward为正前方）</param>
+        /// <param name="Time_deltaTime">时间参数</param>
+        /// <returns>return : 电机组件</returns>
+        public SD_Motor_Vector3 Run_ShaftDelta(Vector3 Origin, Vector3 direction, float Time_deltaTime)
+        {
+            if (MotorActivation)
+            {
+                MotorSave = Origin + direction * MotorSpeed * Time_deltaTime;
+            }
+            return this;
+        }
+
+
+
+        #endregion 
+
+
+
+        #region 限制器
+
+
+
+        /// <summary>
+        /// 移动限制器 ： 本地限制【注：需要限制数值】
+        /// </summary>
+        /// <returns>电机</returns>
+        public SD_Motor_Vector3 Constraint_Vector_Local()
+        {
+            if (MotorConstraint) MotorSave = SS_Mathf.Clamp_Vector3(MotorSave, Limit_Min, Limit_Max, Constraint_X, Constraint_Y, Constraint_Z);
+            return this;
+        }
+
+        /// <summary>
+        /// 移动限制器 ： 本地范围限制(球形范围限制)【注：需要半径值】
+        /// </summary>
+        /// <returns>电机</returns>
+        public SD_Motor_Vector3 Constraint_Vector_Local_Scope()
+        {
+            if (MotorConstraint) MotorSave = SS_Mathf.Clamp_Vector3_Scope(MotorSave, Vector2.zero, Limit_Radius);
+            return this;
+        }
+
+        /// <summary>
+        /// 移动限制器 ： 本地范围限制（自由范围限制）【注：需要自由半径值】
+        /// </summary>
+        /// <returns>电机</returns>
+        public SD_Motor_Vector3 Constraint_Vector_Local_Scope_Free()
+        {
+            if (MotorConstraint) MotorSave = SS_Mathf.Clamp_Vector3(MotorSave, -Limit_RadiusFree, Limit_RadiusFree, Constraint_X, Constraint_Y, Constraint_Z);
+            return this;
+        }
+
+        /// <summary>
+        /// 移动限制器 ： 目标限制 【注：需要限制数值】
+        /// 注：需要限制范围值
+        /// </summary>
+        /// <returns>电机</returns>
+        public SD_Motor_Vector3 Constraint_Vector_Target()
+        {
+            if (MotorConstraint) MotorSave = SS_Mathf.Clamp_Vector3(MotorSave, MotorTarget + Limit_Min, MotorTarget + Limit_Max, Constraint_X, Constraint_Y, Constraint_Z);
+            return this;
+        }
+
+        /// <summary>
+        /// 移动限制器 ： 目标范围限制（球形半径范围限制）【注：需要半径值】
+        /// 注：需要半径值
+        /// </summary>
+        /// <returns>电机</returns>
+        public SD_Motor_Vector3 Constraint_Vector_Target_Scope()
+        {
+            if (MotorConstraint) MotorSave = SS_Mathf.Clamp_Vector3_Scope(MotorSave, MotorTarget, Limit_Radius);
+            return this;
+        }
+
+        /// <summary>
+        /// 移动限制器 ： 目标范围限制（自由半径范围限制）【注：需要自由半径值】
+        /// </summary>
+        /// <returns>电机</returns>
+        public SD_Motor_Vector3 Constraint_Vector_Target_Scope_Free()
+        {
+            if (MotorConstraint) MotorSave = SS_Mathf.Clamp_Vector3(MotorSave, MotorTarget - Limit_RadiusFree, MotorTarget + Limit_RadiusFree, Constraint_X, Constraint_Y, Constraint_Z);
+            return this;
+        }
+
+
+
+        #endregion
+
+
+
+        #region 数值获取
+
+
+
+        /// <summary>
+        /// 获取电机当前位置
+        /// </summary>
+        /// <returns>return : 电机位置</returns>
+        public Vector3 Get_MotorSave()
+        {
+            return MotorSave;
+        }
+
+        /// <summary>
+        /// 判断电机运行完成
+        /// </summary>
+        /// <param name="Deviation">偏差值</param>
+        /// <returns>bool</returns>
+        public bool If_MotorRunFinish(float Deviation)
+        {
+            return (MotorTarget - MotorSave).magnitude < Deviation;
+        }
+
+
+
+        #endregion
+
+
+
+    }
+
+}
\ No newline at end of file
diff --git a/SDHK_Tool/Dynamic/Motor/SD_Motor_Vector3.cs.meta b/SDHK_Tool/Dynamic/Motor/SD_Motor_Vector3.cs.meta
new file mode 100644
index 0000000..7b29e0f
--- /dev/null
+++ b/SDHK_Tool/Dynamic/Motor/SD_Motor_Vector3.cs.meta
@@ -0,0 +1,13 @@
+fileFormatVersion: 2
+guid: c1cca14c7ffad5b4db4ecb4fbbb2091f
+timeCreated: 1560749597
+licenseType: Free
+MonoImporter:
+  externalObjects: {}
+  serializedVersion: 2
+  defaultReferences: []
+  executionOrder: 0
+  icon: {instanceID: 0}
+  userData: 
+  assetBundleName: 
+  assetBundleVariant: 
diff --git a/SDHK_Tool/Dynamic/NeuralNetwork/PerceptionMachine/SD_PerceptionUnit.cs b/SDHK_Tool/Dynamic/NeuralNetwork/PerceptionMachine/SD_PerceptionUnit.cs
new file mode 100644
index 0000000..a1896ad
--- /dev/null
+++ b/SDHK_Tool/Dynamic/NeuralNetwork/PerceptionMachine/SD_PerceptionUnit.cs
@@ -0,0 +1,125 @@
+﻿using System.Collections;
+using System.Collections.Generic;
+using UnityEngine;
+
+/*
+ * 作者：闪电Y黑客
+ * 
+ * 日期： 2019.12.18
+ * 
+ * 功能：神经网络感知机单元件
+ *
+ * 公式：
+ *
+ *  估算结果 = ( for { 临时结果 += 权重i * 输入i }  + 偏置值 > 阈值 ) ？ 1:0 ;
+ *
+ *  for { 权重i = 权重i + 学习速率 *（ 预期结果 - 估算结果 ）* 输入i };
+ *
+ *  偏置 = 偏置 + 学习速率 *（ 预期结果 - 估算结果 ）;
+ *
+ */
+
+
+
+namespace SDHK_Tool.Dynamic
+{
+    /// <summary>
+    /// 神经网络:感知机单元件
+    /// </summary>
+    public class SD_PerceptionUnit
+    {
+
+        /// <summary>
+        /// 学习速率
+        /// </summary>
+        public float SpeedRate = 0.1f;
+
+        /// <summary>
+        /// 判断阈值
+        /// </summary>
+        public float Threshold = 0.5f;//阈值
+
+        private List<float> Inputs;//输入
+
+        private float Expected_Results;//预期结果
+
+        private float ThresholdResults = 0;//阈值结果
+
+        private float Estimate_Results;//估算结果
+
+        private List<float> weight;//权重
+
+        private float Bias;//偏置值
+
+
+
+        /// <summary>
+        /// 设置：值集合
+        /// </summary>
+        /// <param name="inputs">值集合</param>
+        /// <returns>单元件</returns>
+        public SD_PerceptionUnit Set_Inputs(List<float> inputs)
+        {
+            Inputs = inputs;
+            weight = new List<float>(inputs.Count);
+
+            return this;
+        }
+
+        /// <summary>
+        /// 设置：预期结果
+        /// </summary>
+        /// <param name="expected_Results">预期结果</param>
+        /// <returns>单元件</returns>
+        public SD_PerceptionUnit Set_Output(float expected_Results)
+        {
+            Expected_Results = expected_Results;
+
+            return this;
+        }
+
+        /// <summary>
+        /// 获取：估算结果
+        /// </summary>
+        /// <returns>估算结果</returns>
+		public float Get_Output()
+        {
+            return Estimate_Results;
+        }
+
+        /// <summary>
+        /// 感知机解析
+        /// </summary>
+        /// <returns>单元件</returns>
+        public SD_PerceptionUnit Parsing()//解析
+        {
+            ThresholdResults = Bias;
+
+            for (int i = 0; i < Inputs.Count; i++)
+            {
+                ThresholdResults += Inputs[i] * weight[i];
+            }
+
+            Estimate_Results = (ThresholdResults > Threshold) ? 1 : 0;
+
+            return this;
+        }
+
+        /// <summary>
+        /// 感知机训练
+        /// </summary>
+        /// <returns>单元件</returns>
+        public SD_PerceptionUnit Training()//训练
+        {
+            Parsing();
+
+            for (int i = 0; i < weight.Count; i++)
+            {
+                weight[i] += SpeedRate * (Expected_Results - Estimate_Results) * Inputs[i];
+            }
+            Bias += SpeedRate * (Expected_Results - Estimate_Results);
+            return this;
+        }
+
+    }
+}
\ No newline at end of file
diff --git a/SDHK_Tool/Dynamic/NeuralNetwork/PerceptionMachine/SD_PerceptionUnit.cs.meta b/SDHK_Tool/Dynamic/NeuralNetwork/PerceptionMachine/SD_PerceptionUnit.cs.meta
new file mode 100644
index 0000000..7ec6036
--- /dev/null
+++ b/SDHK_Tool/Dynamic/NeuralNetwork/PerceptionMachine/SD_PerceptionUnit.cs.meta
@@ -0,0 +1,13 @@
+fileFormatVersion: 2
+guid: ef1ae033b6d947a4e9abaac2132ad43c
+timeCreated: 1576668437
+licenseType: Pro
+MonoImporter:
+  externalObjects: {}
+  serializedVersion: 2
+  defaultReferences: []
+  executionOrder: 0
+  icon: {instanceID: 0}
+  userData: 
+  assetBundleName: 
+  assetBundleVariant: 
diff --git a/SDHK_Tool/Dynamic/SD_CompleteTriangle.cs b/SDHK_Tool/Dynamic/SD_CompleteTriangle.cs
new file mode 100644
index 0000000..7e83d14
--- /dev/null
+++ b/SDHK_Tool/Dynamic/SD_CompleteTriangle.cs
@@ -0,0 +1,145 @@
+﻿
+/*
+ * 作者：闪电Y黑客
+ * 
+ * 日期： 2019.6.11
+ * 
+ * 功能：全解三角形
+ */
+
+using SDHK_Tool.Static;
+
+namespace SDHK_Tool.Dynamic
+{
+
+    /// <summary>
+    /// 全解三角形
+    /// </summary>
+    public class SD_CompleteTriangle
+    {
+
+        private float A_Angle = 0;//角
+        private float B_Angle = 0;
+        private float C_Angle = 0;
+        private float A_Edge = 0;//边
+        private float B_Edge = 0;
+        private float C_Edge = 0;
+        private float diameter;//外接圆直径
+        //=================================================
+        /// <summary>
+        /// 返回三角形的角A  [正数]
+        /// </summary>
+        public float GetA_Angle { get { return A_Angle; } }
+        /// <summary>
+        /// 返回三角形的角B  [正数]
+        /// </summary>
+        public float GetB_Angle { get { return B_Angle; } }
+        /// <summary>
+        /// 返回三角形的角C  [正数]
+        /// </summary>
+        public float GetC_Angle { get { return C_Angle; } }
+
+        /// <summary>
+        /// 返回三角形的角A对边
+        /// </summary>
+        public float GetA_Edge { get { return A_Edge; } }
+        /// <summary>
+        /// 返回三角形的角B对边
+        /// </summary>
+        public float GetB_Edge { get { return B_Edge; } }
+        /// <summary>
+        /// 返回三角形的角C对边
+        /// </summary>
+        public float GetC_Edge { get { return C_Edge; } }
+        /// <summary>
+        /// 返回三角形的外接圆直径
+        /// </summary>
+        public float Get_diameter { get { return diameter; } }
+
+        //=[三角形全解]=================================================
+        /// <summary>
+        /// 边边边 :
+        /// 提供 : 三角形的三个边 , 全解三角形
+        /// </summary>
+        /// <param name="A_Edge">角A的对边</param>
+        /// <param name="B_Edge">角B的对边</param>
+        /// <param name="C_Edge">角C的对边</param>
+        /// <returns>SD_CompleteTriangle</returns>
+        public SD_CompleteTriangle SolutionsTriangle_EEE(float A_Edge, float B_Edge, float C_Edge)//只有3边解三角，钝角锐角都可解
+        {
+
+            A_Angle = SS_Mathf.Triangle_Get_A_Angle_EEE(A_Edge, B_Edge, C_Edge);
+            B_Angle = SS_Mathf.Triangle_Get_A_Angle_EEE(B_Edge, A_Edge, C_Edge);
+            C_Angle = SS_Mathf.Triangle_Get_A_Angle_EEE(C_Edge, A_Edge, B_Edge);
+
+            return this;
+        }
+        /// <summary>
+        /// 角边边 :
+        /// 提供 : 一个角和两个边 , 全解三角形
+        /// </summary>
+        /// <param name="A_Angle">角A</param>
+        /// <param name="A_Edge">角A的对边</param>
+        /// <param name="B_Edge">角B的对边</param>
+        /// <param name="B_ObtuseAngle">角B优先解为钝角,一般为false</param>
+        /// <returns>SD_CompleteTriangle</returns>
+        public SD_CompleteTriangle SolutionsTriangle_AEE(float A_Angle, float A_Edge, float B_Edge, bool B_ObtuseAngle)//1角2边解三角，钝角锐角都可解，B_ObtuseAngle钝角优先解
+        {
+
+            diameter = SS_Mathf.Triangle_GetDiameter(A_Angle, A_Edge);
+
+            B_Angle = SS_Mathf.Triangle_GetAngle(B_Edge, diameter);//获得<=90的角
+            C_Angle = 90 - SS_Mathf.Triangle_Get_A_Angle_AAA(90 - A_Angle, B_Angle);//绕一圈获得c角
+            C_Edge = SS_Mathf.Triangle_GetEdge(C_Angle, diameter);//通过角获得边
+            if (A_Angle <= 90 && B_ObtuseAngle)//b为钝角优先解
+            {
+                B_Angle = SS_Mathf.Triangle_Get_A_Angle_AAA(A_Angle, C_Angle);//角b为钝角重计算
+            }
+            else
+            {
+                C_Angle = SS_Mathf.Triangle_Get_A_Angle_AAA(A_Angle, B_Angle);//c为钝角优先解
+                C_Edge = SS_Mathf.Triangle_GetEdge(C_Angle, diameter);//通过角获得边
+            }
+            return this;
+        }
+        /// <summary>
+        /// 边角边 :
+        /// 提供 : 两个边和一个夹角 , 全解三角形
+        /// </summary>
+        /// <param name="A_Edge">角A的对边</param>
+        /// <param name="B_Angle">夹角B</param>
+        /// <param name="C_Edge">角C的对边</param>
+        /// <returns>SD_CompleteTriangle</returns>
+        public SD_CompleteTriangle SolutionsTriangle_EAE(float A_Edge, float B_Angle, float C_Edge)//两边夹一角解三角，钝角锐角都可解
+        {
+
+            B_Edge = SS_Mathf.Triangle_Get_A_Edge_EAE(B_Angle, A_Edge, C_Edge);
+            A_Angle = SS_Mathf.Triangle_Get_A_Angle_EEE(A_Edge, C_Edge, B_Edge);
+            C_Angle = SS_Mathf.Triangle_Get_A_Angle_EEE(C_Edge, A_Edge, B_Edge);
+
+            return this;
+        }
+        /// <summary>
+        /// 角边角 :
+        /// 提供 : 两个角夹和一个边 , 全解三角形
+        /// </summary>
+        /// <param name="A_Angle">角A</param>
+        /// <param name="B_Edge">角B的对边</param>
+        /// <param name="C_Angle">角C</param>
+        /// <returns>SD_CompleteTriangle</returns>
+        public SD_CompleteTriangle SolutionsTriangle_AEA(float A_Angle, float B_Edge, float C_Angle)//两角夹一边解三角,钝角锐角都可解
+        {
+
+            B_Angle = SS_Mathf.Triangle_Get_A_Angle_AAA(A_Angle, C_Angle);//暂时求出不定角
+            diameter = SS_Mathf.Triangle_GetDiameter(B_Angle, B_Edge);//获取外接直径
+            A_Edge = SS_Mathf.Triangle_GetEdge(A_Angle, diameter);//通过角获得边
+            C_Edge = SS_Mathf.Triangle_GetEdge(C_Angle, diameter);//通过角获得边
+
+            return this;
+        }
+
+    }
+
+
+}
+
diff --git a/SDHK_Tool/Dynamic/SD_CompleteTriangle.cs.meta b/SDHK_Tool/Dynamic/SD_CompleteTriangle.cs.meta
new file mode 100644
index 0000000..98c3c6c
--- /dev/null
+++ b/SDHK_Tool/Dynamic/SD_CompleteTriangle.cs.meta
@@ -0,0 +1,13 @@
+fileFormatVersion: 2
+guid: a327f7d20c1efae4e9c220d111643e32
+timeCreated: 1560135092
+licenseType: Free
+MonoImporter:
+  externalObjects: {}
+  serializedVersion: 2
+  defaultReferences: []
+  executionOrder: 0
+  icon: {instanceID: 0}
+  userData: 
+  assetBundleName: 
+  assetBundleVariant: 
diff --git a/SDHK_Tool/Dynamic/SD_ObjectPool.cs b/SDHK_Tool/Dynamic/SD_ObjectPool.cs
new file mode 100644
index 0000000..739bed5
--- /dev/null
+++ b/SDHK_Tool/Dynamic/SD_ObjectPool.cs
@@ -0,0 +1,140 @@
+﻿using System.Collections;
+using System.Collections.Generic;
+using UnityEngine;
+using System;
+
+/*
+ * 作者：闪电Y黑客
+ * 
+ * 日期： 2019.11.29
+ * 
+ * 功能：泛型对象池
+ *
+ */
+
+namespace SDHK_Tool.Dynamic
+{
+    /// <summary>
+    /// 对象池
+    /// </summary>
+    /// <typeparam name="T">类型</typeparam>
+    public class SD_ObjectPool<T>
+    {
+        /// <summary>
+        /// 工作池:激活的对集合
+        /// </summary>
+        /// <typeparam name="T">类型</typeparam>
+        /// <returns>类</returns>
+        public List<T> ObjectPool_Work = new List<T>();
+
+        /// <summary>
+        /// 闲置池:闲置的对集合
+        /// </summary>
+        /// <typeparam name="T">类型</typeparam>
+        /// <returns>类</returns>
+        public List<T> ObjectPool_Idle = new List<T>();
+
+        /// <summary>
+        /// 工作委托:工作状态启动后回调函数
+        /// </summary>
+        public Action<T> Object_Work;
+        /// <summary>
+        /// 闲置委托:闲置状态启动后回调函数
+        /// </summary>
+        public Action<T> Object_Idle;
+
+        /// <summary>
+        /// 新建委托:新建对象后回调函数
+        /// </summary>
+        public Action<T> Object_New;
+        /// <summary>
+        /// 删除委托:删除对象前回调函数
+        /// </summary>
+        public Action<T> Object_Del;
+
+
+        private Func<T> ObjectPool_New;//实例化对象的方法
+        private Action<T> ObjectPool_Del;//删除对象的方法
+
+        /// <summary>
+        /// 初始化对象池
+        /// </summary>
+        /// <param name="New">实例化委托</param>
+        /// <param name="Del">删除委托</param>
+        public SD_ObjectPool(Func<T> New, Action<T> Del)
+        {
+            ObjectPool_New = New;//实例化委托
+            ObjectPool_Del = Del;//删除委托
+        }
+
+        /// <summary>
+        /// 获取对象（若没有闲置对象则新建对象为工作对象）
+        /// </summary>
+        /// <returns>对象</returns>
+        public T Get_Object()
+        {
+            T obj;
+
+            if (ObjectPool_Idle.Count > 0)
+            {
+                obj = ObjectPool_Idle[0];
+                ObjectPool_Work.Add(obj);
+                ObjectPool_Idle.RemoveAt(0);
+            }
+            else
+            {
+                obj = ObjectPool_New();
+                if (Object_New != null) Object_New(obj);
+                ObjectPool_Work.Add(obj);
+            }
+
+            if (Object_Work != null) Object_Work(obj);
+
+            return obj;
+        }
+
+        /// <summary>
+        /// 闲置对象(将工作对象设置为闲置对象)
+        /// </summary>
+        /// <param name="Object">要闲置的对象</param>
+        public void Set_Object(T Object)
+        {
+            ObjectPool_Work.Remove(Object);
+            ObjectPool_Idle.Add(Object);//从工作变成闲置状态
+            if (Object_Idle != null) Object_Idle(Object);
+        }
+
+        /// <summary>
+        /// 从对象池中删除一个对象
+        /// </summary>
+        /// <param name="Object">要删除的对象</param>
+        public void Clear_ObjectPool(T Object)
+        {
+            ObjectPool_Work.Remove(Object);
+            ObjectPool_Idle.Remove(Object);
+            if (Object_Del != null) Object_Del(Object);
+            ObjectPool_Del(Object);
+
+        }
+
+        /// <summary>
+        /// 清空对象池
+        /// </summary>
+        public void Clear_ObjectPool()
+        {
+            if (Object_Del != null)
+            {
+                ObjectPool_Work.ForEach(Object_Del);
+                ObjectPool_Idle.ForEach(Object_Del);
+            }
+
+            ObjectPool_Work.ForEach(ObjectPool_Del);
+            ObjectPool_Idle.ForEach(ObjectPool_Del);
+
+            ObjectPool_Work.Clear();
+            ObjectPool_Idle.Clear();
+        }
+
+    }
+
+}
\ No newline at end of file
diff --git a/SDHK_Tool/Dynamic/SD_ObjectPool.cs.meta b/SDHK_Tool/Dynamic/SD_ObjectPool.cs.meta
new file mode 100644
index 0000000..d7c5ec9
--- /dev/null
+++ b/SDHK_Tool/Dynamic/SD_ObjectPool.cs.meta
@@ -0,0 +1,13 @@
+fileFormatVersion: 2
+guid: a074fe2d00ffcf242b47af2441ae9d4d
+timeCreated: 1575264752
+licenseType: Pro
+MonoImporter:
+  externalObjects: {}
+  serializedVersion: 2
+  defaultReferences: []
+  executionOrder: 0
+  icon: {instanceID: 0}
+  userData: 
+  assetBundleName: 
+  assetBundleVariant: 
diff --git a/SDHK_Tool/Dynamic/SD_Thread.cs.meta b/SDHK_Tool/Dynamic/SD_Thread.cs.meta
new file mode 100644
index 0000000..0188212
--- /dev/null
+++ b/SDHK_Tool/Dynamic/SD_Thread.cs.meta
@@ -0,0 +1,13 @@
+fileFormatVersion: 2
+guid: f7541fec5cfc47c44b525c14663f8700
+timeCreated: 1560245942
+licenseType: Free
+MonoImporter:
+  externalObjects: {}
+  serializedVersion: 2
+  defaultReferences: []
+  executionOrder: 0
+  icon: {instanceID: 0}
+  userData: 
+  assetBundleName: 
+  assetBundleVariant: 
diff --git a/SDHK_Tool/Extension/SE_Reflection.cs b/SDHK_Tool/Extension/SE_Reflection.cs
new file mode 100644
index 0000000..59711d6
--- /dev/null
+++ b/SDHK_Tool/Extension/SE_Reflection.cs
@@ -0,0 +1,786 @@
+﻿using System;
+using System.Collections;
+using System.Collections.Generic;
+using System.Reflection;
+using UnityEngine;
+using SDHK_Tool.Static;
+using System.Globalization;
+
+
+/*
+ * 作者：闪电Y黑客
+ * 
+ * 日期： 2019.11.18
+ * 
+ * 功能：反射的扩展方法
+ */
+
+
+
+
+    public static class SE_Reflection
+    {
+        #region 反射DLL
+
+        /// <summary>
+        /// 反射扩展：读取DLL：获取数据元
+        /// </summary>
+        /// <param name="DllPath">DLL路径</param>
+        /// <returns>数据元</returns>
+        public static Assembly SE_GetDLL_Assembly(this string DllPath)
+        {
+            return Assembly.LoadFrom(DllPath);
+        }
+
+        /// <summary>
+        /// 反射扩展：读取DLL：获取类型集合
+        /// </summary>
+        /// <param name="DllPath">DLL路径</param>
+        /// <returns>类型集合</returns>
+        public static Type[] SE_GetDLL_Types(this string DllPath)
+        {
+            return Assembly.LoadFrom(DllPath).GetTypes();
+        }
+
+        /// <summary>
+        /// 反射扩展：读取DLL：获取类型集合(单独反射消耗大)
+        /// </summary>
+        /// <param name="DllPath">DLL路径</param>
+        /// <param name="ObjectName">类型名字</param>
+        /// <returns>类型</returns>
+        public static Type GetDLL_Types(this string DllPath, string ObjectName)
+        {
+            return Assembly.LoadFrom(DllPath).GetType(ObjectName);
+        }
+
+        /// <summary>
+        /// 反射扩展：读取DLL：新建实例化类(单独反射消耗大)
+        /// </summary>
+        /// <param name="DllPath">DLL路径</param>
+        /// <param name="ObjectName">类型名字</param>
+        /// <returns>实例化类</returns>
+        public static object SE_GetDLL_Object(this string DllPath, string ObjectName)
+        {
+            return Activator.CreateInstance(Assembly.LoadFrom(DllPath).GetType(ObjectName));
+        }
+
+        #endregion
+
+
+
+        #region 反射类
+
+        /// <summary>
+        /// 根据名字从数据元中实例化类
+        /// </summary>
+        /// <param name="assembly">数据元</param>
+        /// <param name="ObjectName">类型名字(包括命名空间)</param>
+        /// <returns>实例化类</returns> 
+        public static object SE_GetObject(this Assembly assembly, string ObjectName)
+        {
+            return Activator.CreateInstance(assembly.GetType(ObjectName));
+        }
+
+        /// <summary>
+        /// 根据名字从数据元中获取类型
+        /// </summary>
+        /// <param name="assembly">数据元</param>
+        /// <param name="ObjectName">类型名字(包括命名空间)</param>
+        /// <returns>类型</returns>
+        public static Type SE_GetType(this Assembly assembly, string ObjectName)
+        {
+            return assembly.GetType(ObjectName);
+        }
+
+        /// <summary>
+        /// 反射扩展：根据名字实例化类
+        /// </summary>
+        /// <param name="ObjectName">类型名字(包括命名空间)</param>
+        /// <returns>实例化类</returns>
+        public static object SE_GetObject(this string ObjectName)
+        {
+            return Activator.CreateInstance(Type.GetType(ObjectName));
+        }
+
+        /// <summary>
+        /// 反射扩展：根据类型新建类
+        /// </summary>
+        /// <param name="ObjectType">类型</param>
+        /// <returns>实例化类</returns>
+        public static object SE_GetObject(this Type ObjectType)
+        {
+            return Activator.CreateInstance(ObjectType);
+        }
+
+        /// <summary>
+        /// 反射扩展：根据名字新建类
+        /// </summary>
+        /// <param name="ObjectName">类型名字(包括命名空间)</param>
+        /// <param name="args">构造函数参数</param>
+        /// <returns>实例化类</returns>
+        public static object SE_GetObject(this string ObjectName, object[] args)
+        {
+            return Activator.CreateInstance(Type.GetType(ObjectName), args);
+        }
+
+        /// <summary>
+        /// 反射扩展：根据类型新建类
+        /// </summary>
+        /// <param name="ObjectType">类型</param>
+        /// <param name="args">构造函数参数</param>
+        /// <returns>实例化类</returns>
+        public static object SE_GetObject(this Type ObjectType, object[] args)
+        {
+            return Activator.CreateInstance(ObjectType, args);
+        }
+
+
+
+
+        #endregion
+
+
+        #region  反射字段
+
+
+        #region 获取字段信息	
+
+        /// <summary>
+        /// 反射扩展：获取字段信息集合：根据类型
+        /// </summary>
+        /// <param name="ObjectType">类型</param>
+        /// <param name="bindingFlags">属性过滤</param>
+        /// <returns>字段信息集合</returns>
+        public static FieldInfo[] SE_GetInfos_Field(this Type ObjectType, BindingFlags bindingFlags = BindingFlags.Instance | BindingFlags.Public)
+        {
+            return ObjectType.GetFields(bindingFlags);
+        }
+
+        /// <summary>
+        /// 反射扩展：获取字段信息集合：根据类型名字
+        /// </summary>
+        /// <param name="ObjectName">类型名(包括命名空间)</param>
+        /// <param name="bindingFlags">属性过滤</param>
+        /// <returns>字段信息集合</returns>
+        public static FieldInfo[] SE_GetInfos_Field(this string ObjectName, BindingFlags bindingFlags = BindingFlags.Instance | BindingFlags.Public)
+        {
+            return Type.GetType(ObjectName).GetFields(bindingFlags);
+        }
+
+
+        /// <summary>
+        /// 反射扩展：获取字段信息集合：根据实例化类
+        /// </summary>
+        /// <param name="_Object">实例化类</param>
+        /// <param name="bindingFlags">属性过滤</param>
+        /// <returns>字段信息集合</returns>
+        public static FieldInfo[] SE_GetInfos_Field<T>(this T _Object, BindingFlags bindingFlags = BindingFlags.Instance | BindingFlags.Public)
+        {
+            return _Object.GetType().GetFields(bindingFlags);
+        }
+
+
+        /// <summary>
+        /// 反射扩展：获取字段信息：根据类型
+        /// </summary>
+        /// <param name="ObjectType">类型</param>
+        /// <param name="PropertyName">字段名</param>
+        /// <param name="bindingFlags">属性过滤</param>
+        /// <returns>字段信息</returns>
+        public static FieldInfo SE_GetInfo_Field(this Type ObjectType, string FieldName, BindingFlags bindingFlags = BindingFlags.Instance | BindingFlags.Public)
+        {
+            return ObjectType.GetField(FieldName, bindingFlags);
+        }
+
+        /// <summary>
+        /// 反射扩展：获取字段信息：根据类型名字
+        /// </summary>
+        /// <param name="ObjectName">类型名(包括命名空间)</param>
+        /// <param name="PropertyName">字段名</param>
+        /// <param name="bindingFlags">属性过滤</param>
+        /// <returns>字段信息</returns>
+        public static FieldInfo SE_GetInfo_Field(this string ObjectName, string FieldName, BindingFlags bindingFlags = BindingFlags.Instance | BindingFlags.Public)
+        {
+            return Type.GetType(ObjectName).SE_GetInfo_Field(FieldName, bindingFlags);
+        }
+
+
+        /// <summary>
+        /// 反射扩展：获取字段信息：根据实例化类
+        /// </summary>
+        /// <param name="_Object">实例化类</param>
+        /// <param name="PropertyName">字段名</param>
+        /// <param name="bindingFlags">属性过滤</param>
+        /// <returns>字段信息</returns>
+        public static FieldInfo SE_GetInfo_Field<T>(this T _Object, string FieldName, BindingFlags bindingFlags = BindingFlags.Instance | BindingFlags.Public)
+        {
+            return _Object.GetType().GetField(FieldName, bindingFlags);
+        }
+
+        #endregion
+
+        #region 获取字段
+
+        //===============================================
+
+        /// <summary>
+        /// 反射扩展：获取字段：根据实例化类
+        /// </summary>
+        /// <param name="_Object">实例化类</param>
+        /// <param name="PropertyName">字段名</param>
+        /// <param name="bindingFlags">属性过滤</param>
+        /// <returns>字段</returns>
+        public static object SE_Get_Field<T>(this T _Object, string FieldName, BindingFlags bindingFlags = BindingFlags.Instance | BindingFlags.Public)
+        {
+            return _Object.GetType().GetField(FieldName, bindingFlags).GetValue(_Object);
+        }
+
+        /// <summary>
+        /// 反射扩展：获取静态类字段：根据类型
+        /// </summary>
+        /// <param name="ObjectType">类型</param>
+        /// <param name="PropertyName">字段名</param>
+        /// <param name="bindingFlags">属性过滤</param>
+        /// <returns>字段</returns>
+        public static object SE_Get_Field(this Type ObjectType, string FieldName, BindingFlags bindingFlags = BindingFlags.Static | BindingFlags.Public)
+        {
+            return ObjectType.GetField(FieldName, bindingFlags).GetValue(null);
+        }
+
+        /// <summary>
+        /// 反射扩展：获取静态类字段：根据类型名字
+        /// </summary>
+        /// <param name="ObjectName">类型名(包括命名空间)</param>
+        /// <param name="PropertyName">字段名</param>
+        /// <param name="bindingFlags">属性过滤</param>
+        /// <returns>字段</returns>
+        public static object SE_Get_Field(this string ObjectName, string FieldName, BindingFlags bindingFlags = BindingFlags.Static | BindingFlags.Public)
+        {
+            return Type.GetType(ObjectName).GetField(FieldName, bindingFlags).GetValue(null);
+        }
+
+        #endregion
+
+        #region 设置字段
+
+        /// <summary>
+        /// 反射扩展：设置字段：根据实例化类
+        /// </summary>
+        /// <param name="_Object">实例化类</param>
+        /// <param name="PropertyName">字段名</param>
+        /// <param name="value">设置值</param>
+        /// <param name="bindingFlags">属性过滤</param>
+        /// <param name="binder">自定义绑定器</param>
+        /// <param name="culture">设置文化</param>
+        public static object SE_Set_Field<T>(this T _Object, string FieldName, object value, BindingFlags bindingFlags = BindingFlags.Instance | BindingFlags.Public, Binder binder = null, CultureInfo culture = null)
+        {
+            _Object.GetType().GetField(FieldName, bindingFlags).SetValue(_Object, value, bindingFlags, binder, culture);
+            return _Object;
+        }
+
+        /// <summary>
+        /// 反射扩展：设置静态类字段：根据类型
+        /// </summary>
+        /// <param name="ObjectType">类型</param>
+        /// <param name="PropertyName">字段名</param>
+        /// <param name="value">设置值</param>
+        /// <param name="bindingFlags">属性过滤</param>
+        /// <param name="binder">自定义绑定器</param>
+        /// <param name="culture">设置文化</param>
+        public static void SE_Set_Field(this Type ObjectType, string FieldName, object value, BindingFlags bindingFlags = BindingFlags.Instance | BindingFlags.Public, Binder binder = null, CultureInfo culture = null)
+        {
+            ObjectType.GetField(FieldName, bindingFlags).SetValue(null, value, bindingFlags, binder, culture);
+        }
+
+        /// <summary>
+        /// 反射扩展：设置静态类字段：根据类型名字
+        /// </summary>
+        /// <param name="ObjectName">类型名字(包括命名空间)</param>
+        /// <param name="PropertyName">字段名</param>
+        /// <param name="value">设置值</param>
+        /// <param name="bindingFlags">属性过滤</param>
+        /// <param name="binder">自定义绑定器</param>
+        /// <param name="culture">设置文化</param>
+        public static void SE_Set_Field(this string ObjectName, string FieldName, object value, BindingFlags bindingFlags = BindingFlags.Instance | BindingFlags.Public, Binder binder = null, CultureInfo culture = null)
+        {
+            Type.GetType(ObjectName).GetField(FieldName, bindingFlags).SetValue(null, value, bindingFlags, binder, culture);
+        }
+
+        #endregion
+
+
+
+        #endregion
+
+
+
+
+        #region  反射属性
+
+
+        #region 获取属性信息
+
+        /// <summary>
+        /// 反射扩展：获取属性信息集合：根据类型
+        /// </summary>
+        /// <param name="ObjectType">类型</param>
+        /// <param name="bindingFlags">属性过滤</param>
+        /// <returns>属性信息集合</returns>
+        public static PropertyInfo[] SE_GetInfos_Property(this Type ObjectType, BindingFlags bindingFlags = BindingFlags.Instance | BindingFlags.Public)
+        {
+            return ObjectType.GetProperties(bindingFlags);
+        }
+
+        /// <summary>
+        /// 反射扩展：获取属性信息集合：根据类型名字
+        /// </summary>
+        /// <param name="ObjectName">类型名(包括命名空间)</param>
+        /// <param name="bindingFlags">属性过滤</param>
+        /// <returns>属性信息集合</returns>
+        public static PropertyInfo[] SE_GetInfos_Property(this string ObjectName, BindingFlags bindingFlags = BindingFlags.Instance | BindingFlags.Public)
+        {
+            return Type.GetType(ObjectName).GetProperties(bindingFlags);
+        }
+
+        /// <summary>
+        /// 反射扩展：获取属性信息集合：根据实例化类
+        /// </summary>
+        /// <param name="_Object">实例化类</param>
+        /// <param name="bindingFlags">属性过滤</param>
+        /// <returns>属性信息集合</returns>
+        public static PropertyInfo[] SE_GetInfos_Property<T>(this T _Object, BindingFlags bindingFlags = BindingFlags.Instance | BindingFlags.Public)
+        {
+            return _Object.GetType().GetProperties(bindingFlags);
+        }
+
+
+
+
+        /// <summary>
+        /// 反射扩展：获取属性信息：根据类型
+        /// </summary>
+        /// <param name="ObjectType">类型</param>
+        /// <param name="PropertyName">属性名</param>
+        /// <param name="bindingFlags">属性过滤</param>
+        /// <returns>属性信息</returns>
+        public static PropertyInfo SE_GetInfo_Property(this Type ObjectType, string PropertyName, BindingFlags bindingFlags = BindingFlags.Instance | BindingFlags.Public)
+        {
+            return ObjectType.GetProperty(PropertyName, bindingFlags);
+        }
+
+        /// <summary>
+        /// 反射扩展：获取属性信息：根据类型
+        /// </summary>
+        /// <param name="ObjectType">类型</param>
+        /// <param name="PropertyName">属性名</param>
+        /// <param name="returnType">返回参数类型</param>
+        /// <param name="types">参数类型</param>
+        /// <param name="bindingFlags">属性过滤</param>
+        /// <param name="parameters">传入参数</param>
+        /// <param name="binder">自定义绑定器</param>
+        /// <returns>属性信息</returns>
+        public static PropertyInfo SE_GetInfo_Property(this Type ObjectType, string PropertyName, Type returnType, Type[] types, BindingFlags bindingFlags = BindingFlags.Instance | BindingFlags.Public, ParameterModifier[] parameters = null, Binder binder = null)
+        {
+            return ObjectType.GetProperty(PropertyName, bindingFlags, binder, returnType, types, parameters);
+        }
+
+
+        /// <summary>
+        /// 反射扩展：获取属性信息：根据类型名字
+        /// </summary>
+        /// <param name="ObjectName">类型名(包括命名空间)</param>
+        /// <param name="PropertyName">属性名</param>
+        /// <param name="bindingFlags">属性过滤</param>
+        /// <returns>属性信息</returns>
+        public static PropertyInfo SE_GetInfo_Property(this string ObjectName, string PropertyName, BindingFlags bindingFlags = BindingFlags.Instance | BindingFlags.Public)
+        {
+            return Type.GetType(ObjectName).GetProperty(PropertyName, bindingFlags);
+        }
+
+
+        /// <summary>
+        /// 反射扩展：获取属性信息：根据类型名字
+        /// </summary>
+        /// <param name="ObjectName">类型名(包括命名空间)</param>
+        /// <param name="PropertyName">属性名</param>
+        /// <param name="returnType">返回参数类型</param>
+        /// <param name="types">参数类型</param>
+        /// <param name="bindingFlags">属性过滤</param>
+        /// <param name="parameters">传入参数</param>
+        /// <param name="binder">自定义绑定器</param>
+        /// <returns>属性信息</returns>
+        public static PropertyInfo SE_GetInfo_Property(this string ObjectName, string PropertyName, Type returnType, Type[] types, BindingFlags bindingFlags = BindingFlags.Instance | BindingFlags.Public, ParameterModifier[] parameters = null, Binder binder = null)
+        {
+            return Type.GetType(ObjectName).GetProperty(PropertyName, bindingFlags, binder, returnType, types, parameters);
+        }
+
+
+        /// <summary>
+        /// 反射扩展：获取属性信息：根据实例化类
+        /// </summary>
+        /// <param name="_Object">实例化类</param>
+        /// <param name="PropertyName">属性名</param>
+        /// <param name="bindingFlags">属性过滤</param>
+        /// <returns>属性信息</returns>
+        public static PropertyInfo SE_GetInfo_Property<T>(this T _Object, string PropertyName, BindingFlags bindingFlags = BindingFlags.Instance | BindingFlags.Public)
+        {
+            return _Object.GetType().GetProperty(PropertyName, bindingFlags);
+        }
+
+
+        /// <summary>
+        /// 反射扩展：获取属性信息：根据实例化类
+        /// </summary>
+        /// <param name="_Object">实例化类</param>
+        /// <param name="PropertyName">属性名</param>
+        /// <param name="returnType">返回参数类型</param>
+        /// <param name="types">参数类型</param>
+        /// <param name="bindingFlags">属性过滤</param>
+        /// <param name="parameters">传入参数</param>
+        /// <param name="binder">自定义绑定器</param>
+        /// <returns>属性信息</returns>
+        public static PropertyInfo SE_GetInfo_Property<T>(this T _Object, string PropertyName, Type returnType, Type[] types, BindingFlags bindingFlags = BindingFlags.Instance | BindingFlags.Public, ParameterModifier[] parameters = null, Binder binder = null)
+        {
+            return _Object.GetType().GetProperty(PropertyName, bindingFlags, binder, returnType, types, parameters);
+        }
+
+        #endregion
+
+
+
+        #region 获取属性
+
+        /// <summary>
+        /// 反射扩展：获取属性：根据实例化类
+        /// </summary>
+        /// <param name="_Object">实例化类</param>
+        /// <param name="PropertyName">属性名</param>
+        /// <param name="bindingFlags">属性过滤</param>
+        /// <param name="index">索引器</param>
+        /// <returns>属性</returns>
+        public static object SE_Get_Property<T>(this T _Object, string PropertyName, BindingFlags bindingFlags = BindingFlags.Instance | BindingFlags.Public, object[] index = null)
+        {
+            return _Object.GetType().GetProperty(PropertyName, bindingFlags).GetValue(_Object, index);
+        }
+
+        /// <summary>
+        /// 反射扩展：获取静态类属性：根据类型
+        /// </summary>
+        /// <param name="ObjectType">类型</param>
+        /// <param name="PropertyName">属性名</param>
+        /// <param name="bindingFlags">属性过滤</param>
+        /// <param name="index">索引器</param>
+        /// <returns>属性</returns>
+        public static object SE_Get_Property(this Type ObjectType, string PropertyName, BindingFlags bindingFlags = BindingFlags.Static | BindingFlags.Public, object[] index = null)
+        {
+            return ObjectType.GetProperty(PropertyName, bindingFlags).GetValue(null, index);
+        }
+
+        /// <summary>
+        /// 反射扩展：获取静态类属性：根据类型名字
+        /// </summary>
+        /// <param name="ObjectName">类型名(包括命名空间)</param>
+        /// <param name="PropertyName">属性名</param>
+        /// <param name="bindingFlags">属性过滤</param>
+        /// <param name="index">索引器</param>
+        /// <returns>属性</returns>
+        public static object SE_Get_Property(this string ObjectName, string PropertyName, BindingFlags bindingFlags = BindingFlags.Static | BindingFlags.Public, object[] index = null)
+        {
+            return Type.GetType(ObjectName).GetProperty(PropertyName, bindingFlags).GetValue(null, index);
+        }
+
+        #endregion
+
+
+
+        #region  设置属性
+
+        /// <summary>
+        /// 反射扩展：设置属性：根据实例化类
+        /// </summary>
+        /// <param name="_Object">实例化类</param>
+        /// <param name="PropertyName">属性名</param>
+        /// <param name="value">设置值</param>
+        /// <param name="bindingFlags">属性过滤</param>
+        /// <param name="binder">自定义绑定器</param>
+        /// <param name="index">索引器</param>
+        /// <param name="culture">设置文化</param>
+        public static object SE_Set_Property<T>(this T _Object, string PropertyName, object value, BindingFlags bindingFlags = BindingFlags.Instance | BindingFlags.Public, Binder binder = null, object[] index = null, CultureInfo culture = null)
+        {
+            _Object.GetType().GetProperty(PropertyName, bindingFlags).SetValue(_Object, value, bindingFlags, binder, index, culture);
+            return _Object;
+        }
+
+        /// <summary>
+        /// 反射扩展：设置静态类属性：根据类型
+        /// </summary>
+        /// <param name="ObjectType">类型</param>
+        /// <param name="PropertyName">属性名</param>
+        /// <param name="value">设置值</param>
+        /// <param name="bindingFlags">属性过滤</param>
+        /// <param name="binder">自定义绑定器</param>
+        /// <param name="index">索引器</param>
+        /// <param name="culture">设置文化</param>
+        public static void SE_Set_Property(this Type ObjectType, string PropertyName, object value, BindingFlags bindingFlags = BindingFlags.Instance | BindingFlags.Public, Binder binder = null, object[] index = null, CultureInfo culture = null)
+        {
+            ObjectType.GetProperty(PropertyName, bindingFlags).SetValue(null, value, bindingFlags, binder, index, culture);
+        }
+
+        /// <summary>
+        /// 反射扩展：设置静态类属性：根据类型名字
+        /// </summary>
+        /// <param name="ObjectName">类型名字(包括命名空间)</param>
+        /// <param name="PropertyName">属性名</param>
+        /// <param name="value">设置值</param>
+        /// <param name="bindingFlags">属性过滤</param>
+        /// <param name="binder">自定义绑定器</param>
+        /// <param name="index">索引器</param>
+        /// <param name="culture">设置文化</param>
+        public static void SE_Set_Property(this string ObjectName, string PropertyName, object value, BindingFlags bindingFlags = BindingFlags.Instance | BindingFlags.Public, Binder binder = null, object[] index = null, CultureInfo culture = null)
+        {
+            Type.GetType(ObjectName).GetProperty(PropertyName, bindingFlags).SetValue(null, value, bindingFlags, binder, index, culture);
+        }
+
+        #endregion
+
+
+        #endregion
+
+
+
+        #region  反射方法
+
+
+        #region  获取方法信息
+
+        /// <summary>
+        /// 反射扩展：获取方法信息集合：根据类型
+        /// </summary>
+        /// <param name="ObjectType">类型</param>
+        /// <param name="bindingFlags">属性过滤</param>
+        /// <returns>方法信息集合</returns>
+        public static MethodInfo[] SE_GetInfos_Method(this Type ObjectType, BindingFlags bindingFlags = BindingFlags.Instance | BindingFlags.Public)
+        {
+            return ObjectType.GetMethods(bindingFlags);
+        }
+
+        /// <summary>
+        /// 反射扩展：获取方法信息集合：根据类型名字
+        /// </summary>
+        /// <param name="ObjectName">类型名(包括命名空间)</param>
+        /// <param name="bindingFlags">属性过滤</param>
+        /// <returns>方法信息集合</returns>
+        public static MethodInfo[] SE_GetInfos_Method(this string ObjectName, BindingFlags bindingFlags = BindingFlags.Instance | BindingFlags.Public)
+        {
+            return Type.GetType(ObjectName).GetMethods(bindingFlags);
+        }
+
+
+        /// <summary>
+        /// 反射扩展：获取方法信息集合：根据实例化类
+        /// </summary>
+        /// <param name="_Object">实例化类</param>
+        /// <param name="bindingFlags">属性过滤</param>
+        /// <returns>方法信息集合</returns>
+        public static MethodInfo[] SE_GetInfos_Method<T>(this T _Object, BindingFlags bindingFlags = BindingFlags.Instance | BindingFlags.Public)
+        {
+            return _Object.GetType().GetMethods(bindingFlags);
+        }
+
+
+
+
+        /// <summary>
+        /// 反射扩展：获取方法信息：根据类型
+        /// </summary>
+        /// <param name="ObjectType">类型</param>
+        /// <param name="MethodName">方法名</param>
+        /// <param name="bindingFlags">属性过滤</param>
+        /// <returns>方法信息</returns>
+        public static MethodInfo SE_GetInfo_Method(this Type ObjectType, string MethodName, BindingFlags bindingFlags = BindingFlags.Instance | BindingFlags.Public)
+        {
+            return ObjectType.GetMethod(MethodName, bindingFlags);
+        }
+
+
+
+        /// <summary>
+        /// 反射扩展：获取方法信息：根据类型
+        /// </summary>
+        /// <param name="ObjectType">类型</param>
+        /// <param name="MethodName">方法名</param>
+        /// <param name="types">参数类型</param>
+        /// <param name="bindingFlags">属性过滤</param>
+        /// <param name="modifiers">参数修改器</param>
+        /// <param name="binder">自定义绑定器</param>
+        /// <returns>方法信息</returns>
+        public static MethodInfo SE_GetInfo_Method(this Type ObjectType, string MethodName, Type[] types, BindingFlags bindingFlags = BindingFlags.Instance | BindingFlags.Public, ParameterModifier[] modifiers = null, Binder binder = null)
+        {
+            return ObjectType.GetMethod(MethodName, bindingFlags, binder, types, modifiers);
+        }
+
+
+        /// <summary>
+        /// 反射扩展：获取方法信息：根据类型名字
+        /// </summary>
+        /// <param name="ObjectName">类型名(包括命名空间)</param>
+        /// <param name="MethodName">方法名</param>
+        /// <param name="bindingFlags">属性过滤</param>
+        /// <returns>方法信息</returns>
+        public static MethodInfo SE_GetInfo_Method(this string ObjectName, string MethodName, BindingFlags bindingFlags = BindingFlags.Instance | BindingFlags.Public)
+        {
+            return Type.GetType(ObjectName).GetMethod(MethodName, bindingFlags);
+        }
+
+
+        /// <summary>
+        /// 反射扩展：获取方法信息：根据类型名字
+        /// </summary>
+        /// <param name="ObjectType">类型名(包括命名空间)</param>
+        /// <param name="MethodName">方法名</param>
+        /// <param name="types">参数类型</param>
+        /// <param name="bindingFlags">属性过滤</param>
+        /// <param name="modifiers">参数修改器</param>
+        /// <param name="binder">自定义绑定器</param>
+        /// <returns>方法信息</returns>
+        public static MethodInfo SE_GetInfo_Method(this string ObjectName, string MethodName, Type[] types, BindingFlags bindingFlags = BindingFlags.Instance | BindingFlags.Public, ParameterModifier[] modifiers = null, Binder binder = null)
+        {
+            return Type.GetType(ObjectName).GetMethod(MethodName, bindingFlags, binder, types, modifiers);
+        }
+
+
+        /// <summary>
+        /// 反射扩展：获取方法信息：根据实例化类
+        /// </summary>
+        /// <param name="_Object">实例化类</param>
+        /// <param name="MethodName">方法名</param>
+        /// <param name="bindingFlags">属性过滤</param>
+        /// <returns>方法信息</returns>
+        public static MethodInfo SE_GetInfo_Method<T>(this T _Object, string MethodName, BindingFlags bindingFlags = BindingFlags.Instance | BindingFlags.Public)
+        {
+            return _Object.GetType().GetMethod(MethodName, bindingFlags);
+        }
+
+
+        /// <summary>
+        /// 反射扩展：获取方法信息：根据实例化类
+        /// </summary>
+        /// <param name="_Object">实例化类</param>
+        /// <param name="MethodName">方法名</param>
+        /// <param name="types">参数类型</param>
+        /// <param name="bindingFlags">属性过滤</param>
+        /// <param name="modifiers">参数修改器</param>
+        /// <param name="binder">自定义绑定器</param>
+        /// <returns>方法信息</returns>
+        public static MethodInfo SE_GetInfo_Method<T>(this T _Object, string MethodName, Type[] types, BindingFlags bindingFlags = BindingFlags.Instance | BindingFlags.Public, ParameterModifier[] modifiers = null, Binder binder = null)
+        {
+            return _Object.GetType().GetMethod(MethodName, bindingFlags, binder, types, modifiers);
+        }
+
+        #endregion
+
+
+
+        #region 调用方法
+
+        /// <summary>
+        /// 反射扩展：调用方法：根据实例化类
+        /// </summary>
+        /// <param name="_Object">实例化类</param>
+        /// <param name="MethodName">方法名</param>
+        /// <param name="parameters">参数</param>
+        /// <param name="bindingFlags">属性过滤</param>
+        /// <returns>方法返回值</returns>
+        public static object SE_Call_Method<T>(this T _Object, string MethodName, object[] parameters = null, BindingFlags bindingFlags = BindingFlags.Instance | BindingFlags.Public)
+        {
+            return _Object.GetType().GetMethod(MethodName, bindingFlags).Invoke(_Object, parameters);
+        }
+
+
+        /// <summary>
+        /// 反射扩展：调用方法：根据实例化类
+        /// </summary>
+        /// <param name="_Object">实例化类</param>
+        /// <param name="MethodName">方法名</param>
+        /// <param name="types">参数类型</param>
+        /// <param name="parameters">参数</param>
+        /// <param name="bindingFlags">属性过滤</param>
+        /// <param name="modifiers">参数修改器</param>
+        /// <param name="binder">自定义绑定器</param>
+        /// <returns>方法返回值</returns>
+        public static object SE_Call_Method<T>(this T _Object, string MethodName, Type[] types, object[] parameters, BindingFlags bindingFlags = BindingFlags.Instance | BindingFlags.Public, ParameterModifier[] modifiers = null, Binder binder = null)
+        {
+            return _Object.GetType().GetMethod(MethodName, bindingFlags, binder, types, modifiers).Invoke(_Object, parameters);
+        }
+
+
+        /// <summary>
+        /// 反射扩展：调用静态方法：根据类型名字
+        /// </summary>
+        /// <param name="ObjectName">类型名(包括命名空间)</param>
+        /// <param name="MethodName">方法名</param>
+        /// <param name="parameters">参数</param>
+        /// <param name="bindingFlags">属性过滤</param>
+        /// <returns>方法返回值</returns>
+        public static object SE_Call_Method(this string ObjectName, string MethodName, object[] parameters = null, BindingFlags bindingFlags = BindingFlags.Static | BindingFlags.Public)
+        {
+            return Type.GetType(ObjectName).GetMethod(MethodName, bindingFlags).Invoke(null, parameters);
+        }
+
+
+        /// <summary>
+        /// 反射扩展：调用静态方法：根据类型名字
+        /// </summary>
+        /// <param name="ObjectName">类型名(包括命名空间)</param>
+        /// <param name="MethodName">方法名</param>
+        /// <param name="types">参数类型</param>
+        /// <param name="parameters">参数</param>
+        /// <param name="bindingFlags">属性过滤</param>
+        /// <param name="modifiers">参数修改器</param>
+        /// <param name="binder">自定义绑定器</param>
+        /// <returns>方法返回值</returns>
+        public static object SE_Call_Method(this string ObjectName, string MethodName, Type[] types, object[] parameters, BindingFlags bindingFlags = BindingFlags.Static | BindingFlags.Public, ParameterModifier[] modifiers = null, Binder binder = null)
+        {
+            return Type.GetType(ObjectName).GetMethod(MethodName, bindingFlags, binder, types, modifiers).Invoke(null, parameters);
+        }
+
+
+        /// <summary>
+        /// 反射扩展：调用静态方法：根据类型
+        /// </summary>
+        /// <param name="ObjectType">类型</param>
+        /// <param name="MethodName">方法名</param>
+        /// <param name="parameters">参数</param>
+        /// <param name="bindingFlags">属性过滤</param>
+        /// <returns>方法返回值</returns>
+        public static object SE_Call_Method(this Type ObjectType, string MethodName, object[] parameters = null, BindingFlags bindingFlags = BindingFlags.Static | BindingFlags.Public)
+        {
+            return ObjectType.GetMethod(MethodName, bindingFlags).Invoke(null, parameters);
+        }
+
+
+        /// <summary>
+        /// 反射扩展：调用静态方法：根据类型
+        /// </summary>
+        /// <param name="ObjectType">类型</param>
+        /// <param name="MethodName">方法名</param>
+        /// <param name="types">参数类型</param>
+        /// <param name="parameters">参数</param>
+        /// <param name="bindingFlags">属性过滤</param>
+        /// <param name="modifiers">参数修改器</param>
+        /// <param name="binder">自定义绑定器</param>
+        /// <returns>方法返回值</returns>
+        public static object SE_Call_Method(this Type ObjectType, string MethodName, Type[] types, object[] parameters, BindingFlags bindingFlags = BindingFlags.Static | BindingFlags.Public, ParameterModifier[] modifiers = null, Binder binder = null)
+        {
+            return ObjectType.GetMethod(MethodName, bindingFlags, binder, types, modifiers).Invoke(null, parameters);
+        }
+
+        #endregion
+
+
+        #endregion
+
+
+
+
+    }
diff --git a/SDHK_Tool/Extension/SE_Reflection.cs.meta b/SDHK_Tool/Extension/SE_Reflection.cs.meta
new file mode 100644
index 0000000..9673b58
--- /dev/null
+++ b/SDHK_Tool/Extension/SE_Reflection.cs.meta
@@ -0,0 +1,13 @@
+fileFormatVersion: 2
+guid: 5616d05de3545554fa904c5b629f94ab
+timeCreated: 1574041725
+licenseType: Pro
+MonoImporter:
+  externalObjects: {}
+  serializedVersion: 2
+  defaultReferences: []
+  executionOrder: 0
+  icon: {instanceID: 0}
+  userData: 
+  assetBundleName: 
+  assetBundleVariant: 
diff --git a/SDHK_Tool/Extension/SE_Transform.cs.meta b/SDHK_Tool/Extension/SE_Transform.cs.meta
new file mode 100644
index 0000000..fc72bfb
--- /dev/null
+++ b/SDHK_Tool/Extension/SE_Transform.cs.meta
@@ -0,0 +1,13 @@
+fileFormatVersion: 2
+guid: 799652f35cf1e754e8e2d845e474e987
+timeCreated: 1571810615
+licenseType: Pro
+MonoImporter:
+  externalObjects: {}
+  serializedVersion: 2
+  defaultReferences: []
+  executionOrder: 0
+  icon: {instanceID: 0}
+  userData: 
+  assetBundleName: 
+  assetBundleVariant: 
diff --git a/SDHK_Tool/Static/File/SS_File.cs b/SDHK_Tool/Static/File/SS_File.cs
new file mode 100644
index 0000000..20ed28b
--- /dev/null
+++ b/SDHK_Tool/Static/File/SS_File.cs
@@ -0,0 +1,96 @@
+﻿using System;
+using UnityEngine;
+
+/*
+ * 作者：闪电Y黑客
+ * 
+ * 日期： 2019.6.11
+ * 
+ * 功能：SS_File的分支部分：存放文件操作需要的类型
+ */
+
+namespace SDHK_Tool.Static
+{
+    /// <summary>
+    /// 用于Unity3d的资源文件读写类
+    /// </summary>
+    public static partial class SS_File { }
+
+
+    /// <summary>
+    /// 用于序列化的Vector2结构
+    /// </summary>
+    [Serializable]
+    public struct SF_Vector2
+    {
+        public float x;
+        public float y;
+
+
+        public SF_Vector2(float rX, float rY)
+        {
+            x = rX;
+            y = rY;
+        }
+
+        // 以字符串形式返回,方便调试查看
+        public override string ToString()
+        {
+            return String.Format("[{0}, {1}]", x, y);
+        }
+
+        // 隐式转换：将SF_Vector3 转换成 Vector3
+        public static implicit operator Vector2(SF_Vector2 rValue)
+        {
+            return new Vector2(rValue.x, rValue.y);
+        }
+
+        // 隐式转换：将Vector3 转成 SF_Vector3
+        public static implicit operator SF_Vector2(Vector2 rValue)
+        {
+            return new SF_Vector2(rValue.x, rValue.y);
+        }
+    }
+
+    /// <summary>
+    /// 用于序列化的Vector3结构
+    /// </summary>
+    [Serializable]
+    public struct SF_Vector3
+    {
+        public float x;
+        public float y;
+        public float z;
+
+        public SF_Vector3(float rX, float rY, float rZ)
+        {
+            x = rX;
+            y = rY;
+            z = rZ;
+        }
+
+        // 以字符串形式返回,方便调试查看
+        public override string ToString()
+        {
+            return String.Format("[{0}, {1}, {2}]", x, y, z);
+        }
+
+        // 隐式转换：将SF_Vector3 转换成 Vector3
+        public static implicit operator Vector3(SF_Vector3 rValue)
+        {
+            return new Vector3(rValue.x, rValue.y, rValue.z);
+        }
+
+        // 隐式转换：将Vector3 转成 SF_Vector3
+        public static implicit operator SF_Vector3(Vector3 rValue)
+        {
+            return new SF_Vector3(rValue.x, rValue.y, rValue.z);
+        }
+    }
+
+
+
+
+
+
+}
diff --git a/SDHK_Tool/Static/File/SS_File.cs.meta b/SDHK_Tool/Static/File/SS_File.cs.meta
new file mode 100644
index 0000000..f2a0cbb
--- /dev/null
+++ b/SDHK_Tool/Static/File/SS_File.cs.meta
@@ -0,0 +1,13 @@
+fileFormatVersion: 2
+guid: dea251f9e4fe56c4d97c112c932a4621
+timeCreated: 1560248703
+licenseType: Free
+MonoImporter:
+  externalObjects: {}
+  serializedVersion: 2
+  defaultReferences: []
+  executionOrder: 0
+  icon: {instanceID: 0}
+  userData: 
+  assetBundleName: 
+  assetBundleVariant: 
diff --git a/SDHK_Tool/Static/File/SS_File_Byte.cs b/SDHK_Tool/Static/File/SS_File_Byte.cs
new file mode 100644
index 0000000..e3e535e
--- /dev/null
+++ b/SDHK_Tool/Static/File/SS_File_Byte.cs
@@ -0,0 +1,215 @@
+﻿using System.IO;
+using System.Runtime.Serialization.Formatters.Binary;
+using System.Text;
+using UnityEngine;
+
+/*
+ * 作者：闪电Y黑客
+ * 
+ * 日期： 2019.12.3
+ * 
+ * 功能：SS_File的分支部分：对二进制文件进行操作的方法
+ */
+
+
+namespace SDHK_Tool.Static
+{
+
+    public static partial class SS_File
+    {
+
+        #region 二进制读取
+
+        /// <summary>
+        /// 读取文件：二进制文件读取
+        /// </summary>
+        /// <param name="path">路径</param>
+        /// <returns>return : Byte[]</returns>
+        public static byte[] GetFile_Bytes(string path)
+        {
+            return File.ReadAllBytes(path);
+        }
+
+        /// <summary>
+        /// 读取文件：二进制文件读取
+        /// </summary>
+        /// <param name="path">路径</param>
+        /// <returns>return : 字符串</returns>
+        public static byte[] GetFile_Bytes_WWW(string path)
+        {
+            string Name = path.Split(':')[0].ToUpper();
+            WWW www = new WWW(("http".ToUpper() == Name || "https".ToUpper() == Name) ? path : "file://" + path);
+            while (!www.isDone) { }
+            return www.bytes;
+        }
+
+        /// <summary>
+        /// 读取文件： 把二进制文件变成类
+        /// </summary>
+        /// <typeparam name="T">类型</typeparam>
+        /// <param name="path">文件路径</param>
+        /// <returns>return : 返回类</returns>
+        public static T GetFile_ByteObject<T>(string path)
+        {
+            byte[] bytes = File.ReadAllBytes(path);//读取文件所有内容
+            return Convert_BytesToObject<T>(bytes);//二进制变成类   
+        }
+
+        /// <summary>
+        /// 读取文件： 把二进制文件变成类
+        /// </summary>
+        /// <typeparam name="T">类型</typeparam>
+        /// <param name="path">文件路径</param>
+        /// <returns>return : 返回类</returns>
+        public static T GetFile_ByteObject_WWW<T>(string path)
+        {
+            string Name = path.Split(':')[0].ToUpper();
+            WWW www = new WWW(("http".ToUpper() == Name || "https".ToUpper() == Name) ? path : "file://" + path);
+            while (!www.isDone) { }
+            return Convert_BytesToObject<T>(www.bytes);//二进制变成类   
+        }
+
+        #endregion
+
+
+        #region 二进制写入
+
+        /// <summary>
+        /// 写入文件：二进制写入文件
+        /// </summary>
+        /// <param name="bytes">传入二进制数组</param>
+        /// <param name="path">文件路径</param>
+        public static void SetFile_byte(byte[] bytes, string path)
+        {
+            string Folder = path.Substring(0, path.LastIndexOf('/'));//去除文件名
+            Directory.CreateDirectory(Folder);//如果文件夹不存在就创建它
+            File.WriteAllBytes(path, bytes);//创建新文件
+        }
+
+        /// <summary>
+        /// 写入文件：把类变成二进制文件
+        /// </summary>
+        /// <param name="bytes">传入二进制数组</param>
+        /// <param name="path">文件路径</param>
+        public static void SetFile_byteObject<T>(T Object, string path)
+        {
+            string Folder = path.Substring(0, path.LastIndexOf('/'));//去除文件名
+            Directory.CreateDirectory(Folder);//如果文件夹不存在就创建它
+            File.WriteAllBytes(path, Convert_ObjectToBytes(Object));//创建新文件
+        }
+
+
+        #endregion
+
+
+
+
+        #region 二进制转换
+
+        /// <summary>
+        /// 使用UTF8编码将byte数组转成字符串
+        /// </summary>
+        /// <param name="data">byte数组</param>
+        /// <returns>字符串</returns>
+        public static string Convert_BytesToString(byte[] data)
+        {
+            return Encoding.UTF8.GetString(data, 0, data.Length);
+        }
+
+        /// <summary>
+        /// 使用指定字符编码将byte数组转成字符串
+        /// </summary>
+        /// <param name="data">byte数组</param>
+        /// <param name="encoding">指定字符编码</param>
+        /// <returns>字符串</returns>
+        public static string Convert_BytesToString(byte[] data, Encoding encoding)
+        {
+            return encoding.GetString(data, 0, data.Length);
+        }
+
+        /// <summary>
+        /// 使用UTF8编码将字符串转成byte数组
+        /// </summary>
+        /// <param name="str">字符串</param>
+        /// <returns>byte数组</returns>
+        public static byte[] Convert_StringToBytes(string str)
+        {
+            return Encoding.UTF8.GetBytes(str);
+        }
+
+        /// <summary>
+        /// 使用指定字符编码将字符串转成byte数组
+        /// </summary>
+        /// <param name="str">字符串</param>
+        /// <param name="encoding">指定字符编码</param>
+        /// <returns>byte数组</returns>
+        public static byte[] Convert_StringToBytes(string str, Encoding encoding)
+        {
+            return encoding.GetBytes(str);
+        }
+
+        #endregion
+
+
+        #region 序列化转换
+
+        /// <summary>
+        /// 将对象序列化为二进制数据:对象定义时需[Serializable]序列化
+        /// </summary>
+        /// <param name="obj">对象</param>
+        /// <returns>byte数组</returns>
+        public static byte[] Convert_ObjectToBytes<T>(T obj)
+        {
+            MemoryStream stream = new MemoryStream();
+            BinaryFormatter bf = new BinaryFormatter();
+            bf.Serialize(stream, obj);
+            byte[] data = stream.ToArray();
+            stream.Close();
+            return data;
+        }
+
+        /// <summary>
+        /// 将二进制数据反序列化
+        /// </summary>
+        /// <param name="data">byte数组</param>
+        /// <returns>对象</returns>
+        public static T Convert_BytesToObject<T>(byte[] data)
+        {
+            MemoryStream stream = new MemoryStream();
+            stream.Write(data, 0, data.Length);
+            stream.Position = 0;
+            BinaryFormatter bf = new BinaryFormatter();
+            T obj = (T)bf.Deserialize(stream);
+            stream.Close();
+            return obj;
+        }
+
+        /// <summary>
+        /// 通过二进制序列化深拷贝
+        /// </summary>
+        /// <param name="obj">拷贝对象</param>
+        /// <returns>返回对象</returns>
+        public static T DeepCopy<T>(T obj)
+        {
+            object NewObj;
+            MemoryStream stream = new MemoryStream();
+            BinaryFormatter bf = new BinaryFormatter();
+           
+            //序列化成流
+            bf.Serialize(stream, obj);
+            stream.Seek(0, SeekOrigin.Begin);//设置当前流正在读取的位置 为开始位置即从0开始
+
+            //反序列化成对象
+            NewObj = bf.Deserialize(stream);
+            stream.Close();//关闭流
+
+            return (T)NewObj;
+        }
+
+        #endregion
+
+
+
+    }
+
+}
\ No newline at end of file
diff --git a/SDHK_Tool/Static/File/SS_File_Byte.cs.meta b/SDHK_Tool/Static/File/SS_File_Byte.cs.meta
new file mode 100644
index 0000000..ba273f3
--- /dev/null
+++ b/SDHK_Tool/Static/File/SS_File_Byte.cs.meta
@@ -0,0 +1,13 @@
+fileFormatVersion: 2
+guid: ede07c2885922cc47ad0b6f353c2ef3b
+timeCreated: 1575365817
+licenseType: Pro
+MonoImporter:
+  externalObjects: {}
+  serializedVersion: 2
+  defaultReferences: []
+  executionOrder: 0
+  icon: {instanceID: 0}
+  userData: 
+  assetBundleName: 
+  assetBundleVariant: 
diff --git a/SDHK_Tool/Static/File/SS_File_Json.cs b/SDHK_Tool/Static/File/SS_File_Json.cs
new file mode 100644
index 0000000..1f31a61
--- /dev/null
+++ b/SDHK_Tool/Static/File/SS_File_Json.cs
@@ -0,0 +1,215 @@
+﻿using System;
+using System.IO;
+using System.Text.RegularExpressions;
+using LitJson;
+using UnityEngine;
+
+/*
+ * 作者：闪电Y黑客
+ * 
+ * 日期： 2019.12.3
+ * 
+ * 功能：SS_File的分支部分：对Json文件进行操作的方法
+ */
+
+namespace SDHK_Tool.Static
+{
+
+    public static partial class SS_File
+    {
+        #region Json读取
+
+        /// <summary>
+        /// 读取文件： 把Json文件变成类
+        /// </summary>
+        /// <typeparam name="T">类型</typeparam>
+        /// <param name="path">文件路径</param>
+        /// <returns>return : 返回类</returns>
+        public static T GetFile_JsonObject<T>(string path)
+        {
+            string str = File.ReadAllText(path);//读取文件所有内容
+            return Convert_JsonToObject<T>(str);//json变成类   
+        }
+
+        /// <summary>
+        /// 读取文件： 把Json文件变成json数据类
+        /// </summary>
+        /// <param name="path">文件路径</param>
+        /// <returns>return : 返回类数据</returns>
+        public static JsonData GetFile_JsonObject(string path)
+        {
+            string str = File.ReadAllText(path);//读取文件所有内容        
+            return Convert_JsonToObject(str);//json变成类   
+        }
+
+        /// <summary>
+        /// 读取文件：把Json文件变成json数据类
+        /// </summary>
+        /// <param name="path">路径</param>
+        /// <returns>return : 返回类数据</returns>
+        public static JsonData GetFile_JsonObject_WWW(string path)
+        {
+            string Name = path.Split(':')[0].ToUpper();
+            WWW www = new WWW(("http".ToUpper() == Name || "https".ToUpper() == Name) ? path : "file://" + path);
+            while (!www.isDone) { }
+            return Convert_JsonToObject(www.text);
+        }
+
+        /// <summary>
+        ///  读取文件： 把Json文件变成类
+        /// </summary>
+        /// <param name="path">路径</param>
+        /// <returns>return : 返回类</returns>
+        public static T GetFile_JsonObject_WWW<T>(string path)
+        {
+            string Name = path.Split(':')[0].ToUpper();
+            WWW www = new WWW(("http".ToUpper() == Name || "https".ToUpper() == Name) ? path : "file://" + path);
+            while (!www.isDone) { }
+            return Convert_JsonToObject<T>(www.text);
+        }
+        #endregion
+
+
+
+        #region Json写入
+
+        /// <summary>
+        /// 写入文件：把类变成json文件
+        /// </summary>
+        /// <typeparam name="T">类型</typeparam>
+        /// <param name="Object">传入类</param>
+        /// <param name="path">文件路径</param>
+        public static void SetFile_JsonObject<T>(T Object, string path)
+        {
+            string Folder = path.Substring(0, path.LastIndexOf('/'));//去除文件名
+            Directory.CreateDirectory(Folder);//如果文件夹不存在就创建它
+            File.WriteAllText(path, Convert_ObjectToJson(Object));//创建新文件
+        }
+
+        /// <summary>
+        /// 写入文件：把类变成json文件(缩进格式)
+        /// </summary>
+        /// <typeparam name="T">类型</typeparam>
+        /// <param name="Object">传入类</param>
+        /// <param name="path">文件路径</param>
+        public static void SetFile_JsonObject_Format<T>(T Object, string path)
+        {
+            string Folder = path.Substring(0, path.LastIndexOf('/'));//去除文件名
+            Directory.CreateDirectory(Folder);//如果文件夹不存在就创建它
+            File.WriteAllText(path, Convert_JsonFormat(Convert_ObjectToJson(Object)));//创建新文件
+        }
+        #endregion
+
+
+
+        #region json转换
+
+
+        /// <summary>
+        /// 乱码转换：用于解决LitJson把类转换成string时出现的乱码
+        /// </summary>
+        /// <param name="source">乱码字符串</param>
+        /// <returns>正常字符串</returns>
+        public static string Convert_String(string source)
+        {
+            return new Regex(@"\\u([0-9A-F]{4})", RegexOptions.IgnoreCase)
+            .Replace(source, x => string.Empty + Convert.ToChar(Convert.ToUInt16(x.Result("$1"), 16)));
+        }
+
+        /// <summary>
+        /// 将对象转换成json（封装LitJson）
+        /// </summary>
+        /// <param name="obj">实例化的对象</param>
+        /// <returns>return : Json字符串</returns>
+        public static string Convert_ObjectToJson<T>(T obj)
+        {
+            return Convert_String(JsonMapper.ToJson(obj));
+        }
+
+        /// <summary>
+        /// 将json转换成对象（封装LitJson）
+        /// </summary>
+        /// <typeparam name="T">类型</typeparam>
+        /// <param name="json">Json字符串</param>
+        /// <returns>return : 实例化的对象</returns>
+        public static T Convert_JsonToObject<T>(string json)
+        {
+            return JsonMapper.ToObject<T>(json);
+        }
+
+        /// <summary>
+        /// 将json转换成对象（封装LitJson）
+        /// </summary>
+        /// <param name="json">Json字符串</param>
+        /// <returns>return : 实例化的对象数据</returns>
+        public static JsonData Convert_JsonToObject(string json)
+        {
+            return JsonMapper.ToObject(json);
+        }
+
+        /// <summary>
+        /// 判断字符串是否为json格式
+        /// </summary>
+        /// <param name="json">要判断的json字符串</param>
+        /// <returns>return : bool</returns>
+        public static bool If_JsonString(string json)
+        {
+            try
+            {
+                JsonMapper.ToObject<object>(json);
+                return true;
+            }
+            catch
+            {
+                return false;
+            }
+        }
+
+
+        /// <summary>
+        /// 格式转换：将Json缩进整理，用于查看
+        /// </summary>
+        /// <param name="sourceJson">源Json字符串</param>
+        /// <returns>return : 整理后的Json字符串</returns>
+        public static string Convert_JsonFormat(string sourceJson)
+        {
+            sourceJson += " ";
+            int itap = 0;
+            string newjson = "";
+
+            for (int i = 0; i < sourceJson.Length - 1; i++)
+            {
+                if (sourceJson[i] == '{' || sourceJson[i] == '[')
+                {
+                    itap++;
+                    newjson += sourceJson[i] + "\n";
+                    for (int a = 0; a < itap; a++) { newjson += "\t"; }
+                }
+                else if ((sourceJson[i] == '}' || sourceJson[i] == ']'))
+                {
+                    itap--;
+                    newjson += "\n";
+                    for (int a = 0; a < itap; a++) { newjson += "\t"; }
+                    newjson += sourceJson[i] + "" + ((sourceJson[i + 1] == ',') ? "," : "") + "\n";
+                    if (sourceJson[i + 1] == ',') i++;
+                    for (int a = 0; a < itap; a++) { newjson += "\t"; }
+                }
+                else if (sourceJson[i] != '}' && sourceJson[i] != ']' && sourceJson[i + 1] == ',')
+                {
+                    newjson += sourceJson[i] + "" + sourceJson[i + 1] + "\n";
+                    i++;
+                    for (int a = 0; a < itap; a++) { newjson += "\t"; }
+                }
+                else
+                {
+                    newjson += sourceJson[i];
+                }
+            }
+            return newjson;
+        }
+
+        #endregion
+
+
+    }
+}
\ No newline at end of file
diff --git a/SDHK_Tool/Static/File/SS_File_Json.cs.meta b/SDHK_Tool/Static/File/SS_File_Json.cs.meta
new file mode 100644
index 0000000..227d8b0
--- /dev/null
+++ b/SDHK_Tool/Static/File/SS_File_Json.cs.meta
@@ -0,0 +1,13 @@
+fileFormatVersion: 2
+guid: 0b1361d333454e24280a8f550d0f9575
+timeCreated: 1575366945
+licenseType: Pro
+MonoImporter:
+  externalObjects: {}
+  serializedVersion: 2
+  defaultReferences: []
+  executionOrder: 0
+  icon: {instanceID: 0}
+  userData: 
+  assetBundleName: 
+  assetBundleVariant: 
diff --git a/SDHK_Tool/Static/File/SS_File_Path.cs b/SDHK_Tool/Static/File/SS_File_Path.cs
new file mode 100644
index 0000000..b66abe3
--- /dev/null
+++ b/SDHK_Tool/Static/File/SS_File_Path.cs
@@ -0,0 +1,259 @@
+﻿using System.Collections.Generic;
+using System.IO;
+using System.Linq;
+using UnityEngine;
+
+
+/*
+ * 作者：闪电Y黑客
+ * 
+ * 日期： 2019.12.3
+ * 
+ * 功能：SS_File的分支部分：对文件路径进行处理的方法
+ */
+
+namespace SDHK_Tool.Static
+{
+    public enum FileLocation //根节点枚举类
+    {
+        StreamingAssetsFolder,
+        DataFolder,
+        PeristentDataFolder
+    }
+
+    public static partial class SS_File
+    {
+
+        #region 文件路径读取
+
+        /// <summary>
+        /// 读取文件名字
+        /// </summary>
+        /// <param name="path">文件夹路径</param>
+        /// <returns>return : 文件名集合</returns>
+        public static List<string> GetNames_File(string path)
+        {
+            List<string> FileNames = new List<string>();
+            DirectoryInfo info = new DirectoryInfo(path);//读取路径文件夹文件
+            FileInfo[] infos = info.GetFiles();//读取所有文件名
+
+            foreach (FileInfo file in infos)//遍历每个文件
+            {
+                FileNames.Add(file.Name);//存入链表
+            }
+            return FileNames;
+        }
+
+        /// <summary>
+        /// 读取文件名字(后缀过滤)
+        /// </summary>
+        /// <param name="path">文件夹路径</param>
+        /// <param name="type">后缀名</param>
+        /// <returns>return : 文件名集合</returns>
+        public static List<string> GetNames_File(string path, string type)
+        {
+            List<string> FileNames = new List<string>();
+            DirectoryInfo info = new DirectoryInfo(path);//读取路径文件夹文件
+            FileInfo[] infos = info.GetFiles();//读取所有文件名
+            type = type.ToUpper();
+            foreach (FileInfo file in infos)//遍历每个文件
+            {
+                string[] fileName = file.Name.Split('.');
+                if (type == fileName[fileName.Length - 1].ToUpper()) FileNames.Add(file.Name);//存入链表        
+            }
+            return FileNames;
+        }
+
+        /// <summary>
+        /// 读取文件名字(后缀集合过滤)
+        /// </summary>
+        /// <param name="path">文件夹路径</param>
+        /// <param name="types">后缀集合</param>
+        /// <returns>return : 文件名集合</returns>
+        public static List<string> GetNames_File(string path, string[] types)
+        {
+            List<string> FileNames = new List<string>();
+            DirectoryInfo info = new DirectoryInfo(path);//读取路径文件夹文件
+            FileInfo[] infos = info.GetFiles();//读取所有文件名
+
+            foreach (FileInfo file in infos)//遍历每个文件
+            {
+                string[] fileName = file.Name.Split('.');
+                foreach (var type in types)
+                {
+                    if (type.ToUpper() == fileName[fileName.Length - 1].ToUpper()) FileNames.Add(file.Name);//存入链表
+                }
+
+            }
+            return FileNames;
+        }
+
+        /// <summary>
+        /// 读取文件路径
+        /// </summary>
+        /// <param name="path">文件夹</param>
+        /// <returns>return : 文件路径集合</returns>
+        public static List<string> GetPaths_File(string path)
+        {
+            return new List<string>(System.IO.Directory.GetFiles(path));
+        }
+
+        /// <summary>
+        /// 读取文件路径（后缀过滤）
+        /// </summary>
+        /// <param name="path">文件夹</param>
+        /// <param name="type">后戳名</param>
+        /// <returns>return : 文件路径集合</returns>
+        public static List<string> GetPaths_File(string path, string type)
+        {
+            List<string> FileNames = new List<string>();
+            foreach (var filePath in System.IO.Directory.GetFiles(path))//读取所有文件
+            {
+                string[] fileName = filePath.Split('.');//分隔
+                if (type.ToUpper() == fileName[fileName.Length - 1].ToUpper())//判断后缀相等
+                    FileNames.Add(filePath);//存入链表        
+            }
+            return FileNames;
+        }
+
+        /// <summary>
+        /// 读取文件路径（后缀集合过滤）
+        /// </summary>
+        /// <param name="path">文件夹</param>
+        /// <param name="type">后戳集合</param>
+        /// <returns>return : 文件路径集合</returns>
+        public static List<string> GetPaths_File(string path, string[] types)
+        {
+            List<string> FileNames = new List<string>();
+            foreach (var filePath in System.IO.Directory.GetFiles(path))//读取所有文件
+            {
+                string[] fileName = filePath.Split('.');//分隔
+                foreach (var type in types)
+                {
+                    if (type.ToUpper() == fileName[fileName.Length - 1].ToUpper())//判断后缀相等
+                        FileNames.Add(filePath);//存入链表        
+                }
+            }
+            return FileNames;
+        }
+
+
+        /// <summary>
+        /// 获取枚举路径
+        /// </summary>
+        /// <param name="location">路径枚举</param>
+        /// <returns>路径</returns>
+        public static string GetPath(FileLocation location)
+        {
+            string result = string.Empty;
+            switch (location)
+            {
+                case FileLocation.DataFolder:
+                    result = Application.dataPath;
+                    break;
+                case FileLocation.StreamingAssetsFolder:
+                    result = Application.streamingAssetsPath;
+                    break;
+                case FileLocation.PeristentDataFolder:
+                    result = Application.persistentDataPath;
+                    break;
+            }
+            return result;
+        }
+
+        #endregion
+
+
+
+        #region 文件夹路径读取
+        /// <summary>
+        /// 读取文件夹名字
+        /// </summary>
+        /// <param name="path">文件夹路径</param>
+        /// <returns>return : 文件夹名集合</returns>
+        public static List<string> GetNames_Folder(string path)
+        {
+            List<string> FolderNames = new List<string>();
+            DirectoryInfo[] dirInfo = new DirectoryInfo(path).GetDirectories();
+            foreach (var Folder in dirInfo)
+            {
+                FolderNames.Add(Folder.Name);
+            }
+            return FolderNames;
+        }
+
+        /// <summary>
+        /// 读取文件夹路径
+        /// </summary>
+        /// <param name="path">文件夹</param>
+        /// <returns>return : 文件路径集合</returns>
+        public static List<string> GetPaths_Folder(string path)
+        {
+            List<string> FolderNames = new List<string>();
+            DirectoryInfo[] dirInfo = new DirectoryInfo(path).GetDirectories();
+            foreach (var Folder in dirInfo)
+            {
+                FolderNames.Add(path + "/" + Folder.Name);
+            }
+            return FolderNames;
+        }
+
+        #endregion
+
+        #region 路径新建
+
+        /// <summary>
+        /// 文件夹路径创建
+        /// </summary>
+        /// <param name="path">要创建的路径</param>
+        public static void Path_New(string path)
+        {
+            Directory.CreateDirectory(path);//如果文件夹不存在就创建它
+        }
+
+        #endregion
+
+        #region 路径删除
+
+        /// <summary>
+        /// 文件夹路径删除
+        /// </summary>
+        /// <param name="path">要删除的路径</param>
+        /// <param name="Mode">（true/false）删除子路径/删除文件夹</param>
+        public static void Path_Delete(string path, bool Mode = true)
+        {
+            if (Mode)
+            {
+                Directory.GetFiles(path).ToList().ForEach(File.Delete);
+                Directory.GetDirectories(path).ToList().ForEach(Directory.Delete);
+            }
+            else
+            {
+                Directory.Delete(path, true);
+            }
+        }
+
+        #endregion
+
+        /// <summary>
+        /// 判断文件路径是否存在
+        /// </summary>
+        /// <param name="path">路径</param>
+        /// <returns>bool</returns>
+        public static bool FilePath_IF(string path)
+        {
+            return File.Exists(path);
+        }
+
+        /// <summary>
+        /// 判断文件夹路径是否存在
+        /// </summary>
+        /// <param name="path">路径</param>
+        /// <returns>bool</returns>
+        public static bool Path_IF(string path)
+        {
+            return Directory.Exists(path);
+        }
+
+    }
+}
\ No newline at end of file
diff --git a/SDHK_Tool/Static/File/SS_File_Path.cs.meta b/SDHK_Tool/Static/File/SS_File_Path.cs.meta
new file mode 100644
index 0000000..67f33d1
--- /dev/null
+++ b/SDHK_Tool/Static/File/SS_File_Path.cs.meta
@@ -0,0 +1,13 @@
+fileFormatVersion: 2
+guid: a751eca14d65e2842b7871e62a549799
+timeCreated: 1574414359
+licenseType: Pro
+MonoImporter:
+  externalObjects: {}
+  serializedVersion: 2
+  defaultReferences: []
+  executionOrder: 0
+  icon: {instanceID: 0}
+  userData: 
+  assetBundleName: 
+  assetBundleVariant: 
diff --git a/SDHK_Tool/Static/File/SS_File_Text.cs b/SDHK_Tool/Static/File/SS_File_Text.cs
new file mode 100644
index 0000000..fa6fe20
--- /dev/null
+++ b/SDHK_Tool/Static/File/SS_File_Text.cs
@@ -0,0 +1,68 @@
+﻿using System.IO;
+using UnityEngine;
+
+/*
+ * 作者：闪电Y黑客
+ * 
+ * 日期： 2019.12.3
+ * 
+ * 功能：SS_File的分支部分：对Text文本文件进行操作的方法
+ */
+
+namespace SDHK_Tool.Static
+{
+
+    public static partial class SS_File
+    {
+        #region 字符串读取
+
+        /// <summary>
+        /// 读取文件：字符串读取
+        /// </summary>
+        /// <param name="path">路径</param>
+        /// <returns>return : 字符串</returns>
+        public static string GetFile_String(string path)
+        {
+            return File.ReadAllText(path);
+        }
+
+        /// <summary>
+        /// 读取文件：字符串读取
+        /// </summary>
+        /// <param name="path">路径</param>
+        /// <returns>return : 字符串</returns>
+        public static string GetFile_String_WWW(string path)
+        {
+            string Name = path.Split(':')[0].ToUpper();
+            WWW www = new WWW(("http".ToUpper() == Name || "https".ToUpper() == Name) ? path : "file://" + path);
+            while (!www.isDone) { }
+            return www.text;
+        }
+
+        #endregion
+
+
+        #region 字符串写入
+
+        /// <summary>
+        /// 写入文件：字符串写入文件
+        /// </summary>
+        /// <param name="str">传入字符串</param>
+        /// <param name="path">文件路径</param>
+        public static void SetFile_String(string str, string path)
+        {
+            string Folder = path.Substring(0, path.LastIndexOf('/'));//去除文件名
+            Directory.CreateDirectory(Folder);//如果文件夹不存在就创建它
+            File.WriteAllText(path, str);//创建新文件
+        }
+
+        #endregion
+
+    }
+
+
+
+
+
+
+}
\ No newline at end of file
diff --git a/SDHK_Tool/Static/File/SS_File_Text.cs.meta b/SDHK_Tool/Static/File/SS_File_Text.cs.meta
new file mode 100644
index 0000000..37ec890
--- /dev/null
+++ b/SDHK_Tool/Static/File/SS_File_Text.cs.meta
@@ -0,0 +1,13 @@
+fileFormatVersion: 2
+guid: 3a1822c506be80449b674a88cb67f4b7
+timeCreated: 1575365318
+licenseType: Pro
+MonoImporter:
+  externalObjects: {}
+  serializedVersion: 2
+  defaultReferences: []
+  executionOrder: 0
+  icon: {instanceID: 0}
+  userData: 
+  assetBundleName: 
+  assetBundleVariant: 
diff --git a/SDHK_Tool/Static/File/SS_File_Texture.cs b/SDHK_Tool/Static/File/SS_File_Texture.cs
new file mode 100644
index 0000000..ec8085a
--- /dev/null
+++ b/SDHK_Tool/Static/File/SS_File_Texture.cs
@@ -0,0 +1,294 @@
+﻿using System.Collections.Generic;
+using System.IO;
+using UnityEngine;
+using ZXing;
+using ZXing.QrCode;
+
+/*
+ * 作者：闪电Y黑客
+ * 
+ * 日期： 2019.12.3
+ * 
+ * 功能：SS_File的分支部分：对图片文件进行操作的方法
+ */
+
+namespace SDHK_Tool.Static
+{
+
+    public static partial class SS_File
+    {
+
+        #region 图片读取
+        /// <summary>
+        /// 读取文件：图片读取
+        /// </summary>
+        /// <param name="path">路径</param>
+        /// <returns>return : 图片</returns>
+        public static Texture2D GetFile_Texture2D_WWW(string path)
+        {
+            string Name = path.Split(':')[0].ToUpper();
+            WWW www = new WWW(("http".ToUpper() == Name || "https".ToUpper() == Name) ? path : "file://" + path);
+            while (!www.isDone) { }
+            return www.texture;
+        }
+
+        /// <summary>
+        /// 读取文件：精灵图片读取
+        /// </summary>
+        /// <param name="path">路径</param>
+        /// <returns>return : 精灵图片</returns>
+        public static Sprite GetFile_Sprite_WWW(string path)
+        {
+            string Name = path.Split(':')[0].ToUpper();
+            WWW www = new WWW(("http".ToUpper() == Name || "https".ToUpper() == Name) ? path : "file://" + path);
+            while (!www.isDone) { }
+            return Sprite.Create(www.texture, new Rect(0, 0, www.texture.width, www.texture.height), Vector2.zero);
+        }
+
+
+        /// <summary>
+        /// 读取文件：图片读取
+        /// </summary>
+        /// <param name="path">路径</param>
+        /// <returns>return : 图片</returns>
+        public static Texture2D GetFile_Texture2D(string path)
+        {
+            //创建文件读取流
+            FileStream fileStream = new FileStream(path, FileMode.Open, FileAccess.Read);
+            fileStream.Seek(0, SeekOrigin.Begin);
+            //创建文件长度缓冲区
+            byte[] bytes = new byte[fileStream.Length];
+            //读取文件
+            fileStream.Read(bytes, 0, (int)fileStream.Length);
+            //释放文件读取流
+            fileStream.Close();
+            fileStream.Dispose();
+            fileStream = null;
+            //创建Texture
+            Texture2D texture = new Texture2D(0, 0);
+            texture.LoadImage(bytes);
+            return texture;
+        }
+
+        /// <summary>
+        /// 读取文件：图片批量读取
+        /// </summary>
+        /// <param name="paths">路径集合</param>
+        /// <returns>return : 图片集合</returns>
+        public static List<Texture2D> GetFile_Texture2D(List<string> paths)
+        {
+            List<Texture2D> Texture2Ds = new List<Texture2D>();
+            foreach (string Path in paths)
+            {
+                Texture2Ds.Add(GetFile_Texture2D(Path));
+            }
+            return Texture2Ds;
+        }
+
+        /// <summary>
+        /// 读取文件：图片批量读取(后缀过滤)
+        /// </summary>
+        /// <param name="Paths">路径集合</param>
+        /// <param name="type">后戳名</param>
+        /// <returns>return : 图片集合</returns>
+        public static List<Texture2D> GetFile_Texture2D(string path, string type)
+        {
+            return GetFile_Texture2D(GetPaths_File(path, type));
+        }
+
+        /// <summary>
+        /// 读取文件：图片批量读取(后缀集合过滤)
+        /// </summary>
+        /// <param name="Paths">路径集合</param>
+        /// <param name="types">后戳集合</param>
+        /// <returns>return : 图片集合</returns>
+        public static List<Texture2D> GetFile_Texture2D(string path, string[] types)
+        {
+            return GetFile_Texture2D(GetPaths_File(path, types));
+        }
+
+
+
+
+        /// <summary>
+        /// 读取文件：精灵图片读取
+        /// </summary>
+        /// <param name="path">路径</param>
+        /// <returns>return : 精灵图片</returns>
+        public static Sprite GetFile_Sprite(string path)
+        {
+            Texture2D texture = GetFile_Texture2D(path);
+            //创建Sprite
+            Sprite sprite = Sprite.Create(texture, new Rect(0, 0, texture.width, texture.height), Vector2.zero);
+            return sprite;
+        }
+
+        /// <summary>
+        /// 读取文件：精灵图片批量读取
+        /// </summary>
+        /// <param name="paths">路径集合</param>
+        /// <returns>return : 精灵图片集合</returns>
+        public static List<Sprite> GetFile_Sprite(List<string> paths)
+        {
+            List<Sprite> Sprites = new List<Sprite>();
+            foreach (string Path in paths)
+            {
+                Sprites.Add(GetFile_Sprite(Path));
+            }
+            return Sprites;
+        }
+
+        /// <summary>
+        /// 读取文件：精灵图片批量读取（后缀过滤）
+        /// </summary>
+        /// <param name="Paths">路径集合</param>
+        /// <param name="type">后戳名</param>
+        /// <returns>return : 精灵图片集合</returns>
+        public static List<Sprite> GetFile_Sprite(string path, string type)
+        {
+            return GetFile_Sprite(GetPaths_File(path, type));
+        }
+
+        /// <summary>
+        /// 读取文件：精灵图片批量读取（后缀集合过滤）
+        /// </summary>
+        /// <param name="Paths">路径集合</param>
+        /// <param name="types">后戳集合</param>
+        /// <returns>return : 精灵图片集合</returns>
+        public static List<Sprite> GetFile_Sprite(string path, string[] types)
+        {
+            return GetFile_Sprite(GetPaths_File(path, types));
+        }
+        #endregion
+
+
+
+        #region 图片写入
+        /// <summary>
+        /// 写入文件：图片保存为JPG
+        /// </summary>
+        /// <param name="texture2D">Texture2D图片纹理</param>
+        /// <param name="path">保存路径</param>
+        public static void SetFile_Texture2D_JPG(Texture2D texture2D, string path)
+        {
+            string Folder = path.Substring(0, path.LastIndexOf('/'));//去除文件名
+            Directory.CreateDirectory(Folder);//如果文件夹不存在就创建它
+            byte[] imageTytes = texture2D.EncodeToJPG();
+            File.WriteAllBytes(path, imageTytes);
+        }
+
+        /// <summary>
+        /// 写入文件：图片保存为PNG
+        /// </summary>
+        /// <param name="texture2D">Texture2D图片纹理</param>
+        /// <param name="path">保存路径</param>
+        public static void SetFile_Texture2D_PNG(Texture2D texture2D, string path)
+        {
+            string Folder = path.Substring(0, path.LastIndexOf('/'));//去除文件名
+            Directory.CreateDirectory(Folder);//如果文件夹不存在就创建它
+            byte[] imageTytes = texture2D.EncodeToPNG();
+            File.WriteAllBytes(path, imageTytes);
+        }
+        #endregion
+
+
+
+
+        #region 二维码转换
+
+        /// <summary>
+        /// 将字符串转换为二维码图片
+        /// </summary>
+        /// <param name="Str">字符串（网址）</param>
+        /// <returns>return : 二维码图片</returns>
+        public static Texture2D Convert_StrToQrcodeTexture2D(string Str)
+        {
+            Texture2D encoded = new Texture2D(256, 256);
+
+            QrCodeEncodingOptions qrEncodeOption = new ZXing.QrCode.QrCodeEncodingOptions();
+            qrEncodeOption.CharacterSet = "UTF-8"; //设置编码格式，否则读取'中文'乱码
+            qrEncodeOption.Height = encoded.height;
+            qrEncodeOption.Width = encoded.width;
+            qrEncodeOption.Margin = 0; //设置周围空白边距
+
+            var writer = new BarcodeWriter
+            {
+                Format = BarcodeFormat.QR_CODE,
+                Options = qrEncodeOption
+            };
+            encoded.SetPixels32(writer.Write(Str));
+            encoded.Apply();
+            return encoded;
+        }
+
+        /// <summary>
+        /// 将字符串转换为二维码精灵图片
+        /// </summary>
+        /// <param name="Str">字符串（网址）</param>
+        /// <returns>return : 二维码精灵图片</returns>
+        public static Sprite Convert_StrToQrcodeSprite(string Str)
+        {
+            Texture2D encoded = Convert_StrToQrcodeTexture2D(Str);
+            return Sprite.Create(encoded, new Rect(0, 0, encoded.width, encoded.height), Vector2.zero);
+        }
+
+
+        /// <summary>
+        /// 将二维码转为字符串
+        /// </summary>
+        /// <param name="texture">二维码图片</param>
+        /// <returns>return : 字符串</returns>
+        public static string Convert_QrcodeTexture2DToStr(Texture2D texture)
+        {
+            BarcodeReader mReader = new BarcodeReader();
+            var result = mReader.Decode(texture.GetPixels32(), texture.width, texture.height);
+            return (result != null) ? result.Text : null;
+        }
+
+
+
+        #endregion
+
+        /// <summary>
+        /// 压缩图片
+        /// </summary>
+        /// <param name="tex">原图片</param>
+        /// <param name="width">宽</param>
+        /// <param name="height">高</param>
+        /// <returns>压缩后的图片</returns>
+        public static Texture2D ReSetTextureSize(Texture2D tex, int width, int height)
+        {
+            var rendTex = new RenderTexture(width, height, 24, RenderTextureFormat.ARGB32);
+            rendTex.Create();
+            Graphics.SetRenderTarget(rendTex);
+            GL.PushMatrix();
+            GL.Clear(true, true, Color.clear);
+            GL.PopMatrix();
+            var mat = new Material(Shader.Find("Unlit/Transparent"));
+            mat.mainTexture = tex;
+            Graphics.SetRenderTarget(rendTex);
+            GL.PushMatrix();
+            GL.LoadOrtho();
+            mat.SetPass(0);
+            GL.Begin(GL.QUADS);
+            GL.TexCoord2(0, 0);
+            GL.Vertex3(0, 0, 0);
+            GL.TexCoord2(0, 1);
+            GL.Vertex3(0, 1, 0);
+            GL.TexCoord2(1, 1);
+            GL.Vertex3(1, 1, 0);
+            GL.TexCoord2(1, 0);
+            GL.Vertex3(1, 0, 0);
+            GL.End();
+            GL.PopMatrix();
+            var finalTex = new Texture2D(rendTex.width, rendTex.height, TextureFormat.ARGB32, false);
+            RenderTexture.active = rendTex;
+            finalTex.ReadPixels(new Rect(0, 0, finalTex.width, finalTex.height), 0, 0);
+            finalTex.Apply();
+            return finalTex;
+        }
+
+
+
+    }
+}
\ No newline at end of file
diff --git a/SDHK_Tool/Static/File/SS_File_Xml.cs b/SDHK_Tool/Static/File/SS_File_Xml.cs
new file mode 100644
index 0000000..d437b82
--- /dev/null
+++ b/SDHK_Tool/Static/File/SS_File_Xml.cs
@@ -0,0 +1,139 @@
+﻿using System.IO;
+using System.Text;
+using System.Xml;
+using System.Xml.Serialization;
+using UnityEngine;
+
+/*
+ * 作者：闪电Y黑客
+ * 
+ * 日期： 2019.12.3
+ * 
+ * 功能：SS_File的分支部分：对Xml文件进行操作的方法
+ */
+
+
+namespace SDHK_Tool.Static
+{
+    public static partial class SS_File
+    {
+
+        #region Xml读取
+
+        /// <summary>
+        /// 读取文件： 把Xml文件变成类
+        /// </summary>
+        /// <typeparam name="T">类型</typeparam>
+        /// <param name="path">文件路径</param>
+        /// <returns>return : 返回类</returns>
+        public static T GetFile_XmlObject<T>(string path)
+        {
+            string str = File.ReadAllText(path);//读取文件所有内容
+            return Convert_XmlToObject<T>(str);//Xml变成类   
+        }
+
+        /// <summary>
+        /// 读取文件： 把Xml文件变成类
+        /// </summary>
+        /// <typeparam name="T">类型</typeparam>
+        /// <param name="path">文件路径</param>
+        /// <returns>return : 返回类</returns>
+        public static T GetFile_XmlObject_WWW<T>(string path)
+        {
+            string Name = path.Split(':')[0].ToUpper();
+            WWW www = new WWW(("http".ToUpper() == Name || "https".ToUpper() == Name) ? path : "file://" + path);
+            while (!www.isDone) { }
+            return Convert_XmlToObject<T>(www.text);//Xml变成类   
+        }
+
+        #endregion
+
+        #region Xml写入
+
+        /// <summary>
+        /// 写入文件：把类变成Xml文件
+        /// </summary>
+        /// <typeparam name="T">类型</typeparam>
+        /// <param name="Object">传入类</param>
+        /// <param name="path">文件路径</param>
+        public static void SetFile_XmlObject<T>(T Object, string path)
+        {
+            string Folder = path.Substring(0, path.LastIndexOf('/'));//去除文件名
+            Directory.CreateDirectory(Folder);//如果文件夹不存在就创建它
+            File.WriteAllText(path, Convert_ObjectToXml(Object));//创建新文件
+        }
+
+        #endregion
+
+
+        #region 序列化转换Xml
+
+        /// <summary>
+        /// 将对象序列化为XML数据(转String写入文件)
+        /// </summary>
+        /// <param name="obj">对象</param>
+        /// <returns>XML数据byte数组</returns>
+        public static byte[] Convert_ObjectToXml_Byte<T>(T obj)
+        {
+            MemoryStream stream = new MemoryStream();
+            XmlSerializer xs = new XmlSerializer(obj.GetType());
+            xs.Serialize(stream, obj);
+            byte[] data = stream.ToArray();
+            stream.Close();
+            return data;
+        }
+
+        /// <summary>
+        /// 将对象序列化为XML数据
+        /// </summary>
+        /// <param name="obj">对象</param>
+        /// <returns>XML数据字符串</returns>
+        public static string Convert_ObjectToXml<T>(T obj)
+        {
+            MemoryStream stream = new MemoryStream();
+            XmlSerializer xs = new XmlSerializer(obj.GetType());
+            XmlTextWriter textWriter = new XmlTextWriter(stream,Encoding.GetEncoding("UTF-8"));//定义输出的编码格式
+            xs.Serialize(textWriter, obj);
+            byte[] data = stream.ToArray();
+            stream.Close();
+            return Encoding.UTF8.GetString(data, 0, data.Length);
+        }
+
+        /// <summary>
+        /// 将XML数据反序列化为指定类型对象(转bytes为对象)
+        /// </summary>
+        /// <param name="data">XML数据byte数组</param>
+        /// <returns>对象</returns>
+        public static T Convert_XmlToObject<T>(byte[] data)
+        {
+            MemoryStream stream = new MemoryStream();
+            stream.Write(data, 0, data.Length);
+            stream.Position = 0;
+            XmlSerializer xs = new XmlSerializer(typeof(T));
+            object obj = xs.Deserialize(stream);
+            stream.Close();
+            return (T)obj;
+        }
+
+        /// <summary>
+        /// 将XML数据反序列化为指定类型对象(转String为对象)
+        /// </summary>
+        /// <param name="str">XML数据字符串</param>
+        /// <returns>对象</returns>
+        public static T Convert_XmlToObject<T>(string str)
+        {
+            MemoryStream stream = new MemoryStream();
+            byte[] data = Convert_StringToBytes(str);
+            stream.Write(data, 0, data.Length);
+            stream.Position = 0;
+            XmlSerializer xs = new XmlSerializer(typeof(T));
+            object obj = xs.Deserialize(stream);
+            stream.Close();
+            return (T)obj;
+        }
+
+        #endregion
+
+
+    }
+}
\ No newline at end of file
diff --git a/SDHK_Tool/Static/File/SS_File_Xml.cs.meta b/SDHK_Tool/Static/File/SS_File_Xml.cs.meta
new file mode 100644
index 0000000..b22f79e
--- /dev/null
+++ b/SDHK_Tool/Static/File/SS_File_Xml.cs.meta
@@ -0,0 +1,13 @@
+fileFormatVersion: 2
+guid: 19d36cb031ae25d4ca20b623b5b0f042
+timeCreated: 1575367146
+licenseType: Pro
+MonoImporter:
+  externalObjects: {}
+  serializedVersion: 2
+  defaultReferences: []
+  executionOrder: 0
+  icon: {instanceID: 0}
+  userData: 
+  assetBundleName: 
+  assetBundleVariant: 
diff --git a/SDHK_Tool/Static/Mathf/SS_Mathf.cs.meta b/SDHK_Tool/Static/Mathf/SS_Mathf.cs.meta
new file mode 100644
index 0000000..cf817f1
--- /dev/null
+++ b/SDHK_Tool/Static/Mathf/SS_Mathf.cs.meta
@@ -0,0 +1,13 @@
+fileFormatVersion: 2
+guid: fb445fab951bdb14baa366c3725eeb18
+timeCreated: 1562149719
+licenseType: Free
+MonoImporter:
+  externalObjects: {}
+  serializedVersion: 2
+  defaultReferences: []
+  executionOrder: 0
+  icon: {instanceID: 0}
+  userData: 
+  assetBundleName: 
+  assetBundleVariant: 
diff --git a/SDHK_Tool/Static/Mathf/SS_Mathf_Clamp.cs b/SDHK_Tool/Static/Mathf/SS_Mathf_Clamp.cs
new file mode 100644
index 0000000..500fdc1
--- /dev/null
+++ b/SDHK_Tool/Static/Mathf/SS_Mathf_Clamp.cs
@@ -0,0 +1,334 @@
+﻿using UnityEngine;
+
+/*
+ * 作者：闪电Y黑客
+ * 
+ * 日期： 2019.01.17 
+ *
+ * 创建源于炮塔旋转限制，用于限制旋转角度，而后扩展为数值限制工具
+ *
+ * 2019.6.11 从 MyTool 转到 SDHK_Tool 
+ *
+ * 2020.02.28 合并到 SS_Mathf 里
+ * 
+ * 功能：对向量和欧拉角进行约束 
+ */
+
+
+namespace SDHK_Tool.Static
+{
+    /// <summary>
+    /// 向量约束器                                      
+    /// </summary>
+    public static partial class SS_Mathf
+    {
+
+        #region 一维
+
+        /// <summary>
+        /// 数值约束
+        /// </summary>
+        /// <param name="Current">当前数值</param>
+        /// <param name="Limit_Min">最小值</param>
+        /// <param name="Limit_Max">最大值</param>
+        /// <returns>return ：约束后的数值</returns>
+        public static float Clamp_Vector1(float Current, float Limit_Min, float Limit_Max)
+        {
+            return Mathf.Clamp(Current, Limit_Min, Limit_Max);
+        }
+
+        /// <summary>
+        /// 数值范围约束
+        /// </summary>
+        /// <param name="Current">当前数值</param>
+        /// <param name="TargetPoint">约束点</param>
+        /// <param name="Limit_Radius">限制半径</param>
+        /// <returns>return ：约束后的数值</returns>
+        public static float Clamp_Vector1_Scope(float Current, float TargetPoint, float Limit_Radius)
+        {
+            return Mathf.Clamp(Current, TargetPoint - Limit_Radius, TargetPoint + Limit_Radius);
+        }
+
+
+        #endregion
+
+
+        #region 二维
+
+        //tranframe 范围
+
+
+        /// <summary>
+        /// 二维向量约束
+        /// </summary>
+        /// <param name="Current">当前向量</param>
+        /// <param name="Limit_Min">最小值</param>
+        /// <param name="Limit_Max">最大值</param>
+        /// <returns>return ：约束后的向量</returns>
+        public static Vector2 Clamp_Vector2(Vector2 Current, Vector2 Limit_Min, Vector2 Limit_Max)
+        {
+            Current.x = Mathf.Clamp(Current.x, Limit_Min.x, Limit_Max.x);
+            Current.y = Mathf.Clamp(Current.y, Limit_Min.y, Limit_Max.y);
+            return Current;
+        }
+
+        /// <summary>
+        /// 二维向量约束[轴可控式]
+        /// </summary>
+        /// <param name="Current">当前向量</param>
+        /// <param name="Limit_Min">最小值</param>
+        /// <param name="Limit_Max">最大值</param>
+        /// <param name="Limit_X">X轴限制激活</param>
+        /// <param name="Limit_Y">Y轴限制激活</param>
+        /// <returns>return ：约束后的向量</returns>
+        /// 
+        public static Vector2 Clamp_Vector2(Vector2 Current, Vector2 Limit_Min, Vector2 Limit_Max, bool Limit_X = true, bool Limit_Y = true)
+        {
+            if (Limit_X) Current.x = Mathf.Clamp(Current.x, Limit_Min.x, Limit_Max.x);
+            if (Limit_Y) Current.y = Mathf.Clamp(Current.y, Limit_Min.y, Limit_Max.y);
+            return Current;
+        }
+
+
+
+        /// <summary>
+        /// 二维向量圆形范围约束
+        /// </summary>
+        /// <param name="Current">当前向量</param>
+        /// <param name="TargetPoint">约束点</param>
+        /// <param name="Limit_Radius">限制半径</param>
+        /// <returns>return ：约束后的向量</returns>
+        public static Vector2 Clamp_Vector2_Scope(Vector2 Current, Vector2 TargetPoint, float Limit_Radius)
+        {
+            Vector2 PointsToCurrent = Current - TargetPoint;
+            return (PointsToCurrent.magnitude > Limit_Radius) ? (PointsToCurrent.normalized * Limit_Radius) + TargetPoint : Current;
+        }
+
+        #endregion
+
+
+        #region 三维
+
+        /// <summary>
+        /// 三维向量约束
+        /// </summary>
+        /// <param name="Current">当前向量</param>
+        /// <param name="Limit_Min">最小值</param>
+        /// <param name="Limit_Max">最大值</param>
+        /// <returns>return ：约束后的向量</returns>
+        public static Vector3 Clamp_Vector3(Vector3 Current, Vector3 Limit_Min, Vector3 Limit_Max)
+        {
+            Current.x = Mathf.Clamp(Current.x, Limit_Min.x, Limit_Max.x);
+            Current.y = Mathf.Clamp(Current.y, Limit_Min.y, Limit_Max.y);
+            Current.z = Mathf.Clamp(Current.z, Limit_Min.z, Limit_Max.z);
+            return Current;
+        }
+
+        /// <summary>
+        /// 三维向量约束[轴可控式]
+        /// </summary>
+        /// <param name="Current">当前向量</param>
+        /// <param name="Limit_Min">最小值</param>
+        /// <param name="Limit_Max">最大值</param>
+        /// <param name="Limit_X">X轴限制激活</param>
+        /// <param name="Limit_Y">Y轴限制激活</param>
+        /// <param name="Limit_Z">Z轴限制激活</param>
+        /// <returns>return ：约束后的向量</returns>
+        public static Vector3 Clamp_Vector3(Vector3 Current, Vector3 Limit_Min, Vector3 Limit_Max, bool Limit_X = true, bool Limit_Y = true, bool Limit_Z = true)
+        {
+            if (Limit_X) Current.x = Mathf.Clamp(Current.x, Limit_Min.x, Limit_Max.x);
+            if (Limit_Y) Current.y = Mathf.Clamp(Current.y, Limit_Min.y, Limit_Max.y);
+            if (Limit_Z) Current.z = Mathf.Clamp(Current.z, Limit_Min.z, Limit_Max.z);
+            return Current;
+        }
+
+        /// <summary>
+        /// 三维向量球形范围约束
+        /// </summary>
+        /// <param name="Current">当前向量</param>
+        /// <param name="TargetPoint">约束点</param>
+        /// <param name="Limit_Radius">限制半径</param>
+        /// <returns>return ：约束后的向量</returns>
+        public static Vector3 Clamp_Vector3_Scope(Vector3 Current, Vector3 TargetPoint, float Limit_Radius)
+        {
+            Vector3 PointsToCurrent = Current - TargetPoint;
+            return (PointsToCurrent.magnitude > Limit_Radius) ? (PointsToCurrent.normalized * Limit_Radius) + TargetPoint : Current;
+        }
+
+
+        #endregion
+
+
+        #region 角度
+
+        /// <summary>
+        /// 角度约束（以0为起点的约束）                                  
+        ///【注意：组件上的欧拉角 X 轴是经过计算的，最大值为+-90度，谨慎使用】
+        /// </summary>
+        /// <param name="CurrentAngle">当前角度</param>
+        /// <param name="Limit_Min">最小值</param>
+        /// <param name="Limit_Max">最大值</param>
+        /// <returns>return ：约束后的角度（正负180度）</returns>
+        public static float Clamp_Angle(float CurrentAngle, float Limit_Min, float Limit_Max)
+        {
+            CurrentAngle = SS_EulerAngleConversion.Angle_PN_To_PN180(CurrentAngle);
+
+            return Mathf.Clamp(CurrentAngle, Limit_Min, Limit_Max);
+        }
+
+        /// <summary>
+        /// 角度约束(全面角度约束)                                    
+        ///【注意：组件上的欧拉角 X 轴是经过计算的，最大值为+-90度，谨慎使用】
+        /// </summary>
+        /// <param name="CurrentAngle">当前角度</param>
+        /// <param name="Limit_Min">最小值</param>
+        /// <param name="Limit_Max">最大值</param>
+        /// <returns>return ：约束后的角度</returns>
+        public static float Clamp_Angle_Complete(float CurrentAngle, float Limit_Min, float Limit_Max)
+        {
+
+            float MinToMax = Mathf.DeltaAngle(Limit_Min, Limit_Max);//获得+-180差值
+
+            MinToMax = SS_EulerAngleConversion.Angle_PN_To_P360(MinToMax);//转换为360度差
+
+            float Center = Limit_Min + MinToMax / 2;//中心角度
+
+            return Clamp_Angle_Complete_Scope(CurrentAngle, Center, MinToMax / 2);
+        }
+
+        /// <summary>
+        /// 角度范围约束(全面角度约束)                               
+        ///【注意：组件上的欧拉角 X 轴是经过计算的，最大值为+-90度，谨慎使用】
+        /// </summary>
+        /// <param name="CurrentAngle">当前角度</param>
+        /// <param name="TargetAngle">约束角度</param>
+        /// <param name="Limit_Radius">限制半径</param>
+        /// <returns>return ：约束后的角度</returns>
+        public static float Clamp_Angle_Complete_Scope(float CurrentAngle, float TargetAngle, float Limit_Radius)
+        {
+            float CurToCen = Mathf.DeltaAngle(CurrentAngle, TargetAngle);//获得+-180差值
+
+            if (CurToCen > Limit_Radius) CurrentAngle = TargetAngle - Limit_Radius;
+            else
+            if (CurToCen < -Limit_Radius) CurrentAngle = TargetAngle + Limit_Radius;
+
+            return CurrentAngle;
+        }
+
+        #endregion
+
+
+        #region 欧拉角
+
+
+        /// <summary>
+        /// 欧拉角约束                                            
+        ///【注意：组件上的欧拉角 X 轴是经过计算的，最大值为+-90度，谨慎使用】
+        /// </summary>
+        /// <param name="CurrentAngle">当前欧拉角</param>
+        /// <param name="Limit_Min">最小值</param>
+        /// <param name="Limit_Max">最大值</param>
+        /// <returns>return ：约束后的角度（正负0~180）</returns>
+        public static Vector3 Clamp_EulerAngle(Vector3 CurrentAngle, Vector3 Limit_Min, Vector3 Limit_Max)
+        {
+            CurrentAngle.x = Clamp_Angle(CurrentAngle.x, Limit_Min.x, Limit_Max.x);
+            CurrentAngle.y = Clamp_Angle(CurrentAngle.y, Limit_Min.y, Limit_Max.y);
+            CurrentAngle.z = Clamp_Angle(CurrentAngle.z, Limit_Min.z, Limit_Max.z);
+            return CurrentAngle;
+        }
+
+        /// <summary>
+        /// 欧拉角约束 [轴可控式]                                  
+        ///【注意：组件上的欧拉角 X 轴是经过计算的，最大值为+-90度，谨慎使用】
+        /// </summary>
+        /// <param name="CurrentAngle">当前欧拉角</param>
+        /// <param name="Limit_Min">最小值</param>
+        /// <param name="Limit_Max">最大值</param>
+        /// <param name="Limit_X">X轴限制激活</param>
+        /// <param name="Limit_Y">Y轴限制激活</param>
+        /// <param name="Limit_Z">Z轴限制激活</param>
+        /// <returns>return ：约束后的角度（正负0~180）</returns>
+        public static Vector3 Clamp_EulerAngle(Vector3 CurrentAngle, Vector3 Limit_Min, Vector3 Limit_Max, bool Limit_X = true, bool Limit_Y = true, bool Limit_Z = true)
+        {
+            if (Limit_X) CurrentAngle.x = Clamp_Angle(CurrentAngle.x, Limit_Min.x, Limit_Max.x);
+            if (Limit_Y) CurrentAngle.y = Clamp_Angle(CurrentAngle.y, Limit_Min.y, Limit_Max.y);
+            if (Limit_Z) CurrentAngle.z = Clamp_Angle(CurrentAngle.z, Limit_Min.z, Limit_Max.z);
+            return CurrentAngle;
+        }
+
+        /// <summary>
+        /// 欧拉角约束 (全面角度约束)                               
+        ///【注意：组件上的欧拉角 X 轴是经过计算的，最大值为+-90度，谨慎使用】
+        /// </summary>
+        /// <param name="CurrentEulerAngle">当前欧拉角</param>
+        /// <param name="Limit_Min">最小值</param>
+        /// <param name="Limit_Max">最大值</param>
+        /// <returns>return ：约束后的角度</returns>
+        public static Vector3 Clamp_EulerAngle_Complete(Vector3 CurrentEulerAngle, Vector3 Limit_Min, Vector3 Limit_Max)
+        {
+            CurrentEulerAngle.x = Clamp_Angle_Complete_Scope(CurrentEulerAngle.x, Limit_Min.x, Limit_Max.x);
+            CurrentEulerAngle.y = Clamp_Angle_Complete_Scope(CurrentEulerAngle.y, Limit_Min.x, Limit_Max.y);
+            CurrentEulerAngle.z = Clamp_Angle_Complete_Scope(CurrentEulerAngle.z, Limit_Min.x, Limit_Max.z);
+            return CurrentEulerAngle;
+        }
+
+        /// <summary>
+        /// 欧拉角约束 [轴可控式] (全面角度约束)                        
+        ///【注意：组件上的欧拉角 X 轴是经过计算的，最大值为+-90度，谨慎使用】
+        /// </summary>
+        /// <param name="CurrentEulerAngle">当前欧拉角</param>
+        /// <param name="Limit_Min">最小值</param>
+        /// <param name="Limit_Max">最大值</param>
+        /// <param name="Limit_X">X轴限制激活</param>
+        /// <param name="Limit_Y">Y轴限制激活</param>
+        /// <param name="Limit_Z">Z轴限制激活</param>
+        /// <returns>return ：约束后的角度</returns>
+        public static Vector3 Clamp_EulerAngle_Complete(Vector3 CurrentEulerAngle, Vector3 Limit_Min, Vector3 Limit_Max, bool Limit_X = true, bool Limit_Y = true, bool Limit_Z = true)
+        {
+            if (Limit_X) CurrentEulerAngle.x = Clamp_Angle_Complete_Scope(CurrentEulerAngle.x, Limit_Min.x, Limit_Max.x);
+            if (Limit_Y) CurrentEulerAngle.y = Clamp_Angle_Complete_Scope(CurrentEulerAngle.y, Limit_Min.x, Limit_Max.y);
+            if (Limit_Z) CurrentEulerAngle.z = Clamp_Angle_Complete_Scope(CurrentEulerAngle.z, Limit_Min.x, Limit_Max.z);
+            return CurrentEulerAngle;
+        }
+
+        /// <summary>
+        /// 欧拉角范围约束 (全面角度约束)                                  
+        ///【注意：组件上的欧拉角 X 轴是经过计算的，最大值为+-90度，谨慎使用】
+        /// </summary>
+        /// <param name="CurrentEulerAngle">当前角度</param>
+        /// <param name="TargetEulerAngle">约束角度</param>
+        /// <param name="Limit_Radius">限制半径</param>
+        /// <returns>return ：约束后的角度</returns>
+        public static Vector3 Clamp_EulerAngle_Complete_Scope(Vector3 CurrentEulerAngle, Vector3 TargetEulerAngle, Vector3 Limit_Radius)
+        {
+            CurrentEulerAngle.x = Clamp_Angle_Complete_Scope(CurrentEulerAngle.x, TargetEulerAngle.x, Limit_Radius.x);
+            CurrentEulerAngle.y = Clamp_Angle_Complete_Scope(CurrentEulerAngle.y, TargetEulerAngle.y, Limit_Radius.y);
+            CurrentEulerAngle.z = Clamp_Angle_Complete_Scope(CurrentEulerAngle.z, TargetEulerAngle.z, Limit_Radius.z);
+            return CurrentEulerAngle;
+        }
+
+
+        /// <summary>
+        /// 欧拉角范围约束 [轴可控式] (全面角度约束)                                   
+        ///【注意：组件上的欧拉角 X 轴是经过计算的，最大值为+-90度，谨慎使用】
+        /// </summary>
+        /// <param name="CurrentEulerAngle">当前角度</param>
+        /// <param name="TargetEulerAngle">约束角度</param>
+        /// <param name="Limit_Radius">限制半径</param>
+        /// <param name="Limit_X">X轴限制激活</param>
+        /// <param name="Limit_Y">Y轴限制激活</param>
+        /// <param name="Limit_Z">Z轴限制激活</param>
+        /// <returns>return ：约束后的角度</returns>
+        public static Vector3 Clamp_EulerAngle_Complete_Scope(Vector3 CurrentEulerAngle, Vector3 TargetEulerAngle, Vector3 Limit_Radius, bool Limit_X = true, bool Limit_Y = true, bool Limit_Z = true)
+        {
+            if (Limit_X) CurrentEulerAngle.x = Clamp_Angle_Complete_Scope(CurrentEulerAngle.x, TargetEulerAngle.x, Limit_Radius.x);
+            if (Limit_Y) CurrentEulerAngle.y = Clamp_Angle_Complete_Scope(CurrentEulerAngle.y, TargetEulerAngle.y, Limit_Radius.y);
+            if (Limit_Z) CurrentEulerAngle.z = Clamp_Angle_Complete_Scope(CurrentEulerAngle.z, TargetEulerAngle.z, Limit_Radius.z);
+            return CurrentEulerAngle;
+        }
+
+        #endregion
+
+
+    }
+}
diff --git a/SDHK_Tool/Static/Mathf/SS_Mathf_Recent.cs b/SDHK_Tool/Static/Mathf/SS_Mathf_Recent.cs
new file mode 100644
index 0000000..461babb
--- /dev/null
+++ b/SDHK_Tool/Static/Mathf/SS_Mathf_Recent.cs
@@ -0,0 +1,298 @@
+﻿using System.Collections.Generic;
+using UnityEngine;
+using System;
+
+/*
+ * 作者：闪电Y黑客
+ *
+ * 日期：2019.6.20 
+ *
+ * 创建源于某拖拽窗口项目，用于动态滚动列表的位置计算
+ *
+ * 2020.02.28 从 SS_Mathf文件中 拆分出来
+ * 
+ * 功能：求数值在一个数组中的最近值
+ * 
+ */
+
+
+namespace SDHK_Tool.Static
+{
+
+    /// <summary>
+    /// 最近值                                                                             
+    /// </summary>
+    public static partial class SS_Mathf
+    {
+
+        /// <summary>
+        /// 求最近值:(注意间隔距离要整数)
+        /// </summary>
+        /// <param name="NowValue">数值</param>
+        /// <param name="Distance">间隔距离</param>
+        /// <returns>最近值</returns>
+        public static float Recent_Value(float NowValue, float Distance)
+        {
+            float saveValue = 0;
+            float RedundantValue = 0;
+
+            RedundantValue = NowValue % Distance;//取余数
+            saveValue = NowValue - RedundantValue;//去余数
+
+            saveValue += Mathf.RoundToInt(RedundantValue / Distance) * Distance;// 四舍五入到整数（0/1）*间隔
+
+            return saveValue;
+        }
+
+        /// <summary>
+        /// 求最近值:(注意间隔距离要整数)
+        /// </summary>
+        /// <param name="NowValue">数值</param>
+        /// <param name="Distance">间隔距离</param>
+        /// <param name="Mode">true/false(顶值间隔/底值间隔)</param>
+        /// <returns>最近值</returns>
+        public static float Recent_Value(float NowValue, float Distance, bool Mode)
+        {
+            float saveValue = 0;
+            float RedundantValue = 0;
+
+            RedundantValue = NowValue % Distance;
+            saveValue = NowValue - RedundantValue;
+
+            if (Mode)
+            {
+                saveValue += (RedundantValue / Distance > 0) ? Distance : 0;// top顶值
+            }
+            return saveValue;
+        }
+
+        /// <summary>
+        /// 求最近值
+        /// </summary>
+        /// <param name="NowValue">数值</param>
+        /// <param name="Distances">数组</param>
+        /// <returns>最近值</returns>
+        public static float Recent_Value(float NowValue, List<float> Distances)
+        {
+            if (Distances.Count > 0)
+            {
+                int index = 0;
+                float LateDistance = Mathf.Abs(NowValue - Distances[0]);
+
+                for (int i = 0; i < Distances.Count; i++)
+                {
+                    float newDistance = Mathf.Abs(NowValue - Distances[i]);
+                    if (newDistance <= LateDistance)
+                    {
+                        index = i;
+                        LateDistance = newDistance;
+                    }
+                }
+                return Distances[index];
+            }
+            else
+            {
+                return NowValue;
+            }
+        }
+
+        /// <summary>
+        /// 求最近值:需要从小到大的排列顺序
+        /// </summary>
+        /// <param name="NowValue">数值</param>
+        /// <param name="Distances">数组</param>
+        /// <param name="Mode">true/false(顶值间隔/底值间隔)</param>
+        /// <returns>最近值</returns>
+        public static float Recent_Value(float NowValue, List<float> Distances, bool Mode)
+        {
+            if (Distances.Count > 0)
+            {
+                int MinIndex = 0;
+                int MaxIndex = 0;
+
+                for (int i = 1; i < Distances.Count; i++)
+                {
+                    if (Distances[i - 1] < NowValue && Distances[i] >= NowValue)
+                    {
+                        MinIndex = i - 1;
+                        MaxIndex = i;
+                        break;
+                    }
+                    else if (Distances[i - 1] < NowValue && Distances[i] < NowValue)
+                    {
+                        MinIndex = Distances.Count - 1;
+                        MaxIndex = Distances.Count - 1;
+                    }
+                    else if (Distances[i - 1] > NowValue && Distances[i] > NowValue)
+                    {
+                        MinIndex = 0;
+                        MaxIndex = 0;
+                    }
+                }
+                return (Mode) ? Distances[MaxIndex] : Distances[MinIndex];
+            }
+            else
+            {
+                return NowValue;
+            }
+        }
+
+
+        /// <summary>
+        /// 求最近值的间隔数:(注意间隔距离要整数)
+        /// </summary>
+        /// <param name="NowValue">数值</param>
+        /// <param name="Distance">间隔距离</param>
+        /// <returns>间隔个数</returns>
+        public static int Recent_Number(float NowValue, float Distance)
+        {
+            return (int)(Recent_Value(NowValue, Distance) / Distance);
+        }
+
+        /// <summary>
+        /// 求最近值的间隔数:(注意间隔距离要整数)
+        /// </summary>
+        /// <param name="NowValue">数值</param>
+        /// <param name="Distance">间隔距离</param>
+        /// <param name="Mode">true/false(顶值间隔/底值间隔)</param>
+        /// <returns>间隔数</returns>
+        public static int Recent_Number(float NowValue, int Distance, bool Mode)
+        {
+            return (int)(Recent_Value(NowValue, Distance, Mode) / Distance);
+        }
+
+
+        /// <summary>
+        /// 求最近值的下标
+        /// </summary>
+        /// <param name="NowValue">数值</param>
+        /// <param name="Distances">数组</param>
+        /// <returns>最近值下标</returns>
+        public static int Recent_Number(float NowValue, List<float> Distances)
+        {
+            if (Distances.Count > 0)
+            {
+                int index = 0;
+                float LateDistance = Mathf.Abs(NowValue - Distances[0]);
+
+                for (int i = 0; i < Distances.Count; i++)
+                {
+                    float newDistance = Mathf.Abs(NowValue - Distances[i]);
+                    if (newDistance <= LateDistance)
+                    {
+                        index = i;
+                        LateDistance = newDistance;
+                    }
+                }
+                return index;
+            }
+            else
+            {
+                return -1;
+            }
+        }
+
+
+        /// <summary>
+        /// 求最近值的下标:需要从小到大的排列顺序
+        /// </summary>
+        /// <param name="NowValue">数值</param>
+        /// <param name="Distances">数组</param>
+        /// <param name="Mode">true/false(顶值间隔/底值间隔)</param>
+        /// <returns>最近值下标</returns>
+        public static int Recent_Number(float NowValue, List<float> Distances, bool Mode)
+        {
+            if (Distances.Count > 0)
+            {
+                int MinIndex = 0;
+                int MaxIndex = 0;
+
+                for (int i = 1; i < Distances.Count; i++)
+                {
+                    if (Distances[i - 1] < NowValue && Distances[i] >= NowValue)
+                    {
+                        MinIndex = i - 1;
+                        MaxIndex = i;
+                        break;
+                    }
+                    else if (Distances[i - 1] < NowValue && Distances[i] < NowValue)
+                    {
+                        MinIndex = Distances.Count - 1;
+                        MaxIndex = Distances.Count - 1;
+                    }
+                    else if (Distances[i - 1] > NowValue && Distances[i] > NowValue)
+                    {
+                        MinIndex = 0;
+                        MaxIndex = 0;
+                    }
+                }
+                return (Mode) ? MaxIndex : MinIndex;
+            }
+            else
+            {
+                return -1;
+            }
+        }
+
+        /// <summary>
+        /// 求最近值:[3D]
+        /// </summary>
+        /// <param name="NowVector">当前坐标</param>
+        /// <param name="vector3s">坐标集合</param>
+        /// <returns>集合中最近的坐标</returns>
+        public static Vector3 Recent_Vector(Vector3 NowVector, List<Vector3> vector3s)
+        {
+            if (vector3s.Count > 0)
+            {
+                int index = 0;
+                float LateDistance = (NowVector - vector3s[0]).magnitude;
+
+                for (int i = 0; i < vector3s.Count; i++)
+                {
+                    float newDistance = (NowVector - vector3s[i]).magnitude;
+                    if (newDistance <= LateDistance)
+                    {
+                        index = i;
+                        LateDistance = newDistance;
+                    }
+                }
+                return vector3s[index];
+            }
+            else
+            {
+                return NowVector;
+            }
+        }
+
+        /// <summary>
+        /// 求最近值:[3D]
+        /// </summary>
+        /// <param name="NowVector">当前坐标</param>
+        /// <param name="vector3s">坐标集合</param>
+        /// <returns>集合中最近向量的下标</returns>
+        public static int Recent_Vector<T>(Vector3 NowVector, List<T> vector3s, Func<int, Vector3> GetVector3)
+        {
+            if (vector3s.Count > 0)
+            {
+                int index = 0;
+                float LateDistance = (NowVector - GetVector3(0)).magnitude;
+
+                for (int i = 0; i < vector3s.Count; i++)
+                {
+                    float newDistance = (NowVector - GetVector3(i)).magnitude;
+                    if (newDistance <= LateDistance)
+                    {
+                        index = i;
+                        LateDistance = newDistance;
+                    }
+                }
+                return index;
+            }
+            else
+            {
+                return -1;
+            }
+        }
+
+    }
+}
\ No newline at end of file
diff --git a/SDHK_Tool/Static/Mathf/SS_Mathf_Triangle.cs b/SDHK_Tool/Static/Mathf/SS_Mathf_Triangle.cs
new file mode 100644
index 0000000..f77c30e
--- /dev/null
+++ b/SDHK_Tool/Static/Mathf/SS_Mathf_Triangle.cs
@@ -0,0 +1,100 @@
+﻿using UnityEngine;
+
+/*
+ * 作者：闪电Y黑客
+ * 
+ * 日期： 2019.01.17 
+ * 
+ * 创建源于炮塔旋转功能，用于计算炮塔与目标不在统一角度时的炮塔旋转角度
+ *
+ * 2019.6.11 从 MyTool 转到 SDHK_Tool 
+ *
+ * 2020.02.28  SS_TriangleSolutions 合并到 SS_Mathf 
+ * 
+ * 功能：解三角的静态方法
+ */
+
+namespace SDHK_Tool.Static
+{
+
+    /// <summary>
+    /// 解三角形                                              
+    /// </summary>
+    public static partial class SS_Mathf
+    {
+
+
+        //=[三角形求值]=================================================
+        /// <summary>
+        /// 解三角形 : 获得角A : 角A=180-(角B+角C) 同理
+        /// </summary>
+        /// <param name="B_Angle">角B</param>
+        /// <param name="C_Angle">角C</param>
+        /// <returns>return : 角A</returns>
+        public static float Triangle_Get_A_Angle_AAA(float B_Angle, float C_Angle)//获取角
+        {
+            return 180 - (B_Angle + C_Angle);
+        }
+
+        /// <summary>
+        /// 解三角形 : 获得外接圆直径
+        /// </summary>
+        /// <param name="Angle">角</param>
+        /// <param name="Edge">角的对边</param>
+        /// <returns>return : 外接圆直径</returns>
+        public static float Triangle_GetDiameter(float Angle, float Edge)//获取外接圆直径
+        {
+            return Edge / Mathf.Sin(Angle * Mathf.Deg2Rad);//获取外接直径
+        }
+
+        /// <summary>
+        /// 解三角形 : 获得角的对边
+        /// </summary>
+        /// <param name="Angle">角</param>
+        /// <param name="diameter">外接圆直径</param>
+        /// <returns>return : 角的对边</returns>
+        public static float Triangle_GetEdge(float Angle, float diameter)//通过外接圆直径获得边
+        {
+            return Mathf.Sin(Angle * Mathf.Deg2Rad) * diameter;//通过直径获得边
+        }
+
+        /// <summary>
+        /// 解三角形 : 通过外接圆直径获得对角
+        /// </summary>
+        /// <param name="Edge">角的对边</param>
+        /// <param name="diameter">外接圆直径</param>
+        /// <returns>return : 小于等于90度的对角</returns>
+        public static float Triangle_GetAngle(float Edge, float diameter)//通过外接圆直径获得<=90的角
+        {
+            return Mathf.Asin(Edge / diameter) * Mathf.Rad2Deg;//获得<=90的角
+        }
+
+
+        /// <summary>
+        /// 解三角形 : 获得角A
+        /// </summary>
+        /// <param name="A_Edge">角A的对边</param>
+        /// <param name="B_Edge">角B的对边</param>
+        /// <param name="C_Edge">角C的对边</param>
+        /// <returns>return : 角A</returns>
+        public static float Triangle_Get_A_Angle_EEE(float A_Edge, float B_Edge, float C_Edge)//从三边获得一角
+        {
+            return Mathf.Acos((B_Edge * B_Edge + C_Edge * C_Edge - A_Edge * A_Edge) / (2 * (B_Edge * C_Edge))) * Mathf.Rad2Deg;
+        }
+
+        /// <summary>
+        /// 解三角形 : 获得夹角A的对边
+        /// </summary>
+        /// <param name="A_Angle">夹角A</param>
+        /// <param name="B_Edge">角B的对边</param>
+        /// <param name="C_Edge">角C的对边</param>
+        /// <returns>return : 夹角A的对边</returns>
+        public static float Triangle_Get_A_Edge_EAE(float A_Angle, float B_Edge, float C_Edge)//夹角获取对边
+        {
+            
+            return Mathf.Sqrt(B_Edge * B_Edge + C_Edge * C_Edge - 2 * B_Edge * C_Edge * Mathf.Cos(A_Angle * Mathf.Deg2Rad));
+        }
+    }
+
+
+}
\ No newline at end of file
diff --git a/SDHK_Tool/Static/SS_CoordinateConversion.cs b/SDHK_Tool/Static/SS_CoordinateConversion.cs
new file mode 100644
index 0000000..7a37f53
--- /dev/null
+++ b/SDHK_Tool/Static/SS_CoordinateConversion.cs
@@ -0,0 +1,113 @@
+﻿using UnityEngine;
+
+/*
+ * 作者：闪电Y黑客
+ * 
+ * 日期： 2019.10.9
+ * 
+ * 功能: 不同坐标系之间的坐标转换
+ */
+
+namespace SDHK_Tool.Static
+{
+
+    /// <summary>
+    /// 坐标系坐标转换
+    /// </summary>
+    public class SS_CoordinateConversion
+    {
+
+        /// <summary>
+        /// 屏幕像素坐标转世界坐标:Z为物体与相机的水平距离
+        /// </summary>
+        /// <param name="ScreenPoint">屏幕像素坐标</param>
+        /// <param name="PlaneDistance">画布距离</param>
+        /// <returns>世界坐标</returns>
+        public static Vector3 Screen_To_World(Vector2 ScreenPoint, float PlaneDistance)
+        {
+            return Camera.main.ScreenToWorldPoint(new Vector3(ScreenPoint.x, ScreenPoint.y, PlaneDistance));
+        }
+
+        /// <summary>
+        /// 世界坐标转屏幕像素坐标
+        /// </summary>
+        /// <param name="WorldPoint">世界坐标</param>
+        /// <returns>屏幕像素坐标</returns>
+        public static Vector3 World_To_Screen(Vector3 WorldPoint)
+        {
+            return Camera.main.WorldToScreenPoint(WorldPoint);
+        }
+
+        /// <summary>
+        /// 屏幕像素坐标转世界坐标:Z为物体与相机的水平距离
+        /// </summary>
+        /// <param name="camera">相机</param>
+        /// <param name="ScreenPoint">屏幕像素坐标</param>
+        /// <param name="PlaneDistance">画布距离</param>
+        /// <returns>世界坐标</returns>
+        public static Vector3 Screen_To_World(Camera camera, Vector2 ScreenPoint, float PlaneDistance)
+        {
+            return camera.ScreenToWorldPoint(new Vector3(ScreenPoint.x, ScreenPoint.y, PlaneDistance));
+        }
+
+        /// <summary>
+        /// 世界坐标转屏幕像素坐标
+        /// </summary>
+        /// <param name="camera">相机</param>
+        /// <param name="WorldPoint">世界坐标</param>
+        /// <returns>屏幕像素坐标</returns>
+        public static Vector3 World_To_Screen(Camera camera, Vector3 WorldPoint)
+        {
+            return camera.WorldToScreenPoint(WorldPoint);
+        }
+
+
+        /// <summary>
+        /// 世界坐标转局部坐标
+        /// </summary>
+        /// <param name="transform">局部坐标系</param>
+        /// <param name="WorldPoint">世界坐标点</param>
+        /// <returns>局部坐标</returns>
+        public static Vector3 World_To_local(Transform transform, Vector3 WorldPoint)
+        {
+            return transform.InverseTransformPoint(WorldPoint);
+        }
+
+        /// <summary>
+        /// 局部坐标转世界坐标
+        /// </summary>
+        /// <param name="transform">局部坐标系</param>
+        /// <param name="LocalPoint">局部坐标点</param>
+        /// <returns>世界坐标</returns>
+        public static Vector3 Local_To_World(Transform transform, Vector3 LocalPoint)
+        {
+            return transform.TransformPoint(LocalPoint);
+        }
+
+        /// <summary>
+        /// 局部坐标转局部坐标
+        /// </summary>
+        /// <param name="TargetTransform">目标坐标系</param>
+        /// <param name="CurrentTransform">当前坐标系</param>
+        /// <param name="LocalPoint">当前局部坐标点</param>
+        /// <returns>局部坐标点</returns>
+        public static Vector3 Local_To_Local(Transform TargetTransform, Transform CurrentTransform, Vector3 LocalPoint)
+        {
+            return TargetTransform.InverseTransformPoint(CurrentTransform.TransformPoint(LocalPoint));
+        }
+
+        /// <summary>
+        /// 屏幕坐标转局部坐标：用于可移动世界画布
+        /// </summary>
+        /// <param name="TargetTransform">目标坐标系</param>
+        /// <param name="ScreenPoint">屏幕像素坐标</param>
+        /// <param name="PlaneDistance">画布距离</param>
+        /// <returns>局部坐标</returns>
+        public static Vector3 Screen_To_Local(Transform TargetTransform, Vector2 ScreenPoint, float PlaneDistance)
+        {
+            return World_To_local(TargetTransform, Screen_To_World(ScreenPoint, PlaneDistance));
+        }
+
+
+    }
+}
\ No newline at end of file
diff --git a/SDHK_Tool/Static/SS_CoordinateConversion.cs.meta b/SDHK_Tool/Static/SS_CoordinateConversion.cs.meta
new file mode 100644
index 0000000..b2dbf9f
--- /dev/null
+++ b/SDHK_Tool/Static/SS_CoordinateConversion.cs.meta
@@ -0,0 +1,13 @@
+fileFormatVersion: 2
+guid: 2952201c09340d743997c9fb9c692660
+timeCreated: 1570611041
+licenseType: Pro
+MonoImporter:
+  externalObjects: {}
+  serializedVersion: 2
+  defaultReferences: []
+  executionOrder: 0
+  icon: {instanceID: 0}
+  userData: 
+  assetBundleName: 
+  assetBundleVariant: 
diff --git a/SDHK_Tool/Static/SS_DeBug.cs b/SDHK_Tool/Static/SS_DeBug.cs
new file mode 100644
index 0000000..079ee8b
--- /dev/null
+++ b/SDHK_Tool/Static/SS_DeBug.cs
@@ -0,0 +1,51 @@
+﻿using System;
+using System.Collections;
+using System.Collections.Generic;
+using System.Diagnostics;
+using UnityEngine;
+
+/*
+ * 作者：闪电Y黑客
+ *
+ * 日期：2019.6.20
+ * 
+ * 功能：一些调试测试用的静态方法
+ * 
+ */
+
+namespace SDHK_Tool.Static
+{
+
+    /// <summary>
+    /// 调试静态类
+    /// </summary>
+    public class SS_DeBug
+    {
+		
+        /// <summary>
+        /// 函数效率检测
+        /// </summary>
+        /// <param name="action">要检测的方法委托</param>
+        /// <param name="Num">循环次数(默认为1000次)</param>
+        /// <returns>执行时间(毫秒)</returns>
+        public static long Efficiency(Action action, int Num = 1000)
+        {
+            Stopwatch sw = new Stopwatch();
+            sw.Start();
+            for (int i = 0; i < Num; i++)
+            {
+                action();
+            }
+            sw.Stop();
+            return sw.ElapsedMilliseconds;
+
+            // Profiler.BeginSample("TestMethod");//定位热点功能
+            // Profiler.EndSample();
+        }
+
+
+
+
+    }
+
+}
\ No newline at end of file
diff --git a/SDHK_Tool/Static/SS_DeBug.cs.meta b/SDHK_Tool/Static/SS_DeBug.cs.meta
new file mode 100644
index 0000000..a8184a7
--- /dev/null
+++ b/SDHK_Tool/Static/SS_DeBug.cs.meta
@@ -0,0 +1,13 @@
+fileFormatVersion: 2
+guid: 14587d56d8b6c3542be80dae8f23f8fd
+timeCreated: 1574328857
+licenseType: Pro
+MonoImporter:
+  externalObjects: {}
+  serializedVersion: 2
+  defaultReferences: []
+  executionOrder: 0
+  icon: {instanceID: 0}
+  userData: 
+  assetBundleName: 
+  assetBundleVariant: 
diff --git a/SDHK_Tool/Static/SS_EulerAngleConversion.cs b/SDHK_Tool/Static/SS_EulerAngleConversion.cs
new file mode 100644
index 0000000..3697bbc
--- /dev/null
+++ b/SDHK_Tool/Static/SS_EulerAngleConversion.cs
@@ -0,0 +1,237 @@
+﻿using UnityEngine;
+
+/*
+ * 作者：闪电Y黑客
+ * 
+ * 日期： 2019.6.11
+ * 
+ * 功能: 角度与向量的各种转换计算
+ */
+
+namespace SDHK_Tool.Static
+{
+
+    /// <summary>
+    /// 欧拉角,角度转换计算
+    /// </summary>
+    public static class SS_EulerAngleConversion
+    {
+
+        /// <summary>
+        /// 角度转换：正负无限 转换成 正负0~180 的角度
+        /// </summary>
+        /// <param name="Angle">要转换角度</param>
+        /// <returns>return ： 转换成 正负0~180 的角度</returns>
+        public static float Angle_PN_To_PN180(float Angle)
+        {
+            Angle = Angle_PN_To_P360(Angle);
+            return Angle_P360_To_PN180(Angle);
+        }
+
+        /// <summary>
+        /// 角度转换：正负无限 转换成 正0~360 的角度
+        /// </summary>
+        /// <param name="Angle">要转换角度</param>
+        /// <returns>return ： 转换成 正0~360 的角度</returns>
+        public static float Angle_PN_To_P360(float Angle)
+        {
+            return ((Angle %= 360) < 0) ? Angle + 360 : Angle;
+        }
+
+        /// <summary>
+        /// 角度转换：正0~360 转换成 正负0~180 的角度
+        /// </summary>
+        /// <param name="Angle">要转换角度</param>
+        /// <returns>return ： 转换成 正负0~180 的角度</returns>
+        public static float Angle_P360_To_PN180(float Angle)
+        {
+            return (Angle >= 180) ? Angle - 360 : Angle;
+        }
+
+        /// <summary>
+        /// 角度转换：正0~180 转换成 正负0~90 的角度
+        /// </summary>
+        /// <param name="Angle">要转换角度</param>
+        /// <returns>return ： 转换成 正负0~180 的角度</returns>
+        public static float Angle_PN180_To_PN90(float Angle)
+        {
+            Angle = Mathf.Abs(Angle);
+            return (Angle >= 90) ? Angle - 180 : Angle;
+        }
+
+
+        /// <summary>
+        /// 欧拉角转换：正负无限 转换成 正负0~180 的欧拉角
+        /// </summary>
+        /// <param name="EulerAngles">要转换的欧拉角</param>
+        /// <returns>return ： 转换成 正负0~180 的欧拉角</returns>
+        public static Vector3 EulerAngle_PN_To_PN180(Vector3 EulerAngles)
+        {
+            EulerAngles.x = Angle_PN_To_PN180(EulerAngles.x);
+            EulerAngles.y = Angle_PN_To_PN180(EulerAngles.y);
+            EulerAngles.z = Angle_PN_To_PN180(EulerAngles.z);
+            return EulerAngles;
+        }
+
+        /// <summary>
+        /// 欧拉角转换：正负无限 转换成 正0~360 的欧拉角
+        /// </summary>
+        /// <param name="EulerAngles">要转换的欧拉角</param>
+        /// <returns>return ： 转换成 正0~360 的欧拉角</returns>
+        public static Vector3 EulerAngle_PN_To_P360(Vector3 EulerAngles)
+        {
+            EulerAngles.x = Angle_PN_To_P360(EulerAngles.x);
+            EulerAngles.y = Angle_PN_To_P360(EulerAngles.y);
+            EulerAngles.z = Angle_PN_To_P360(EulerAngles.z);
+            return EulerAngles;
+        }
+
+        /// <summary>
+        /// 欧拉角转换：正0~360 转换成 正负0~180 的欧拉角
+        /// </summary>
+        /// <param name="EulerAngles">要转换的欧拉角</param>
+        /// <returns>return ： 转换成 正负0~180 的欧拉角</returns>
+        public static Vector3 EulerAngle_P360_To_PN180(Vector3 EulerAngles)
+        {
+            EulerAngles.x = Angle_P360_To_PN180(EulerAngles.x);
+            EulerAngles.y = Angle_P360_To_PN180(EulerAngles.y);
+            EulerAngles.z = Angle_P360_To_PN180(EulerAngles.z);
+            return EulerAngles;
+        }
+
+
+        /// <summary>
+        /// 二维向量转换为角度：向量不能为0
+        /// </summary>
+        /// <param name="vector2">要转换的向量</param>
+        /// <returns>return ： 角度(360度)</returns>
+        public static float Get_Angle_In_Vector2(Vector2 vector2)
+        {
+            return Quaternion.LookRotation(new Vector3(vector2.x, 0, vector2.y)).eulerAngles.y;  //返回最终角度
+        }
+
+        /// <summary>
+        /// 三维向量转换为欧拉角：向量不能为0
+        /// </summary>
+        /// <param name="AngleVector3">指向向量</param>
+        /// <returns>return : 欧拉角(360度)</returns>
+        public static Vector3 Get_EulerAngle_In_Vector3(Vector3 AngleVector3)
+        {
+            return Quaternion.LookRotation(AngleVector3).eulerAngles;
+        }
+
+
+        /// <summary>
+        /// 角度转换为二维向量（x为横，Y为竖）
+        /// </summary>
+        /// <param name="Angle_Z">要转换的角度</param>
+        /// <returns>return ： 转换的二维向量</returns>
+        public static Vector2 Get_Vector2_In_Angle(float Angle_Z)
+        {
+
+            Vector3 vector = new Vector3(0, 1, 0);
+            vector = Quaternion.AngleAxis(Angle_Z, -Vector3.forward) * vector; //算出旋转后的向量
+            return vector;
+        }
+
+        /// <summary>
+        /// 欧拉角转换为三维向量
+        /// </summary>
+        /// <param name="EulerAngles">欧拉角</param>
+        /// <returns>return : 转换的三维向量</returns>
+        public static Vector3 Get_Vector3_In_EulerAngle(Vector3 EulerAngles)
+        {
+            Vector3 vector = new Vector3(0, 0, 1);
+            vector = Quaternion.AngleAxis(EulerAngles.x, -Vector3.left) * vector; //算出旋转后的向量
+            vector = Quaternion.AngleAxis(EulerAngles.y, Vector3.up) * vector; //算出旋转后的向量
+
+            return vector;
+        }
+
+
+        /// <summary>
+        /// 获取点绕某轴旋转x度后的位置（三维）
+        /// </summary>
+        /// <param name="position">要旋转的点</param>
+        /// <param name="center">旋转的中心点</param>
+        /// <param name="axis">旋转的轴</param>
+        /// <param name="angle">要旋转角度（顺时针为正）</param>
+        /// <returns>旋转后的位置</returns>
+        public static Vector3 Get_Vector3_RotateRound(Vector3 position, Vector3 center, Vector3 axis, float angle)
+        {
+            Vector3 point = Quaternion.AngleAxis(angle, axis) * (position - center); //算出旋转后的向量
+            Vector3 resultVec3 = center + point;        //加上旋转中心位置得到旋转后的位置
+            return resultVec3;
+        }
+
+        /// <summary>
+        /// 获取点绕某轴旋转x度后的位置（二维）
+        /// </summary>
+        /// <param name="position">要旋转的点</param>
+        /// <param name="center">旋转的中心点</param>
+        /// <param name="axis">旋转的轴</param>
+        /// <param name="angle">一次旋转多少角度（顺时针为正）</param>
+        /// <returns>旋转后的位置</returns>
+        public static Vector2 Get_Vector2_RotateRound(Vector2 position, Vector2 center, int axis, float angle)
+        {
+            Vector3 point = Quaternion.AngleAxis(angle, Vector3.forward * axis) * (new Vector3(position.x, 0, position.y) - new Vector3(center.x, 0, center.y)); //算出旋转后的向量
+            Vector2 resultVec3 = center + new Vector2(point.x, point.z);        //加上旋转中心位置得到旋转后的位置
+            return resultVec3;
+        }
+
+
+
+
+        /// <summary>
+        /// 获得两个二维向量的角度差，顺时针为正
+        /// </summary>
+        /// <param name="firstVector2">第一个向量</param>
+        /// <param name="secondVector2">第二个向量</param>
+        /// <param name="Direction">轴方向：true 为轴向自己（从前往后看）2d一般为false</param>
+        /// <returns>return : 返回正负180度角</returns>
+        public static float Get_Angle_In_Vector2Deviation(Vector2 firstVector2, Vector2 secondVector2, bool Direction)
+        {
+            float direction = Vector3.Cross(firstVector2, secondVector2).z;   //根据两个向量判断左右方向
+
+            float angle = Vector3.Angle(firstVector2, secondVector2);         //根据两个向量算出角度
+
+            if ((direction < 0 && !Direction) || (direction > 0 && Direction))
+            {
+                angle = -angle;
+            }
+            return angle;
+        }
+
+        /// <summary>
+        /// 获得两个三维向量的角度差，顺时针为正
+        /// </summary>
+        /// <param name="firstVector3">第一个向量</param>
+        /// <param name="secondVector3">第二个向量</param>
+        /// <returns>第一位为左右角度，第二位为俯仰角，第三位为实际偏差角(+-180度)</returns>
+        public static Vector3 GetAngle_In_Vector3Deviation(Vector3 firstVector3, Vector3 secondVector3)
+        {
+            Vector3 firstEulerAngles = Get_EulerAngle_In_Vector3(firstVector3);
+            Vector3 secondEulerAngles = Get_EulerAngle_In_Vector3(secondVector3);
+
+            float Angle_Y = Mathf.DeltaAngle(firstEulerAngles.y, secondEulerAngles.y);//获得+-180差值
+
+            float Angle_X = Mathf.DeltaAngle(firstEulerAngles.x, secondEulerAngles.x);//获得+-180差值
+
+            float Angle = Vector3.Angle(firstVector3, secondVector3);
+
+            return new Vector3(Angle_Y, Angle_X, Angle);
+        }
+
+        /// <summary>
+        /// 获得目标位置位于Transform的方位角度
+        /// </summary>
+        /// <param name="isTransform">Transform</param>
+        /// <param name="TargetVector3">目标点世界坐标位置</param>
+        /// <returns>return : 方位角度(+-180度) </returns>
+        public static Vector3 Get_Angle_In_Transform(Transform isTransform, Vector3 TargetVector3)
+        {
+            return EulerAngle_P360_To_PN180(Get_EulerAngle_In_Vector3(isTransform.InverseTransformPoint(TargetVector3)));
+        }
+
+    }
+}
diff --git a/SDHK_Tool/Static/SS_EulerAngleConversion.cs.meta b/SDHK_Tool/Static/SS_EulerAngleConversion.cs.meta
new file mode 100644
index 0000000..156ebf7
--- /dev/null
+++ b/SDHK_Tool/Static/SS_EulerAngleConversion.cs.meta
@@ -0,0 +1,13 @@
+fileFormatVersion: 2
+guid: 65882e3e46fc9ac449c9ca327f0b50bb
+timeCreated: 1560158816
+licenseType: Free
+MonoImporter:
+  externalObjects: {}
+  serializedVersion: 2
+  defaultReferences: []
+  executionOrder: 0
+  icon: {instanceID: 0}
+  userData: 
+  assetBundleName: 
+  assetBundleVariant: 
diff --git a/SDHK_Tool/Static/SS_GameObject.cs b/SDHK_Tool/Static/SS_GameObject.cs
new file mode 100644
index 0000000..4cc0821
--- /dev/null
+++ b/SDHK_Tool/Static/SS_GameObject.cs
@@ -0,0 +1,247 @@
+﻿using System;
+using System.Collections.Generic;
+using UnityEngine;
+
+
+/*
+ * 作者：闪电Y黑客
+ * 
+ * 日期：2019.10.16
+ * 
+ * 功能：用于游戏物体的处理
+ */
+
+namespace SDHK_Tool.Static
+{
+    /// <summary>
+    /// 用于游戏物体处理
+    /// </summary>
+    public static class SS_GameObject
+    {
+
+        /// <summary>
+        /// 判断游戏物体是否为要忽略的层
+        /// </summary>
+        /// <param name="ThisGameObject">游戏物体</param>
+        /// <param name="IgnoreLayer">要忽略的层</param>
+        /// <returns>bool</returns>
+        public static bool If_IgnoreLayer(GameObject ThisGameObject, string[] IgnoreLayer)
+        {
+            for (int i = 0; i < IgnoreLayer.Length; i++)//触摸事件穿透传递
+            {
+                if (ThisGameObject.layer == LayerMask.NameToLayer(IgnoreLayer[i])) return true;
+            }
+            return false;
+        }
+
+
+        /// <summary>
+        /// 获取游戏物体：根据最近的组件查找父物体
+        /// </summary>
+		/// <param name="thisGameObject">当前物体</param>
+        /// <typeparam name="T">组件类型</typeparam>
+        /// <returns>游戏物体</returns>
+        public static GameObject GetParent_In_Component<T>(GameObject thisGameObject)
+        {
+            Transform thisTransform = thisGameObject.transform;
+            if (thisTransform.parent != null)
+            {
+                thisTransform = thisTransform.parent;
+                for (; thisTransform.GetComponent<T>() == null && thisTransform.parent != null;)
+                {
+                    thisTransform = thisTransform.parent;
+                }
+                return thisTransform.gameObject;
+            }
+            else
+            {
+                return null;
+            }
+        }
+
+        /// <summary>
+        /// 获取游戏物体集合：根据最近的组件查找父物体
+        /// </summary>
+        /// <param name="thisGameObject">当前物体</param>
+        /// <typeparam name="T">组件类型</typeparam>
+        /// <returns>游戏物体集合</returns>
+        public static List<GameObject> GetParents_In_Component<T>(GameObject thisGameObject)
+        {
+            Transform thisTransform = thisGameObject.transform;
+
+            List<GameObject> gameObjects = new List<GameObject>();
+
+            if (thisTransform.parent != null)
+            {
+                thisTransform = thisTransform.parent;
+
+                for (; thisTransform.parent != null;)
+                {
+                    if (thisTransform.GetComponent<T>() != null) gameObjects.Add(thisTransform.gameObject);
+                    thisTransform = thisTransform.parent;
+                }
+                return gameObjects;
+            }
+            else
+            {
+                return null;
+            }
+        }
+
+        /// <summary>
+        /// 获取组件:在最接近的父物体
+        /// </summary>
+        /// <param name="thisGameObject">当前物体</param>
+        /// <typeparam name="T">组件类型</typeparam>
+        /// <returns>组件</returns>
+        public static T GetComponent_In_Parent<T>(GameObject thisGameObject)
+        {
+            Transform thisTransform = thisGameObject.transform;
+            if (thisTransform.parent != null)
+            {
+                thisTransform = thisTransform.parent;
+                for (; thisTransform.GetComponent<T>() == null && thisTransform.parent != null;)
+                {
+                    thisTransform = thisTransform.parent;
+                }
+                return thisTransform.GetComponent<T>();
+            }
+            else
+            {
+                return default(T);
+            }
+        }
+
+        /// <summary>
+        /// 获取组件集合:在最接近的父物体
+        /// </summary>
+        /// <param name="thisGameObject">当前物体</param>
+        /// <typeparam name="T">组件类型</typeparam>
+        /// <returns>组件集合</returns>
+        public static T[] GetComponents_In_Parent<T>(GameObject thisGameObject)
+        {
+            Transform thisTransform = thisGameObject.transform;
+            if (thisTransform.parent != null)
+            {
+                thisTransform = thisTransform.parent;
+                for (; thisTransform.GetComponents<T>().Length <= 0 && thisTransform.parent != null;)
+                {
+                    thisTransform = thisTransform.parent;
+                }
+                return thisTransform.GetComponents<T>();
+            }
+            else
+            {
+                return null;
+            }
+        }
+
+        /// <summary>
+        /// 物体集合剔除
+        /// </summary>
+        /// <param name="OriginList">原集合</param>
+        /// <param name="ExceptList">要剔除的集合</param>
+        /// <param name="IF_Func">判断方法:相等返回true</param>
+        /// <typeparam name="T">集合类型</typeparam>
+        /// <returns>剔除的集合</returns>
+        public static List<T> List_Except<T>(List<T> OriginList, List<T> ExceptList, Func<T, T, bool> IF_Func)
+        {
+            List<T> newList = new List<T>();
+            bool bit = false;
+            for (int i = 0; i < OriginList.Count; i++)
+            {
+                for (int i1 = 0; i1 < ExceptList.Count; i1++)
+                {
+                    if (IF_Func(OriginList[i], ExceptList[i1]))
+                    {
+                        bit = true;
+                        break;
+                    }
+                }
+                if (!bit) newList.Add(OriginList[i]);
+                bit = false;
+            }
+            return newList;
+        }
+        /// <summary>
+        /// 物体集合剔除
+        /// </summary>
+        /// <param name="OriginList">原集合</param>
+        /// <param name="ExceptList">要剔除的集合</param>
+        /// <param name="IF_Func">判断方法:相等返回true</param>
+        /// <typeparam name="T">集合类型</typeparam>
+        /// <returns>剔除的集合</returns>
+        public static List<T> List_Except<T>(T[] OriginList, T[] ExceptList, Func<T, T, bool> IF_Func)
+        {
+            List<T> newList = new List<T>();
+            bool bit = false;
+            for (int i = 0; i < OriginList.Length; i++)
+            {
+                for (int i1 = 0; i1 < ExceptList.Length; i1++)
+                {
+                    if (IF_Func(OriginList[i], ExceptList[i1]))
+                    {
+                        bit = true;
+                        break;
+                    }
+                }
+                if (!bit) newList.Add(OriginList[i]);
+                bit = false;
+            }
+            return newList;
+        }
+
+        /// <summary>
+        /// 物体集合交集
+        /// </summary>
+        /// <param name="originList">原集合</param>
+        /// <param name="IntersectList">新集合</param>
+        /// <param name="IF_Func">判断方法:相等返回true</param>
+        /// <typeparam name="T">集合类型</typeparam>
+        /// <returns>交集集合</returns>
+        public static List<T> List_Intersect<T>(List<T> originList, List<T> IntersectList, Func<T, T, bool> IF_Func)
+        {
+            List<T> newList = new List<T>();
+            for (int i = 0; i < originList.Count; i++)
+            {
+                for (int i1 = 0; i1 < IntersectList.Count; i1++)
+                {
+                    if (IF_Func(originList[i], IntersectList[i1]))
+                    {
+                        newList.Add(originList[i]);
+                    }
+                }
+            }
+            return newList;
+        }
+
+        /// <summary>
+        /// 物体集合交集
+        /// </summary>
+        /// <param name="originList">原集合</param>
+        /// <param name="IntersectList">新集合</param>
+        /// <param name="IF_Func">判断方法:相等返回true</param>
+        /// <typeparam name="T">集合类型</typeparam>
+        /// <returns>交集集合</returns>
+        public static List<T> List_Intersect<T>(T[] originList, T[] IntersectList, Func<T, T, bool> IF_Func)
+        {
+            List<T> newList = new List<T>();
+            for (int i = 0; i < originList.Length; i++)
+            {
+                for (int i1 = 0; i1 < IntersectList.Length; i1++)
+                {
+                    if (IF_Func(originList[i], IntersectList[i1]))
+                    {
+                        newList.Add(originList[i]);
+                    }
+                }
+            }
+            return newList;
+        }
+
+
+       
+
+
+    }
+}
\ No newline at end of file
diff --git a/SDHK_Tool/Static/SS_GameObject.cs.meta b/SDHK_Tool/Static/SS_GameObject.cs.meta
new file mode 100644
index 0000000..008710d
--- /dev/null
+++ b/SDHK_Tool/Static/SS_GameObject.cs.meta
@@ -0,0 +1,13 @@
+fileFormatVersion: 2
+guid: cb95a09060f8b2046a65fb204a1653cb
+timeCreated: 1571193008
+licenseType: Pro
+MonoImporter:
+  externalObjects: {}
+  serializedVersion: 2
+  defaultReferences: []
+  executionOrder: 0
+  icon: {instanceID: 0}
+  userData: 
+  assetBundleName: 
+  assetBundleVariant: 
diff --git a/SDHK_Tool/Static/SS_Ray.cs b/SDHK_Tool/Static/SS_Ray.cs
new file mode 100644
index 0000000..e862521
--- /dev/null
+++ b/SDHK_Tool/Static/SS_Ray.cs
@@ -0,0 +1,159 @@
+﻿using System;
+using System.Collections.Generic;
+using UnityEngine;
+using UnityEngine.EventSystems;
+using UnityEngine.UI;
+
+/*
+ * 作者：闪电Y黑客
+ * 
+ * 日期：2019.6.11
+ * 
+ * 功能：用于射线检测
+ */
+
+namespace SDHK_Tool.Static
+{
+
+    /// <summary>
+    /// 射线检测类
+    /// </summary>
+    public static class SS_Ray
+    {
+        /// <summary>
+        /// 射线检测：障碍穿越
+        /// </summary>
+        /// <param name="origin">射线发射原点</param>
+        /// <param name="direction">射线发射向量</param>
+        /// <param name="collision_distance">二次延伸长度</param>
+        /// <param name="LayerMask">遮罩层:~LayerMask.GetMask(Tags.player)//忽略player</param>
+        /// <returns>return : 穿越后的位置</returns>
+        public static Vector3 Obstacle_crossing(Vector3 origin, Vector3 direction, float collision_distance, int LayerMask)
+        {
+            RaycastHit hit;
+            Vector3 direction_Extended = direction + direction.normalized * collision_distance;//向量延伸
+
+            return (Physics.Raycast(origin, direction_Extended, out hit, direction_Extended.magnitude, LayerMask))
+            ?
+                hit.point - (direction.normalized * collision_distance)//前往射线碰撞位置
+            :
+                origin + direction//回到原始位置
+            ;
+        }
+
+        /// <summary>
+        /// 画布射线：UI事件穿透
+        /// </summary>
+        /// <param name="eventData">eventData事件</param>
+        /// <param name="function">ExecuteEvents.触摸事件</param>
+        /// <typeparam name="T">事件类型</typeparam>
+        public static void UICastEvent<T>(PointerEventData eventData, ExecuteEvents.EventFunction<T> function)
+            where T : IEventSystemHandler
+        {
+            List<RaycastResult> results = new List<RaycastResult>();
+            EventSystem.current.RaycastAll(eventData, results);
+            GameObject current = eventData.pointerCurrentRaycast.gameObject;
+            for (int i = 0; i < results.Count; i++)
+            {
+                if (current != results[i].gameObject)
+                {
+                    ExecuteEvents.Execute(results[i].gameObject, eventData, function);//触摸事件传递!!!!!!
+                }
+            }
+        }
+
+        /// <summary>
+        /// 画布射线：穿透获取UI集合列表
+        /// </summary>
+        /// <param name="Canvas">画布射线组件</param>
+        /// <param name="position">屏幕坐标</param>
+        /// <returns>穿透的UI列表</returns>
+        public static List<RaycastResult> UIRayCast(GraphicRaycaster Canvas, Vector2 position)
+        {
+            PointerEventData eventData = new PointerEventData(EventSystem.current);
+            List<RaycastResult> list = new List<RaycastResult>();
+            eventData.position = position;
+            Canvas.Raycast(eventData, list);
+            return list;
+        }
+        /// <summary>
+        /// 画布射线：穿透获取UI集合列表
+        /// </summary>
+        /// <param name="canvas">画布射线组件</param>
+        /// <param name="point">屏幕坐标</param>
+        /// <param name="InterceptTag">拦截标签</param>
+        /// <param name="ignoreLayer">忽略层</param>
+        /// <returns> UI集合列表</returns>
+        public static List<RaycastResult> UIRayCast(GraphicRaycaster canvas, Vector2 point, string InterceptTag, string[] ignoreLayer)
+        {
+            List<RaycastResult> UI_List = new List<RaycastResult>();//提取物体列表
+            foreach (var UI in SS_Ray.UIRayCast(canvas, point))
+            {
+                if (!SS_GameObject.If_IgnoreLayer(UI.gameObject, ignoreLayer))
+                {
+                    UI_List.Add(UI);
+                    if (UI.gameObject.tag == InterceptTag) break;
+                }
+            }
+            return UI_List;
+        }
+
+        /// <summary>
+        /// UI射线：穿透获取UI集合列表
+        /// </summary>
+        /// <param name="position">屏幕坐标</param>
+        /// <returns>穿透的UI列表</returns>
+        public static List<RaycastResult> UIRayCast(Vector2 position)
+        {
+            PointerEventData eventData = new PointerEventData(EventSystem.current);
+            List<RaycastResult> list = new List<RaycastResult>();
+            eventData.position = position;
+            EventSystem.current.RaycastAll(eventData, list);
+            return list;
+        }
+
+        /// <summary>
+        /// UI射线：穿透获取UI集合列表
+        /// </summary>
+        /// <param name="point">屏幕坐标</param>
+        /// <param name="InterceptTag">拦截标签</param>
+        /// <param name="ignoreLayer">忽略层</param>
+        /// <returns> UI集合列表</returns>
+        public static List<RaycastResult> UIRayCast(Vector2 point, string InterceptTag, string[] ignoreLayer)
+        {
+            List<RaycastResult> UI_List = new List<RaycastResult>();//提取物体列表
+            foreach (var UI in SS_Ray.UIRayCast(point))
+            {
+                if (!SS_GameObject.If_IgnoreLayer(UI.gameObject, ignoreLayer))
+                {
+                    UI_List.Add(UI);
+                    if (UI.gameObject.tag == InterceptTag) break;
+                }
+            }
+            return UI_List;
+        }
+
+
+
+
+        /// <summary>
+        /// UI投射事件传递
+        /// </summary>
+        /// <param name="UI_Objects">UI投射集合列表</param>
+        /// <param name="eventData">eventData事件</param>
+        /// <param name="function">ExecuteEvents.触摸事件</param>
+        /// <typeparam name="T">类型</typeparam>
+        public static void UISendEvent<T>(List<RaycastResult> UI_Objects, PointerEventData eventData, ExecuteEvents.EventFunction<T> function)
+        where T : IEventSystemHandler//泛型约束
+        {
+            foreach (var UI_Object in UI_Objects)
+            {
+                if (UI_Object.gameObject != null)
+                {
+                    ExecuteEvents.Execute(UI_Object.gameObject, eventData, function);//触摸事件传递
+                }
+            }
+        }
+    }
+}
+
diff --git a/SDHK_Tool/Static/SS_Ray.cs.meta b/SDHK_Tool/Static/SS_Ray.cs.meta
new file mode 100644
index 0000000..f209c59
--- /dev/null
+++ b/SDHK_Tool/Static/SS_Ray.cs.meta
@@ -0,0 +1,13 @@
+fileFormatVersion: 2
+guid: 40d0470a56725fa4790cd0e0c231bb50
+timeCreated: 1560331298
+licenseType: Free
+MonoImporter:
+  externalObjects: {}
+  serializedVersion: 2
+  defaultReferences: []
+  executionOrder: 0
+  icon: {instanceID: 0}
+  userData: 
+  assetBundleName: 
+  assetBundleVariant: 
diff --git a/SDHK_Tool/Static/SS_Reflection.cs b/SDHK_Tool/Static/SS_Reflection.cs
new file mode 100644
index 0000000..ef89e6c
--- /dev/null
+++ b/SDHK_Tool/Static/SS_Reflection.cs
@@ -0,0 +1,830 @@
+﻿using System;
+using System.Collections;
+using System.Collections.Generic;
+using System.Globalization;
+using System.Reflection;
+using UnityEngine;
+using System.Linq;
+
+
+
+
+/*
+ * 作者：闪电Y黑客
+ *
+ * 日期：2019.11.14
+ * 
+ * 功能：用于反射的静态工具类
+ * 
+ */
+
+
+namespace SDHK_Tool.Static
+{
+
+    /// <summary>
+    /// 反射静态工具类
+    /// </summary>
+    public static class SS_Reflection
+    {
+
+        #region 查询
+
+        /// <summary>
+        /// 查询继承了接口的类
+        /// </summary>
+        /// <param name="assemblys">程序集</param>
+        /// <param name="Interface">接口</param>
+        /// <returns>类型集合</returns>
+        public static Type[] FindTypes_Interface(Assembly[] assemblys, Type Interface)
+        {
+            return assemblys.SelectMany(Assambly => Assambly.GetTypes().Where(T => T.GetInterfaces().Contains(Interface))).ToArray();
+        }
+
+        /// <summary>
+        /// 查询继承了父类的类
+        /// </summary>
+        /// <param name="assemblys">程序集</param>
+        /// <param name="Base">父类</param>
+        /// <returns>类型集合</returns>
+        public static Type[] FindTypes_Base(Assembly[] assemblys, Type Base)
+        {
+            return assemblys.SelectMany(Assambly => Assambly.GetTypes().Where(T => Equals(T.BaseType, Base))).ToArray();
+        }
+
+        #endregion
+
+        #region 反射DLL
+
+        /// <summary>
+        /// 读取加载到此应用程序域的程序集。
+        /// </summary>
+        /// <returns>程序集</returns>
+        public static Assembly[] GetThis_Assembly()
+        {
+            return AppDomain.CurrentDomain.GetAssemblies();
+        }
+
+        /// <summary>
+        /// 读取DLL：获取程序集
+        /// </summary>
+        /// <param name="DllPath">DLL路径</param>
+        /// <returns>数据元</returns>
+        public static Assembly GetDLL_Assembly(string DllPath)
+        {
+            return Assembly.LoadFrom(DllPath);
+        }
+
+        /// <summary>
+        /// 读取DLL：获取类型集合
+        /// </summary>
+        /// <param name="DllPath">DLL路径</param>
+        /// <returns>类型集合</returns>
+        public static Type[] GetDLL_Types(string DllPath)
+        {
+            return Assembly.LoadFrom(DllPath).GetTypes();
+        }
+
+        /// <summary>
+        /// 读取DLL：获取类型(单独反射消耗大)
+        /// </summary>
+        /// <param name="DllPath">DLL路径</param>
+        /// <param name="ObjectName">类型名字</param>
+        /// <returns>类型</returns>
+        public static Type GetDLL_Type(string DllPath, string ObjectName)
+        {
+            return Assembly.LoadFrom(DllPath).GetType(ObjectName);
+        }
+
+        /// <summary>
+        /// 读取DLL：新建实例化类(单独反射消耗大)
+        /// </summary>
+        /// <param name="DllPath">DLL路径</param>
+        /// <param name="ObjectName">类型名字</param>
+        /// <returns>实例化类</returns>
+        public static object GetDLL_Object(string DllPath, string ObjectName)
+        {
+            return Activator.CreateInstance(Assembly.LoadFrom(DllPath).GetType(ObjectName));
+        }
+
+        #endregion
+
+
+        #region 反射类
+
+
+        /// <summary>
+        /// 根据名字从程序集中新建类
+        /// </summary>
+        /// <param name="assembly">程序集</param>
+        /// <param name="ObjectName">类型名字(包括命名空间)</param>
+        /// <returns>实例化类</returns> 
+        public static object GetObject(Assembly assembly, string ObjectName)
+        {
+            return Activator.CreateInstance(assembly.GetType(ObjectName));
+        }
+
+        /// <summary>
+        /// 根据名字从程序集中获取类型
+        /// </summary>
+        /// <param name="assembly">程序集</param>
+        /// <param name="ObjectName">类型名字(包括命名空间)</param>
+        /// <returns>类型</returns>
+        public static Type GetType(Assembly assembly, string ObjectName)
+        {
+            return assembly.GetType(ObjectName);
+        }
+
+        /// <summary>
+        /// 根据名字新建类
+        /// </summary>
+        /// <param name="ObjectName">类型名字(包括命名空间)</param>
+        /// <returns>实例化类</returns>
+        public static object GetObject(string ObjectName)
+        {
+            return Activator.CreateInstance(Type.GetType(ObjectName));
+        }
+
+        /// <summary>
+        /// 根据类型新建类
+        /// </summary>
+        /// <param name="ObjectType">类型</param>
+        /// <returns>实例化类</returns>
+        public static object GetObject(Type ObjectType)
+        {
+            return Activator.CreateInstance(ObjectType);
+        }
+
+        /// <summary>
+        /// 根据名字新建类
+        /// </summary>
+        /// <param name="ObjectName">类型名字(包括命名空间)</param>
+        /// <param name="args">构造函数参数</param>
+        /// <returns>实例化类</returns>
+        public static object GetObject(string ObjectName, object[] args)
+        {
+            return Activator.CreateInstance(Type.GetType(ObjectName), args);
+        }
+
+        /// <summary>
+        /// 根据类型新建类
+        /// </summary>
+        /// <param name="ObjectType">类型</param>
+        /// <param name="args">构造函数参数</param>
+        /// <returns>实例化类</returns>
+        public static object GetObject(Type ObjectType, object[] args)
+        {
+            return Activator.CreateInstance(ObjectType, args);
+        }
+
+        #endregion
+
+        //================================================================================
+
+        #region  反射字段
+
+
+        #region 获取字段信息
+
+        /// <summary>
+        /// 获取字段信息集合：根据类型
+        /// </summary>
+        /// <param name="ObjectType">类型</param>
+        /// <param name="bindingFlags">属性过滤</param>
+        /// <returns>字段信息集合</returns>
+        public static FieldInfo[] GetInfos_Field(Type ObjectType, BindingFlags bindingFlags = BindingFlags.Instance | BindingFlags.Public)
+        {
+
+            return ObjectType.GetFields(bindingFlags);
+        }
+
+        /// <summary>
+        /// 获取字段信息集合：根据类型名字
+        /// </summary>
+        /// <param name="ObjectName">类型名(包括命名空间)</param>
+        /// <param name="bindingFlags">属性过滤</param>
+        /// <returns>字段信息集合</returns>
+        public static FieldInfo[] GetInfos_Field(string ObjectName, BindingFlags bindingFlags = BindingFlags.Instance | BindingFlags.Public)
+        {
+            return Type.GetType(ObjectName).GetFields(bindingFlags);
+        }
+
+        /// <summary>
+        /// 获取字段信息集合：根据实例化类
+        /// </summary>
+        /// <param name="_Object">实例化类</param>
+        /// <param name="bindingFlags">属性过滤</param>
+        /// <returns>字段信息集合</returns>
+        public static FieldInfo[] GetInfos_Field<T>(T _Object, BindingFlags bindingFlags = BindingFlags.Instance | BindingFlags.Public)
+        {
+            return _Object.GetType().GetFields(bindingFlags);
+        }
+
+
+
+        /// <summary>
+        /// 获取字段信息：根据类型
+        /// </summary>
+        /// <param name="ObjectType">类型</param>
+        /// <param name="PropertyName">字段名</param>
+        /// <param name="bindingFlags">属性过滤</param>
+        /// <returns>字段信息</returns>
+        public static FieldInfo GetInfo_Field(Type ObjectType, string FieldName, BindingFlags bindingFlags = BindingFlags.Instance | BindingFlags.Public)
+        {
+            return ObjectType.GetField(FieldName, bindingFlags);
+        }
+
+
+        /// <summary>
+        /// 获取字段信息：根据类型名字
+        /// </summary>
+        /// <param name="ObjectName">类型名(包括命名空间)</param>
+        /// <param name="PropertyName">字段名</param>
+        /// <param name="bindingFlags">属性过滤</param>
+        /// <returns>字段信息</returns>
+        public static FieldInfo GetInfo_Field(string ObjectName, string FieldName, BindingFlags bindingFlags = BindingFlags.Instance | BindingFlags.Public)
+        {
+            return GetInfo_Field(Type.GetType(ObjectName), FieldName, bindingFlags);
+        }
+
+
+        /// <summary>
+        /// 获取字段信息：根据实例化类
+        /// </summary>
+        /// <param name="_Object">实例化类</param>
+        /// <param name="PropertyName">字段名</param>
+        /// <param name="bindingFlags">属性过滤</param>
+        /// <returns>字段信息</returns>
+        public static FieldInfo GetInfo_Field<T>(T _Object, string FieldName, BindingFlags bindingFlags = BindingFlags.Instance | BindingFlags.Public)
+        {
+            return _Object.GetType().GetField(FieldName, bindingFlags);
+        }
+
+        #endregion
+
+        #region 获取字段
+
+        //===============================================
+
+        /// <summary>
+        /// 获取字段：根据实例化类
+        /// </summary>
+        /// <param name="_Object">实例化类</param>
+        /// <param name="PropertyName">字段名</param>
+        /// <param name="bindingFlags">属性过滤</param>
+        /// <returns>字段</returns>
+        public static object Get_Field<T>(T _Object, string FieldName, BindingFlags bindingFlags = BindingFlags.Instance | BindingFlags.Public)
+        {
+            return _Object.GetType().GetField(FieldName, bindingFlags).GetValue(_Object);
+        }
+
+        /// <summary>
+        /// 获取静态类字段：根据类型
+        /// </summary>
+        /// <param name="ObjectType">类型</param>
+        /// <param name="PropertyName">字段名</param>
+        /// <param name="bindingFlags">属性过滤</param>
+        /// <returns>字段</returns>
+        public static object Get_Field(Type ObjectType, string FieldName, BindingFlags bindingFlags = BindingFlags.Static | BindingFlags.Public)
+        {
+            return ObjectType.GetField(FieldName, bindingFlags).GetValue(null);
+        }
+
+        /// <summary>
+        /// 获取静态类字段：根据类型名字
+        /// </summary>
+        /// <param name="ObjectName">类型名(包括命名空间)</param>
+        /// <param name="PropertyName">字段名</param>
+        /// <param name="bindingFlags">属性过滤</param>
+        /// <returns>字段</returns>
+        public static object Get_Field(string ObjectName, string FieldName, BindingFlags bindingFlags = BindingFlags.Static | BindingFlags.Public)
+        {
+            return Type.GetType(ObjectName).GetField(FieldName, bindingFlags).GetValue(null);
+        }
+
+        #endregion
+
+
+
+        #region 设置字段
+
+        /// <summary>
+        /// 设置字段：根据实例化类
+        /// </summary>
+        /// <param name="_Object">实例化类</param>
+        /// <param name="PropertyName">字段名</param>
+        /// <param name="value">设置值</param>
+        /// <param name="bindingFlags">属性过滤</param>
+        /// <param name="binder">自定义绑定器</param>
+        /// <param name="culture">设置文化</param>
+        public static void Set_Field<T>(T _Object, string FieldName, object value, BindingFlags bindingFlags = BindingFlags.Instance | BindingFlags.Public, Binder binder = null, CultureInfo culture = null)
+        {
+            _Object.GetType().GetField(FieldName, bindingFlags).SetValue(_Object, value, bindingFlags, binder, culture);
+        }
+
+        /// <summary>
+        /// 设置静态类字段：根据类型
+        /// </summary>
+        /// <param name="ObjectType">类型</param>
+        /// <param name="PropertyName">字段名</param>
+        /// <param name="value">设置值</param>
+        /// <param name="bindingFlags">属性过滤</param>
+        /// <param name="binder">自定义绑定器</param>
+        /// <param name="culture">设置文化</param>
+        public static void Set_Field(Type ObjectType, string FieldName, object value, BindingFlags bindingFlags = BindingFlags.Instance | BindingFlags.Public, Binder binder = null, CultureInfo culture = null)
+        {
+            ObjectType.GetField(FieldName, bindingFlags).SetValue(null, value, bindingFlags, binder, culture);
+        }
+
+        /// <summary>
+        /// 设置静态类字段：根据类型名字
+        /// </summary>
+        /// <param name="ObjectName">类型名字(包括命名空间)</param>
+        /// <param name="PropertyName">字段名</param>
+        /// <param name="value">设置值</param>
+        /// <param name="bindingFlags">属性过滤</param>
+        /// <param name="binder">自定义绑定器</param>
+        /// <param name="culture">设置文化</param>
+        public static void Set_Field(string ObjectName, string FieldName, object value, BindingFlags bindingFlags = BindingFlags.Instance | BindingFlags.Public, Binder binder = null, CultureInfo culture = null)
+        {
+            Type.GetType(ObjectName).GetField(FieldName, bindingFlags).SetValue(null, value, bindingFlags, binder, culture);
+        }
+
+        #endregion
+
+
+        #endregion
+
+        //================================================================================
+
+
+        #region  反射属性
+
+
+        #region 获取属性信息
+
+        /// <summary>
+        /// 获取属性信息集合：根据类型
+        /// </summary>
+        /// <param name="ObjectType">类型</param>
+        /// <param name="bindingFlags">属性过滤</param>
+        /// <returns>属性信息集合</returns>
+        public static PropertyInfo[] GetInfos_Property(Type ObjectType, BindingFlags bindingFlags = BindingFlags.Instance | BindingFlags.Public)
+        {
+            return ObjectType.GetProperties(bindingFlags);
+        }
+
+        /// <summary>
+        /// 获取属性信息集合：根据类型名字
+        /// </summary>
+        /// <param name="ObjectName">类型名(包括命名空间)</param>
+        /// <param name="bindingFlags">属性过滤</param>
+        /// <returns>属性信息集合</returns>
+        public static PropertyInfo[] GetInfos_Property(string ObjectName, BindingFlags bindingFlags = BindingFlags.Instance | BindingFlags.Public)
+        {
+            return Type.GetType(ObjectName).GetProperties(bindingFlags);
+        }
+
+        /// <summary>
+        /// 获取属性信息集合：根据实例化类
+        /// </summary>
+        /// <param name="_Object">实例化类</param>
+        /// <param name="bindingFlags">属性过滤</param>
+        /// <returns>属性信息集合</returns>
+        public static PropertyInfo[] GetInfos_Property<T>(T _Object, BindingFlags bindingFlags = BindingFlags.Instance | BindingFlags.Public)
+        {
+            return _Object.GetType().GetProperties(bindingFlags);
+        }
+
+
+
+
+        /// <summary>
+        /// 获取属性信息：根据类型
+        /// </summary>
+        /// <param name="ObjectType">类型</param>
+        /// <param name="PropertyName">属性名</param>
+        /// <param name="bindingFlags">属性过滤</param>
+        /// <returns>属性信息</returns>
+        public static PropertyInfo GetInfo_Property(Type ObjectType, string PropertyName, BindingFlags bindingFlags = BindingFlags.Instance | BindingFlags.Public)
+        {
+            return ObjectType.GetProperty(PropertyName, bindingFlags);
+        }
+
+        /// <summary>
+        /// 获取属性信息：根据类型
+        /// </summary>
+        /// <param name="ObjectType">类型</param>
+        /// <param name="PropertyName">属性名</param>
+        /// <param name="returnType">返回参数类型</param>
+        /// <param name="types">参数类型</param>
+        /// <param name="bindingFlags">属性过滤</param>
+        /// <param name="parameters">传入参数</param>
+        /// <param name="binder">自定义绑定器</param>
+        /// <returns>属性信息</returns>
+        public static PropertyInfo GetInfo_Property(Type ObjectType, string PropertyName, Type returnType, Type[] types, BindingFlags bindingFlags = BindingFlags.Instance | BindingFlags.Public, ParameterModifier[] parameters = null, Binder binder = null)
+        {
+            return ObjectType.GetProperty(PropertyName, bindingFlags, binder, returnType, types, parameters);
+        }
+
+
+        /// <summary>
+        /// 获取属性信息：根据类型名字
+        /// </summary>
+        /// <param name="ObjectName">类型名(包括命名空间)</param>
+        /// <param name="PropertyName">属性名</param>
+        /// <param name="bindingFlags">属性过滤</param>
+        /// <returns>属性信息</returns>
+        public static PropertyInfo GetInfo_Property(string ObjectName, string PropertyName, BindingFlags bindingFlags = BindingFlags.Instance | BindingFlags.Public)
+        {
+            return Type.GetType(ObjectName).GetProperty(PropertyName, bindingFlags);
+        }
+
+
+        /// <summary>
+        /// 获取属性信息：根据类型名字
+        /// </summary>
+        /// <param name="ObjectName">类型名(包括命名空间)</param>
+        /// <param name="PropertyName">属性名</param>
+        /// <param name="returnType">返回参数类型</param>
+        /// <param name="types">参数类型</param>
+        /// <param name="bindingFlags">属性过滤</param>
+        /// <param name="parameters">传入参数</param>
+        /// <param name="binder">自定义绑定器</param>
+        /// <returns>属性信息</returns>
+        public static PropertyInfo GetInfo_Property(string ObjectName, string PropertyName, Type returnType, Type[] types, BindingFlags bindingFlags = BindingFlags.Instance | BindingFlags.Public, ParameterModifier[] parameters = null, Binder binder = null)
+        {
+            return Type.GetType(ObjectName).GetProperty(PropertyName, bindingFlags, binder, returnType, types, parameters);
+        }
+
+
+        /// <summary>
+        /// 获取属性信息：根据实例化类
+        /// </summary>
+        /// <param name="_Object">实例化类</param>
+        /// <param name="PropertyName">属性名</param>
+        /// <param name="bindingFlags">属性过滤</param>
+        /// <returns>属性信息</returns>
+        public static PropertyInfo GetInfo_Property<T>(T _Object, string PropertyName, BindingFlags bindingFlags = BindingFlags.Instance | BindingFlags.Public)
+        {
+            return _Object.GetType().GetProperty(PropertyName, bindingFlags);
+        }
+
+
+        /// <summary>
+        /// 获取属性信息：根据实例化类
+        /// </summary>
+        /// <param name="_Object">实例化类</param>
+        /// <param name="PropertyName">属性名</param>
+        /// <param name="returnType">返回参数类型</param>
+        /// <param name="types">参数类型</param>
+        /// <param name="bindingFlags">属性过滤</param>
+        /// <param name="parameters">传入参数</param>
+        /// <param name="binder">自定义绑定器</param>
+        /// <returns>属性信息</returns>
+        public static PropertyInfo GetInfo_Property<T>(T _Object, string PropertyName, Type returnType, Type[] types, BindingFlags bindingFlags = BindingFlags.Instance | BindingFlags.Public, ParameterModifier[] parameters = null, Binder binder = null)
+        {
+            return _Object.GetType().GetProperty(PropertyName, bindingFlags, binder, returnType, types, parameters);
+        }
+
+        #endregion
+
+
+
+        #region 获取属性
+
+        /// <summary>
+        /// 获取属性：根据实例化类
+        /// </summary>
+        /// <param name="_Object">实例化类</param>
+        /// <param name="PropertyName">属性名</param>
+        /// <param name="bindingFlags">属性过滤</param>
+        /// <param name="index">索引器</param>
+        /// <returns>属性</returns>
+        public static object Get_Property<T>(T _Object, string PropertyName, BindingFlags bindingFlags = BindingFlags.Instance | BindingFlags.Public, object[] index = null)
+        {
+            return _Object.GetType().GetProperty(PropertyName, bindingFlags).GetValue(_Object, index);
+        }
+
+        /// <summary>
+        /// 获取静态类属性：根据类型
+        /// </summary>
+        /// <param name="ObjectType">类型</param>
+        /// <param name="PropertyName">属性名</param>
+        /// <param name="bindingFlags">属性过滤</param>
+        /// <param name="index">索引器</param>
+        /// <returns>属性</returns>
+        public static object Get_Property(Type ObjectType, string PropertyName, BindingFlags bindingFlags = BindingFlags.Static | BindingFlags.Public, object[] index = null)
+        {
+            return ObjectType.GetProperty(PropertyName, bindingFlags).GetValue(null, index);
+        }
+
+        /// <summary>
+        /// 获取静态类属性：根据类型名字
+        /// </summary>
+        /// <param name="ObjectName">类型名(包括命名空间)</param>
+        /// <param name="PropertyName">属性名</param>
+        /// <param name="bindingFlags">属性过滤</param>
+        /// <param name="index">索引器</param>
+        /// <returns>属性</returns>
+        public static object Get_Property(string ObjectName, string PropertyName, BindingFlags bindingFlags = BindingFlags.Static | BindingFlags.Public, object[] index = null)
+        {
+            return Type.GetType(ObjectName).GetProperty(PropertyName, bindingFlags).GetValue(null, index);
+        }
+
+        #endregion
+
+
+
+        #region  设置属性
+
+        /// <summary>
+        /// 设置属性：根据实例化类
+        /// </summary>
+        /// <param name="_Object">实例化类</param>
+        /// <param name="PropertyName">属性名</param>
+        /// <param name="value">设置值</param>
+        /// <param name="bindingFlags">属性过滤</param>
+        /// <param name="binder">自定义绑定器</param>
+        /// <param name="index">索引器</param>
+        /// <param name="culture">设置文化</param>
+        public static void Set_Property<T>(T _Object, string PropertyName, object value, BindingFlags bindingFlags = BindingFlags.Instance | BindingFlags.Public, Binder binder = null, object[] index = null, CultureInfo culture = null)
+        {
+            _Object.GetType().GetProperty(PropertyName, bindingFlags).SetValue(_Object, value, bindingFlags, binder, index, culture);
+        }
+
+        /// <summary>
+        /// 设置静态类属性：根据类型
+        /// </summary>
+        /// <param name="ObjectType">类型</param>
+        /// <param name="PropertyName">属性名</param>
+        /// <param name="value">设置值</param>
+        /// <param name="bindingFlags">属性过滤</param>
+        /// <param name="binder">自定义绑定器</param>
+        /// <param name="index">索引器</param>
+        /// <param name="culture">设置文化</param>
+        public static void Set_Property(Type ObjectType, string PropertyName, object value, BindingFlags bindingFlags = BindingFlags.Instance | BindingFlags.Public, Binder binder = null, object[] index = null, CultureInfo culture = null)
+        {
+            ObjectType.GetProperty(PropertyName, bindingFlags).SetValue(null, value, bindingFlags, binder, index, culture);
+        }
+
+        /// <summary>
+        /// 设置静态类属性：根据类型名字
+        /// </summary>
+        /// <param name="ObjectName">类型名字(包括命名空间)</param>
+        /// <param name="PropertyName">属性名</param>
+        /// <param name="value">设置值</param>
+        /// <param name="bindingFlags">属性过滤</param>
+        /// <param name="binder">自定义绑定器</param>
+        /// <param name="index">索引器</param>
+        /// <param name="culture">设置文化</param>
+        public static void Set_Property(string ObjectName, string PropertyName, object value, BindingFlags bindingFlags = BindingFlags.Instance | BindingFlags.Public, Binder binder = null, object[] index = null, CultureInfo culture = null)
+        {
+            Type.GetType(ObjectName).GetProperty(PropertyName, bindingFlags).SetValue(null, value, bindingFlags, binder, index, culture);
+        }
+
+        #endregion
+
+
+        #endregion
+
+
+        //================================================================================
+
+
+
+        #region  反射方法
+
+
+        #region  获取方法信息
+
+        /// <summary>
+        /// 获取方法信息集合：根据类型
+        /// </summary>
+        /// <param name="ObjectType">类型</param>
+        /// <param name="bindingFlags">属性过滤</param>
+        /// <returns>方法信息集合</returns>
+        public static MethodInfo[] GetInfos_Method(Type ObjectType, BindingFlags bindingFlags = BindingFlags.Instance | BindingFlags.Public)
+        {
+            return ObjectType.GetMethods(bindingFlags);
+        }
+
+        /// <summary>
+        /// 获取方法信息集合：根据类型名字
+        /// </summary>
+        /// <param name="ObjectName">类型名(包括命名空间)</param>
+        /// <param name="bindingFlags">属性过滤</param>
+        /// <returns>方法信息集合</returns>
+        public static MethodInfo[] GetInfos_Method(string ObjectName, BindingFlags bindingFlags = BindingFlags.Instance | BindingFlags.Public)
+        {
+            return Type.GetType(ObjectName).GetMethods(bindingFlags);
+        }
+
+
+        /// <summary>
+        /// 获取方法信息集合：根据实例化类
+        /// </summary>
+        /// <param name="_Object">实例化类</param>
+        /// <param name="bindingFlags">属性过滤</param>
+        /// <returns>方法信息集合</returns>
+        public static MethodInfo[] GetInfos_Method<T>(T _Object, BindingFlags bindingFlags = BindingFlags.Instance | BindingFlags.Public)
+        {
+            return _Object.GetType().GetMethods(bindingFlags);
+        }
+
+
+
+
+        /// <summary>
+        /// 获取方法信息：根据类型
+        /// </summary>
+        /// <param name="ObjectType">类型</param>
+        /// <param name="MethodName">方法名</param>
+        /// <param name="bindingFlags">属性过滤</param>
+        /// <returns>方法信息</returns>
+        public static MethodInfo GetInfo_Method(Type ObjectType, string MethodName, BindingFlags bindingFlags = BindingFlags.Instance | BindingFlags.Public)
+        {
+            return ObjectType.GetMethod(MethodName, bindingFlags);
+        }
+
+
+
+        /// <summary>
+        /// 获取方法信息：根据类型
+        /// </summary>
+        /// <param name="ObjectType">类型</param>
+        /// <param name="MethodName">方法名</param>
+        /// <param name="types">参数类型</param>
+        /// <param name="bindingFlags">属性过滤</param>
+        /// <param name="modifiers">参数修改器</param>
+        /// <param name="binder">自定义绑定器</param>
+        /// <returns>方法信息</returns>
+        public static MethodInfo GetInfo_Method(Type ObjectType, string MethodName, Type[] types, BindingFlags bindingFlags = BindingFlags.Instance | BindingFlags.Public, ParameterModifier[] modifiers = null, Binder binder = null)
+        {
+            return ObjectType.GetMethod(MethodName, bindingFlags, binder, types, modifiers);
+        }
+
+
+        /// <summary>
+        /// 获取方法信息：根据类型名字
+        /// </summary>
+        /// <param name="ObjectName">类型名(包括命名空间)</param>
+        /// <param name="MethodName">方法名</param>
+        /// <param name="bindingFlags">属性过滤</param>
+        /// <returns>方法信息</returns>
+        public static MethodInfo GetInfo_Method(string ObjectName, string MethodName, BindingFlags bindingFlags = BindingFlags.Instance | BindingFlags.Public)
+        {
+            return Type.GetType(ObjectName).GetMethod(MethodName, bindingFlags);
+        }
+
+
+        /// <summary>
+        /// 获取方法信息：根据类型名字
+        /// </summary>
+        /// <param name="ObjectType">类型名(包括命名空间)</param>
+        /// <param name="MethodName">方法名</param>
+        /// <param name="types">参数类型</param>
+        /// <param name="bindingFlags">属性过滤</param>
+        /// <param name="modifiers">参数修改器</param>
+        /// <param name="binder">自定义绑定器</param>
+        /// <returns>方法信息</returns>
+        public static MethodInfo GetInfo_Method(string ObjectName, string MethodName, Type[] types, BindingFlags bindingFlags = BindingFlags.Instance | BindingFlags.Public, ParameterModifier[] modifiers = null, Binder binder = null)
+        {
+            return Type.GetType(ObjectName).GetMethod(MethodName, bindingFlags, binder, types, modifiers);
+        }
+
+
+        /// <summary>
+        /// 获取方法信息：根据实例化类
+        /// </summary>
+        /// <param name="_Object">实例化类</param>
+        /// <param name="MethodName">方法名</param>
+        /// <param name="bindingFlags">属性过滤</param>
+        /// <returns>方法信息</returns>
+        public static MethodInfo GetInfo_Method<T>(T _Object, string MethodName, BindingFlags bindingFlags = BindingFlags.Instance | BindingFlags.Public)
+        {
+            return _Object.GetType().GetMethod(MethodName, bindingFlags);
+        }
+
+
+        /// <summary>
+        /// 获取方法信息：根据实例化类
+        /// </summary>
+        /// <param name="_Object">实例化类</param>
+        /// <param name="MethodName">方法名</param>
+        /// <param name="types">参数类型</param>
+        /// <param name="bindingFlags">属性过滤</param>
+        /// <param name="modifiers">参数修改器</param>
+        /// <param name="binder">自定义绑定器</param>
+        /// <returns>方法信息</returns>
+        public static MethodInfo GetInfo_Method<T>(T _Object, string MethodName, Type[] types, BindingFlags bindingFlags = BindingFlags.Instance | BindingFlags.Public, ParameterModifier[] modifiers = null, Binder binder = null)
+        {
+            return _Object.GetType().GetMethod(MethodName, bindingFlags, binder, types, modifiers);
+        }
+
+        #endregion
+
+
+
+        #region 调用方法
+
+        /// <summary>
+        /// 调用方法：根据实例化类
+        /// </summary>
+        /// <param name="_Object">实例化类</param>
+        /// <param name="MethodName">方法名</param>
+        /// <param name="parameters">参数</param>
+        /// <param name="bindingFlags">属性过滤</param>
+        /// <returns>方法返回值</returns>
+        public static object Call_Method<T>(T _Object, string MethodName, object[] parameters = null, BindingFlags bindingFlags = BindingFlags.Instance | BindingFlags.Public)
+        {
+            return _Object.GetType().GetMethod(MethodName, bindingFlags).Invoke(_Object, parameters);
+        }
+
+
+        /// <summary>
+        /// 调用方法：根据实例化类
+        /// </summary>
+        /// <param name="_Object">实例化类</param>
+        /// <param name="MethodName">方法名</param>
+        /// <param name="types">参数类型</param>
+        /// <param name="parameters">参数</param>
+        /// <param name="bindingFlags">属性过滤</param>
+        /// <param name="modifiers">参数修改器</param>
+        /// <param name="binder">自定义绑定器</param>
+        /// <returns>方法返回值</returns>
+        public static object Call_Method<T>(T _Object, string MethodName, Type[] types, object[] parameters, BindingFlags bindingFlags = BindingFlags.Instance | BindingFlags.Public, ParameterModifier[] modifiers = null, Binder binder = null)
+        {
+            return _Object.GetType().GetMethod(MethodName, bindingFlags, binder, types, modifiers).Invoke(_Object, parameters);
+        }
+
+
+        /// <summary>
+        /// 调用静态方法：根据类型名字
+        /// </summary>
+        /// <param name="ObjectName">类型名(包括命名空间)</param>
+        /// <param name="MethodName">方法名</param>
+        /// <param name="parameters">参数</param>
+        /// <param name="bindingFlags">属性过滤</param>
+        /// <returns>方法返回值</returns>
+        public static object Call_Method(string ObjectName, string MethodName, object[] parameters = null, BindingFlags bindingFlags = BindingFlags.Static | BindingFlags.Public)
+        {
+            return Type.GetType(ObjectName).GetMethod(MethodName, bindingFlags).Invoke(null, parameters);
+        }
+
+
+        /// <summary>
+        /// 调用静态方法：根据类型名字
+        /// </summary>
+        /// <param name="ObjectName">类型名(包括命名空间)</param>
+        /// <param name="MethodName">方法名</param>
+        /// <param name="types">参数类型</param>
+        /// <param name="parameters">参数</param>
+        /// <param name="bindingFlags">属性过滤</param>
+        /// <param name="modifiers">参数修改器</param>
+        /// <param name="binder">自定义绑定器</param>
+        /// <returns>方法返回值</returns>
+        public static object Call_Method(string ObjectName, string MethodName, Type[] types, object[] parameters, BindingFlags bindingFlags = BindingFlags.Static | BindingFlags.Public, ParameterModifier[] modifiers = null, Binder binder = null)
+        {
+            return Type.GetType(ObjectName).GetMethod(MethodName, bindingFlags, binder, types, modifiers).Invoke(null, parameters);
+        }
+
+
+        /// <summary>
+        /// 调用静态方法：根据类型
+        /// </summary>
+        /// <param name="ObjectType">类型</param>
+        /// <param name="MethodName">方法名</param>
+        /// <param name="parameters">参数</param>
+        /// <param name="bindingFlags">属性过滤</param>
+        /// <returns>方法返回值</returns>
+        public static object Call_Method(Type ObjectType, string MethodName, object[] parameters = null, BindingFlags bindingFlags = BindingFlags.Static | BindingFlags.Public)
+        {
+            return ObjectType.GetMethod(MethodName, bindingFlags).Invoke(null, parameters);
+        }
+
+
+        /// <summary>
+        /// 调用静态方法：根据类型
+        /// </summary>
+        /// <param name="ObjectType">类型</param>
+        /// <param name="MethodName">方法名</param>
+        /// <param name="types">参数类型</param>
+        /// <param name="parameters">参数</param>
+        /// <param name="bindingFlags">属性过滤</param>
+        /// <param name="modifiers">参数修改器</param>
+        /// <param name="binder">自定义绑定器</param>
+        /// <returns>方法返回值</returns>
+        public static object Call_Method(Type ObjectType, string MethodName, Type[] types, object[] parameters, BindingFlags bindingFlags = BindingFlags.Static | BindingFlags.Public, ParameterModifier[] modifiers = null, Binder binder = null)
+        {
+            return ObjectType.GetMethod(MethodName, bindingFlags, binder, types, modifiers).Invoke(null, parameters);
+        }
+
+        #endregion
+
+
+        #endregion
+
+
+    }
+}
diff --git a/SDHK_Tool/Static/SS_Reflection.cs.meta b/SDHK_Tool/Static/SS_Reflection.cs.meta
new file mode 100644
index 0000000..ccc1f4d
--- /dev/null
+++ b/SDHK_Tool/Static/SS_Reflection.cs.meta
@@ -0,0 +1,13 @@
+fileFormatVersion: 2
+guid: f2d5d43474d7cae4f9545204236983da
+timeCreated: 1573708610
+licenseType: Pro
+MonoImporter:
+  externalObjects: {}
+  serializedVersion: 2
+  defaultReferences: []
+  executionOrder: 0
+  icon: {instanceID: 0}
+  userData: 
+  assetBundleName: 
+  assetBundleVariant: 
diff --git a/SDHK_Tool/Static/SS_Rotation.cs b/SDHK_Tool/Static/SS_Rotation.cs
new file mode 100644
index 0000000..c15fab3
--- /dev/null
+++ b/SDHK_Tool/Static/SS_Rotation.cs
@@ -0,0 +1,126 @@
+﻿using UnityEngine;
+
+/*
+ * 作者：闪电Y黑客
+ * 
+ * 日期： 2019.6.11
+ * 
+ * 功能：旋转方法的集合类
+ */
+
+namespace SDHK_Tool.Static
+{
+
+    /// <summary>
+    /// 旋转集合
+    /// </summary>
+    public static class SS_Rotation
+    {
+        /// <summary>
+        /// 欧拉角匀速旋转
+        /// </summary>
+        /// <param name="CurrentEulerAngle">当前欧拉角</param>
+        /// <param name="TargetEulerAngle">目标欧拉角</param>
+        /// <param name="RotationSpeed">旋转速度</param>
+        /// <returns>return : 旋转后的欧拉角</returns>
+        public static Vector3 EulerAngles_MoveTowards(Vector3 CurrentEulerAngle, Vector3 TargetEulerAngle, float RotationSpeed)
+        {
+            CurrentEulerAngle.x = Mathf.MoveTowardsAngle(CurrentEulerAngle.x, TargetEulerAngle.x, RotationSpeed);
+            CurrentEulerAngle.y = Mathf.MoveTowardsAngle(CurrentEulerAngle.y, TargetEulerAngle.y, RotationSpeed);
+            CurrentEulerAngle.z = Mathf.MoveTowardsAngle(CurrentEulerAngle.z, TargetEulerAngle.z, RotationSpeed);
+            return CurrentEulerAngle;
+        }
+
+        /// <summary>
+        /// 欧拉角插值旋转
+        /// </summary>
+        /// <param name="CurrentEulerAngle">当前欧拉角</param>
+        /// <param name="TargetEulerAngle">目标欧拉角</param>
+        /// <param name="RotationSpeed">旋转速度（差值比例）</param>
+        /// <returns>return : 旋转后的欧拉角</returns>
+        public static Vector3 EulerAngles_Lerp(Vector3 CurrentEulerAngle, Vector3 TargetEulerAngle, float RotationSpeed)
+        {
+            CurrentEulerAngle.x = Mathf.LerpAngle(CurrentEulerAngle.x, TargetEulerAngle.x, RotationSpeed);
+            CurrentEulerAngle.y = Mathf.LerpAngle(CurrentEulerAngle.y, TargetEulerAngle.y, RotationSpeed);
+            CurrentEulerAngle.z = Mathf.LerpAngle(CurrentEulerAngle.z, TargetEulerAngle.z, RotationSpeed);
+            return CurrentEulerAngle;
+        }
+
+        /// <summary>
+        /// 欧拉角平滑旋转
+        /// </summary>
+        /// <param name="CurrentEulerAngle">当前欧拉角</param>
+        /// <param name="TargetEulerAngle">目标欧拉角</param>
+        /// <param name="yVelocity">ref 当前速度</param>
+        /// <param name="MoveTime">到达目标的近似时间</param>
+        /// <returns>return : 旋转后的欧拉角</returns>
+        public static Vector3 EulerAngles_SmoothDamp(Vector3 CurrentEulerAngle, Vector3 TargetEulerAngle, ref Vector3 yVelocity, float MoveTime)
+        {
+            CurrentEulerAngle.x = Mathf.SmoothDampAngle(CurrentEulerAngle.x, TargetEulerAngle.x, ref yVelocity.x, MoveTime);
+            CurrentEulerAngle.y = Mathf.SmoothDampAngle(CurrentEulerAngle.y, TargetEulerAngle.y, ref yVelocity.y, MoveTime);
+            CurrentEulerAngle.z = Mathf.SmoothDampAngle(CurrentEulerAngle.z, TargetEulerAngle.z, ref yVelocity.z, MoveTime);
+            return CurrentEulerAngle;
+        }
+
+        /// <summary>
+        /// 欧拉角自轴旋转
+        /// </summary>
+        /// <param name="CurrentEulerAngle">当前物体欧拉角(transform.eulerAngles)</param>
+        /// <param name="direction">旋转轴向量及角度大小（Vector3.up）</param>
+        /// <returns>return : 自转后的欧拉角</returns>
+        public static Vector3 EulerAngles_AxisRotation(Vector3 CurrentEulerAngle, Vector3 direction)
+        {
+            return (Quaternion.Euler(CurrentEulerAngle) * Quaternion.Euler(direction)).eulerAngles;
+        }
+
+
+        /// <summary>
+        /// 匀速旋转
+        /// </summary>
+        /// <param name="CurrentAngle">当前角度</param>
+        /// <param name="TargetAngle">目标角度</param>
+        /// <param name="RotationSpeed">旋转速度</param>
+        /// <returns>return : 旋转后的角度</returns>
+        public static float Angle_MoveTowards(float CurrentAngle, float TargetAngle, float RotationSpeed)
+        {
+            return Mathf.MoveTowardsAngle(CurrentAngle, TargetAngle, RotationSpeed);
+        }
+
+        /// <summary>
+        /// 差值旋转
+        /// </summary>
+        /// <param name="CurrentAngle">当前角度</param>
+        /// <param name="TargetAngle">目标角度</param>
+        /// <param name="RotationSpeed">旋转速度</param>
+        /// <returns>return : 旋转后的角度</returns>
+        public static float Angle_Lerp(float CurrentAngle, float TargetAngle, float RotationSpeed)
+        {
+            return Mathf.LerpAngle(CurrentAngle, TargetAngle, RotationSpeed);
+        }
+
+        /// <summary>
+        /// 平滑旋转
+        /// </summary>
+        /// <param name="CurrentAngle">当前角度</param>
+        /// <param name="TargetAngle">目标角度</param>
+        /// <param name="yVelocity">ref 当前速度</param>
+        /// <param name="MoveTime">到达目标的近似时间</param>
+        /// <returns>return : 旋转后的角度</returns>
+        public static float Angle_SmoothDamp(float CurrentAngle, float TargetAngle, ref float yVelocity, float MoveTime)
+        {
+            return Mathf.SmoothDampAngle(CurrentAngle, TargetAngle, ref yVelocity, MoveTime);
+        }
+
+        /// <summary>
+        /// 自轴旋转
+        /// </summary>
+        /// <param name="CurrentAngle">当前角度</param>
+        /// <param name="direction">方向值</param>
+        /// <returns>return : 自转后的角度</returns>
+        public static float Angle_AxisRotation(float CurrentAngle, float direction)
+        {
+            return SS_EulerAngleConversion.Angle_PN_To_P360(CurrentAngle + direction);
+        }
+
+    }
+}
diff --git a/SDHK_Tool/Static/SS_Texture.cs b/SDHK_Tool/Static/SS_Texture.cs
new file mode 100644
index 0000000..1fa161e
--- /dev/null
+++ b/SDHK_Tool/Static/SS_Texture.cs
@@ -0,0 +1,109 @@
+﻿using System.Collections;
+using System.Collections.Generic;
+using UnityEngine;
+
+
+/*
+ * 作者：闪电Y黑客
+ * 
+ * 日期： 2019.9.6
+ * 
+ * 功能：对Texture的转换处理
+ */
+
+namespace SDHK_Tool.Static
+{
+
+    /// <summary>
+    /// 对Texture的转换处理
+    /// </summary>
+    public static class SS_Texture
+    {
+
+        /// <summary>
+        /// Texture2D纹理翻转：
+        /// </summary>
+        /// <param name="texture">Texture2D纹理</param>
+        /// <param name="Flip">翻转模式：0~4</param>
+        /// <returns>翻转后的Texture2D纹理</returns>
+        public static Texture2D Texture2D_Flip(Texture2D texture, TextureFlip Flip = TextureFlip.无翻转)
+        {
+            Texture2D newTexture;
+
+            switch (Flip)
+            {
+                case TextureFlip.无翻转: return texture;
+                case TextureFlip.顺时针水平翻转:
+                case TextureFlip.逆时针水平翻转:
+                case TextureFlip.顺时针90度:
+                case TextureFlip.逆时针90度: newTexture = new Texture2D(texture.height, texture.width); break;
+                case TextureFlip.旋转180度:
+                case TextureFlip.垂直翻转:
+                case TextureFlip.水平翻转: newTexture = new Texture2D(texture.width, texture.height); break;
+
+                default: newTexture = texture; break;
+            }
+
+            int width = texture.width - 1;
+            int height = texture.height - 1;
+
+            for (int i = 0; i < width + 1; i++)
+            {
+                for (int j = 0; j < height + 1; j++)
+                {
+                    Color color = texture.GetPixel(i, j);
+                    switch (Flip)
+                    {
+                        case TextureFlip.顺时针90度: newTexture.SetPixel(j, width - i, color); break;//顺时针90度
+                        case TextureFlip.逆时针90度: newTexture.SetPixel(height - j, i, color); break;//逆时针90度
+                        case TextureFlip.旋转180度: newTexture.SetPixel(width - i, height - j, color); break;//旋转180度
+                        case TextureFlip.水平翻转: newTexture.SetPixel(width - i, j, color); break;//水平翻转
+                        case TextureFlip.顺时针水平翻转: newTexture.SetPixel(height - j, width - i, color); break;//顺时针水平翻转
+                        case TextureFlip.逆时针水平翻转: newTexture.SetPixel(j, i, color); break;//逆时针水平翻转
+                        case TextureFlip.垂直翻转: newTexture.SetPixel(i, height - j, color); break;//垂直翻转
+                    }
+                }
+            }
+            newTexture.Apply();
+            return newTexture;
+        }
+
+
+        /// <summary>
+        /// Texture2D纹理裁剪
+        /// </summary>
+        /// <param name="texture2D">要裁剪的Texture2D</param>
+        /// <param name="x">裁剪x轴起点(原点为左下角)</param>
+        /// <param name="y">裁剪y轴起点(原点为左下角)</param>
+        /// <param name="width">裁剪图形宽度</param>
+        /// <param name="height">裁剪图形高度</param>
+        /// <returns>裁剪后的Texture2D纹理</returns>
+        public static Texture2D Texture2D_Shear(Texture2D texture2D, int x, int y, int width, int height)
+        {
+            Texture2D newTexture = new Texture2D(width, height);
+            newTexture.SetPixels(texture2D.GetPixels(x, y, width, height));
+            newTexture.Apply();
+            return newTexture;
+        }
+
+        // 从屏幕读取像素保存到纹理数据中。
+        // texture.ReadPixels(new Rect(0, 0, Screen.width, Screen.height), 0, 0, false);
+
+    }
+
+
+    public enum TextureFlip
+    {
+        无翻转,
+        顺时针90度,
+        逆时针90度,
+        旋转180度,
+
+        水平翻转,
+        顺时针水平翻转,
+        逆时针水平翻转,
+        垂直翻转
+
+    }
+
+}
diff --git a/SDHK_Tool/Static/SS_Texture.cs.meta b/SDHK_Tool/Static/SS_Texture.cs.meta
new file mode 100644
index 0000000..9ba916d
--- /dev/null
+++ b/SDHK_Tool/Static/SS_Texture.cs.meta
@@ -0,0 +1,13 @@
+fileFormatVersion: 2
+guid: 6d0ca2343d3bd6c4c8f8e8881862973d
+timeCreated: 1567748730
+licenseType: Pro
+MonoImporter:
+  externalObjects: {}
+  serializedVersion: 2
+  defaultReferences: []
+  executionOrder: 0
+  icon: {instanceID: 0}
+  userData: 
+  assetBundleName: 
+  assetBundleVariant: 
diff --git a/SDHK_Tool/Static/SS_Touch.cs b/SDHK_Tool/Static/SS_Touch.cs
new file mode 100644
index 0000000..e5b6a35
--- /dev/null
+++ b/SDHK_Tool/Static/SS_Touch.cs
@@ -0,0 +1,161 @@
+﻿using System.Collections;
+using System.Collections.Generic;
+using UnityEngine;
+using UnityEngine.EventSystems;
+
+/*
+ * 作者：闪电Y黑客
+ * 
+ * 日期： 2019.10.17
+ * 
+ * 功能：用于Touch的方法
+ */
+
+namespace SDHK_Tool.Static
+{
+
+    /// <summary>
+    /// 对Touch的处理
+    /// </summary>
+    public static class SS_Touch
+    {
+
+        /// <summary>
+        /// 触摸事件：按下
+        /// </summary>
+        /// <param name="gameObject">游戏物体</param>
+        /// <param name="eventData">触摸点</param>
+        public static void OnDown(GameObject gameObject, PointerEventData eventData)
+        {
+            ExecuteEvents.Execute(gameObject, eventData, ExecuteEvents.pointerDownHandler);
+        }
+
+        /// <summary>
+        /// 触摸事件：抬起
+        /// </summary>
+        /// <param name="gameObject">游戏物体</param>
+        /// <param name="eventData">触摸点</param>
+        public static void OnUp(GameObject gameObject, PointerEventData eventData)
+        {
+            ExecuteEvents.Execute(gameObject, eventData, ExecuteEvents.pointerUpHandler);
+        }
+
+        /// <summary>
+        /// 触摸事件：点击
+        /// </summary>
+        /// <param name="gameObject">游戏物体</param>
+        /// <param name="eventData">触摸点</param>
+        public static void OnClick(GameObject gameObject, PointerEventData eventData)
+        {
+            ExecuteEvents.Execute(gameObject, eventData, ExecuteEvents.pointerClickHandler);
+        }
+
+        /// <summary>
+        /// 触摸事件：进入停留
+        /// </summary>
+        /// <param name="gameObject">游戏物体</param>
+        /// <param name="eventData">触摸点</param>
+        public static void OnEnter(GameObject gameObject, PointerEventData eventData)
+        {
+            ExecuteEvents.Execute(gameObject, eventData, ExecuteEvents.pointerEnterHandler);
+        }
+
+        /// <summary>
+        /// 触摸事件：停留离开
+        /// </summary>
+        /// <param name="gameObject">游戏物体</param>
+        /// <param name="eventData">触摸点</param>
+        public static void OnExit(GameObject gameObject, PointerEventData eventData)
+        {
+            ExecuteEvents.Execute(gameObject, eventData, ExecuteEvents.pointerExitHandler);
+        }
+
+        /// <summary>
+        /// 触摸事件：开始拖拽
+        /// </summary>
+        /// <param name="gameObject">游戏物体</param>
+        /// <param name="eventData">触摸点</param>
+        public static void OnBeginDrag(GameObject gameObject, PointerEventData eventData)
+        {
+            ExecuteEvents.Execute(gameObject, eventData, ExecuteEvents.beginDragHandler);
+        }
+
+        /// <summary>
+        /// 触摸事件：结束拖拽
+        /// </summary>
+        /// <param name="gameObject">游戏物体</param>
+        /// <param name="eventData">触摸点</param>
+        public static void OnEndDrag(GameObject gameObject, PointerEventData eventData)
+        {
+            ExecuteEvents.Execute(gameObject, eventData, ExecuteEvents.endDragHandler);
+        }
+
+        /// <summary>
+        /// 触摸事件：拖拽
+        /// </summary>
+        /// <param name="gameObject">游戏物体</param>
+        /// <param name="eventData">触摸点</param>
+        public static void OnDrag(GameObject gameObject, PointerEventData eventData)
+        {
+            ExecuteEvents.Execute(gameObject, eventData, ExecuteEvents.dragHandler);
+        }
+
+        /// <summary>
+        /// 触摸事件：滚轮
+        /// </summary>
+        /// <param name="gameObject">游戏物体</param>
+        /// <param name="eventData">触摸点</param>
+        public static void OnScroll(GameObject gameObject, PointerEventData eventData)
+        {
+            ExecuteEvents.Execute(gameObject, eventData, ExecuteEvents.scrollHandler);
+        }
+
+
+        /// <summary>
+        /// 触摸事件转移：进入停留
+        /// </summary>
+        /// <param name="Current">当前物体</param>
+        /// <param name="Target">目标物体</param>
+        /// <param name="eventData">触摸点</param>
+        public static void Transfer_Enter(GameObject Current, GameObject Target, PointerEventData eventData)
+        {
+
+            ExecuteEvents.Execute(Current, eventData, ExecuteEvents.pointerExitHandler);//停留离开
+            ExecuteEvents.Execute(Target, eventData, ExecuteEvents.pointerEnterHandler);//进入停留
+            eventData.pointerEnter = Target;
+
+        }
+
+        /// <summary>
+        /// 触摸事件转移：按下
+        /// </summary>
+        /// <param name="Current">当前物体</param>
+        /// <param name="Target">目标物体</param>
+        /// <param name="eventData">触摸点</param>
+        public static void Transfer_Down(GameObject Current, GameObject Target, PointerEventData eventData)
+        {
+            ExecuteEvents.Execute(Current, eventData, ExecuteEvents.pointerUpHandler);//抬起
+            ExecuteEvents.Execute(Target, eventData, ExecuteEvents.pointerDownHandler);//按下
+
+            eventData.pointerDrag = Target;
+            eventData.pointerPress = Target;
+
+        }
+
+        /// <summary>
+        /// 触摸事件转移：开始拖拽
+        /// </summary>
+        /// <param name="Current">当前物体</param>
+        /// <param name="Target">目标物体</param>
+        /// <param name="eventData">触摸点</param>
+        public static void Transfer_Drag(GameObject Current, GameObject Target, PointerEventData eventData)
+        {
+            ExecuteEvents.Execute(Current, eventData, ExecuteEvents.endDragHandler);//停止拖拽
+            ExecuteEvents.Execute(Target, eventData, ExecuteEvents.beginDragHandler);//开始拖拽
+            eventData.pointerDrag = Target;
+        }
+
+    }
+
+
+}
\ No newline at end of file
diff --git a/SDHK_Tool/Static/SS_Touch.cs.meta b/SDHK_Tool/Static/SS_Touch.cs.meta
new file mode 100644
index 0000000..4055ebf
--- /dev/null
+++ b/SDHK_Tool/Static/SS_Touch.cs.meta
@@ -0,0 +1,13 @@
+fileFormatVersion: 2
+guid: e5140439bfde17d42b95ac32d612b8d1
+timeCreated: 1571278851
+licenseType: Pro
+MonoImporter:
+  externalObjects: {}
+  serializedVersion: 2
+  defaultReferences: []
+  executionOrder: 0
+  icon: {instanceID: 0}
+  userData: 
+  assetBundleName: 
+  assetBundleVariant: 
diff --git a/SDHK_Tool/Static/SS_TriggerMarker.cs b/SDHK_Tool/Static/SS_TriggerMarker.cs
new file mode 100644
index 0000000..1ecce8b
--- /dev/null
+++ b/SDHK_Tool/Static/SS_TriggerMarker.cs
@@ -0,0 +1,104 @@
+﻿using System;
+using UnityEngine;
+
+/*
+ * 作者：闪电Y黑客
+ * 
+ * 日期： 2019.6.11
+ * 
+ * 功能：状态标记
+ */
+
+namespace SDHK_Tool.Static
+{
+    /// <summary>
+    /// 标记器
+    /// </summary>
+    public static class SS_TriggerMarker
+    {
+        /// <summary>
+        /// 边缘检测：检测Switch是否发生变化,触发标记变成true一次 ; 用!Switch[与]运算过滤上下边缘
+        /// </summary>
+        /// <param name="Switch">主判断</param>
+        /// <param name="bit">标记位</param>
+        /// <returns>return :　触发标记</returns>
+        public static bool Edge(bool Switch, ref bool bit)
+        {
+            bool T = Switch && !bit;
+            bit = Switch;
+            return T;
+        }
+
+        /// <summary>
+        /// T触发器：Switch间隔变成true，可改变触发标记状态（false/true）
+        /// </summary>
+        /// <param name="Switch">主判断</param>
+        /// <param name="bit">标记位</param>
+        /// <param name="trigger">触发标记</param>
+        /// <returns>return :　触发标记</returns>
+        public static bool Trigger(bool Switch, ref bool bit, ref bool trigger)
+        {
+            if (Switch && !bit) trigger = !trigger;
+            bit = Switch;
+            return trigger;
+        }
+
+        /// <summary>
+        /// 累加计数器：判断累加数值，需要手动清零
+        /// </summary>
+        /// <param name="StartCount">计数位</param> 
+        /// <param name="TargetCount">设定数</param>
+        /// <param name="Cumulative">累加数</param>
+        /// <returns>return :　触发标记</returns>
+        public static bool Count(ref float StartCount, float TargetCount, float Cumulative)
+        {
+            if (StartCount <= TargetCount)
+            {
+                StartCount += Cumulative;
+                return false;
+            }
+            else
+            {
+                return true;
+            }
+        }
+
+        /// <summary>
+        /// 计时器：判断系统时间:DateTime.Now
+        /// </summary>
+        /// <param name="StartTime">计时位</param>
+        /// <param name="TargetSeconds">定时位（秒）</param>
+        /// <returns>return :　触发标记</returns>
+        public static bool Clock_System(DateTime StartTime, float TargetSeconds)
+        {
+
+            return ((DateTime.Now - StartTime).TotalSeconds > TargetSeconds);
+        }
+
+        /// <summary>
+        /// 计时器：判断游戏时间:Time.unscaledTime
+        /// </summary>
+        /// <param name="StartTime">计时位</param>
+        /// <param name="TargetSeconds">定时位（秒）</param>
+        /// <returns>return :　触发标记</returns>
+        public static bool Clock_Game(float StartTime, float TargetSeconds)
+        {
+
+            return ((Time.unscaledTime - StartTime) > TargetSeconds);
+        }
+
+        /// <summary>
+        /// 计时器：判断游戏世界时间:Time.time（被TimeScale影响）
+        /// </summary>
+        /// <param name="StartTime">计时位</param>
+        /// <param name="TargetSeconds">定时位（秒）</param>
+        /// <returns>return :　触发标记</returns>
+        public static bool Clock_GameWorld(float StartTime, float TargetSeconds)
+        {
+            return ((Time.time - StartTime) > TargetSeconds);
+        }
+
+
+    }
+}
+
diff --git a/SDHK_Tool/Static/SS_TriggerMarker.cs.meta b/SDHK_Tool/Static/SS_TriggerMarker.cs.meta
new file mode 100644
index 0000000..4cfead5
--- /dev/null
+++ b/SDHK_Tool/Static/SS_TriggerMarker.cs.meta
@@ -0,0 +1,13 @@
+fileFormatVersion: 2
+guid: 5de3748fa9a46e24da8f29d38e895301
+timeCreated: 1560246956
+licenseType: Free
+MonoImporter:
+  externalObjects: {}
+  serializedVersion: 2
+  defaultReferences: []
+  executionOrder: 0
+  icon: {instanceID: 0}
+  userData: 
+  assetBundleName: 
+  assetBundleVariant: 
diff --git a/Component/TUIO.meta b/SDHK_Tool/XunFei_Tool/SDK/bin/ise_cn.meta
similarity index 70%
rename from Component/TUIO.meta
rename to SDHK_Tool/XunFei_Tool/SDK/bin/ise_cn.meta
index 1c44bb7..bf38477 100644
--- a/Component/TUIO.meta
+++ b/SDHK_Tool/XunFei_Tool/SDK/bin/ise_cn.meta
@@ -1,7 +1,7 @@
 fileFormatVersion: 2
-guid: 4659662200bd52a4f9292247e25a11a3
+guid: 57f414ea0da67bc46aced2f7ba4dec06
 folderAsset: yes
-timeCreated: 1576480925
+timeCreated: 1577437607
 licenseType: Pro
 DefaultImporter:
   externalObjects: {}
diff --git a/Component/Touch/Base.meta b/SDHK_Tool/XunFei_Tool/SDK/bin/ise_en.meta
similarity index 70%
rename from Component/Touch/Base.meta
rename to SDHK_Tool/XunFei_Tool/SDK/bin/ise_en.meta
index 7fc87b4..664f514 100644
--- a/Component/Touch/Base.meta
+++ b/SDHK_Tool/XunFei_Tool/SDK/bin/ise_en.meta
@@ -1,7 +1,7 @@
 fileFormatVersion: 2
-guid: 9ee5bdbee3674134ebae75e47c3da213
+guid: 698107fa3e9644146adef1ce34b8b0b0
 folderAsset: yes
-timeCreated: 1571306157
+timeCreated: 1577437607
 licenseType: Pro
 DefaultImporter:
   externalObjects: {}
diff --git a/Component/Touch/CanvasMode.meta b/SDHK_Tool/XunFei_Tool/SDK/bin/msc.meta
similarity index 70%
rename from Component/Touch/CanvasMode.meta
rename to SDHK_Tool/XunFei_Tool/SDK/bin/msc.meta
index 69066d3..4b16e4e 100644
--- a/Component/Touch/CanvasMode.meta
+++ b/SDHK_Tool/XunFei_Tool/SDK/bin/msc.meta
@@ -1,7 +1,7 @@
 fileFormatVersion: 2
-guid: 00472e0d50026384ca4b19e64d70d557
+guid: d89ad86c2809fb14c904d49107773c5e
 folderAsset: yes
-timeCreated: 1570788665
+timeCreated: 1577437607
 licenseType: Pro
 DefaultImporter:
   externalObjects: {}
diff --git a/Component/Touch/TouchTransfer.meta b/SDHK_Tool/XunFei_Tool/SDK/bin/wav.meta
similarity index 70%
rename from Component/Touch/TouchTransfer.meta
rename to SDHK_Tool/XunFei_Tool/SDK/bin/wav.meta
index 242b6e1..b7c08ae 100644
--- a/Component/Touch/TouchTransfer.meta
+++ b/SDHK_Tool/XunFei_Tool/SDK/bin/wav.meta
@@ -1,7 +1,7 @@
 fileFormatVersion: 2
-guid: c9ab321961ee05148965b4e76c9b4e2e
+guid: 34e66cf12f066f840b9d9c73ea776337
 folderAsset: yes
-timeCreated: 1571306466
+timeCreated: 1577437607
 licenseType: Pro
 DefaultImporter:
   externalObjects: {}
diff --git a/Static/File.meta b/Static/File.meta
deleted file mode 100644
index 06d9e73..0000000
--- a/Static/File.meta
+++ /dev/null
@@ -1,10 +0,0 @@
-fileFormatVersion: 2
-guid: 645d48de39e8f964e9aaa96bcdad5d4f
-folderAsset: yes
-timeCreated: 1574414376
-licenseType: Pro
-DefaultImporter:
-  externalObjects: {}
-  userData: 
-  assetBundleName: 
-  assetBundleVariant: 
